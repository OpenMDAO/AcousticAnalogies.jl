var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = AADocs","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [AcousticAnalogies]","category":"page"},{"location":"api/#AcousticAnalogies.AcousticObserver","page":"API Reference","title":"AcousticAnalogies.AcousticObserver","text":"Supertype for an object that recieves a noise prediction when combined with an acoustic analogy source; computational equivalent of a microphone.\n\n(obs::AcousticObserver)(t)\n\nCalculate the position of the acoustic observer at time t.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.CompactSourceElement-NTuple{10, Any}","page":"API Reference","title":"AcousticAnalogies.CompactSourceElement","text":"CompactSourceElement(ρ0, c0, r, θ, Δr, Λ, fn, fc, τ)\n\nConstruct a source element to be used with the compact form of Farassat's formulation 1A.\n\nArguments\n\nρ0: Ambient air density (kg/m^3)\nc0: Ambient speed of sound (m/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nΛ: cross-sectional area of the element (m^2)\nfn: normal load per unit span on the fluid (N/m)\nfr: radial load on the fluid (N/m)\nfc: circumferential load on the fluid (N/m)\nτ: source time (s)\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CompactSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Vararg{Any, 4}}","page":"API Reference","title":"AcousticAnalogies.CompactSourceElement","text":"CompactSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, area_per_chord2, τ)\n\nConstruct a source element to be used with the compact form of Farassat's formulation 1A from CCBlade objects.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.precone.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element.\narea_per_chord2: cross-sectional area divided by the chord squared of the element.\nτ: source time of the element.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.ConstVelocityAcousticObserver","page":"API Reference","title":"AcousticAnalogies.ConstVelocityAcousticObserver","text":"ConstVelocityAcousticObserver(t0, x0, v)\n\nConstruct an acoustic observer moving with a constant velocity v, located at x0 at time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1AOutput","page":"API Reference","title":"AcousticAnalogies.F1AOutput","text":"Output of the F1A calculation: the acoustic pressure value at time t, broken into monopole component p_m and dipole component p_d.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1APressureTimeHistory","page":"API Reference","title":"AcousticAnalogies.F1APressureTimeHistory","text":"F1APressureTimeHistory(apth::AbstractArray{<:F1AOutput}, period::AbstractFloat, n::Integer, axis::Integer=1)\n\nConstruct an F1APressureTimeHistory struct suitable for containing an acoustic prediction from an array of F1AOutput struct.\n\nThe elapsed time and length of the returned F1APressureTimeHistory will be period and n, respectively. axis indicates which axis the apth structs time varies. (period, n, axis are passed to common_obs_time.)\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1APressureTimeHistory-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"API Reference","title":"AcousticAnalogies.F1APressureTimeHistory","text":"F1APressureTimeHistory([T=Float64,] n, dt, t0)\n\nConstruct an F1APressureTimeHistory struct suitable for containing an acoustic prediction of length n, starting at time t0 with time step dt.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.StationaryAcousticObserver","page":"API Reference","title":"AcousticAnalogies.StationaryAcousticObserver","text":"StationaryAcousticObserver(x)\n\nConstruct an acoustic observer that does not move with position x (m).\n\n\n\n\n\n","category":"type"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Tuple{AcousticAnalogies.CompactSourceElement}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::CompactSourceElement)\n\nTransform the position and forces of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.adv_time-Tuple{AcousticAnalogies.CompactSourceElement, AcousticAnalogies.AcousticObserver}","page":"API Reference","title":"AcousticAnalogies.adv_time","text":"adv_time(se::CompactSourceElement, obs::AcousticObserver)\n\nCalculate the time an acoustic wave emmited by source se at time se.τ is recieved by observer obs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.combine","page":"API Reference","title":"AcousticAnalogies.combine","text":"combine(apth::AbstractArray{<:F1AOutput}, period::AbstractFloat, n::Integer, axis=1; f_interp=akima)\n\nCombine the acoustic pressures of multiple sources (apth) into a single acoustic pressure time history on a time grid of size n extending over time length period.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.combine!-Tuple{Any, Any, Any}","page":"API Reference","title":"AcousticAnalogies.combine!","text":"combine!(apth_out::F1APressureTimeHistory, apth::AbstractArray{<:F1AOutput}, axis; f_interp=akima)\n\nCombine the acoustic pressures of multiple sources (apth) into a single acoustic pressure time history apth_out.\n\nThe input acoustic pressures apth are interpolated onto the time grid returned by time(apth_out). The interpolation is performed by the function f_intep(xpt, ypt, x), where xpt and ytp are the input grid and function values, respectively, and x is the output grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.common_obs_time","page":"API Reference","title":"AcousticAnalogies.common_obs_time","text":"common_obs_time(apth::AbstractArray{<:F1AOutput}, period, n, axis=1)\n\nReturn a suitable time range for the collection of F1A acoustic pressures in apth.\n\nThe time range will begin near the latest start time of the acoustic pressures in apth, and be an AbstractVector (really a StepRangeLen) of size n and of time length period. axis indicates which axis of apth the time for a source varies.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.endpoints-Tuple{AcousticAnalogies.CompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.endpoints","text":"endpoints(se::CompactSourceElement)\n\nReturn the Tuple containing the endpoint locations of the compact source element se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.f1a-Tuple{AcousticAnalogies.CompactSourceElement, AcousticAnalogies.AcousticObserver, Any}","page":"API Reference","title":"AcousticAnalogies.f1a","text":"f1a(se::CompactSourceElement, obs::AcousticObserver, t_obs)\n\nCalculate the acoustic pressure emitted by source element se and recieved by observer obs at time t_obs, returning an F1AOutput object.\n\nThe correct value for t_obs can be found using adv_time.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.f1a-Tuple{AcousticAnalogies.CompactSourceElement, AcousticAnalogies.AcousticObserver}","page":"API Reference","title":"AcousticAnalogies.f1a","text":"f1a(se::CompactSourceElement, obs::AcousticObserver)\n\nCalculate the acoustic pressure emitted by source element se and recieved by observer obs, returning an F1AOutput object.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.get_ccblade_dradii-Tuple{Any, Any}","page":"API Reference","title":"AcousticAnalogies.get_ccblade_dradii","text":"get_ccblade_dradii(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section})\n\nConstruct and return a Vector of the lengths of each CCBlade section.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.get_dradii-Tuple{Any, Any, Any}","page":"API Reference","title":"AcousticAnalogies.get_dradii","text":"get_dradii(radii, Rhub, Rtip)\n\nCompute the spacing between blade elements given the radial locations of the element midpoints in radii and the hub and tip radius in Rhub and Rtip, respectively.\n\nAssume the interfaces between elements are midway between adjacent element's midpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.source_elements_ccblade-NTuple{7, Any}","page":"API Reference","title":"AcousticAnalogies.source_elements_ccblade","text":"source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, area_per_chord2::Vector{AbstractFloat}, period, num_src_times)\n\nConstruct and return an array of CompactSourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.precone).\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs::Vector of CCBlade output objects.\narea_per_chord2: cross-sectional area divided by the chord squared of the element at each CCBlade.section. Should be a Vector{AbstractFloat}, same length as sections, ops, outputs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.to_paraview_collection","page":"API Reference","title":"AcousticAnalogies.to_paraview_collection","text":"to_paraview_collection(name::AbstractString, ses::AbstractArray{<:CompactSourceElement}, axis::Integer=1)\n\nConstruct and write out a ParaView collection data file (.pvd) object for an array of CompactSourceElement with name name.pvd (i.e., the name argument should not contain a file extension).\n\naxis indicates the axis of ses over which the source time for the source elements in ses vary. One VTK PolyData (.vtp) file will be written for each valid index along axis.\n\nReturns a list of filenames written out by WriteVTK.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.to_vtp-Tuple{Any, AbstractArray{<:AcousticAnalogies.CompactSourceElement}}","page":"API Reference","title":"AcousticAnalogies.to_vtp","text":"to_vtp(name::AbstractString, ses::AbstractArray{<:CompactSourceElement})\n\nConstruct and return a VTK polygonal (.vtp) data file object for an array of CompactSourceElement with name name.vtp (i.e., the name argument should not contain a file extension).\n\n\n\n\n\n","category":"method"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"CurrentModule = AADocs","category":"page"},{"location":"guided_example/#guided_example","page":"Guided Example","title":"Compact Formulation 1A Guided Example","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"There are four steps to predicting propeller/rotor noise with AcousticAnalogies.jl.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Define the blade's motion and loading as a function of source time\nPerform the advanced time calculation\nPropagate the acoustics caused by each blade section to the acoustic observer(s) using the F1A formulation\nCombine all the acoustic pressures resulting from step 3 into one acoustic pressure time history","category":"page"},{"location":"guided_example/#1.-Define-the-Blade","page":"Guided Example","title":"1. Define the Blade","text":"","category":"section"},{"location":"guided_example/#The-Blade-Fixed-Reference-Frame","page":"Guided Example","title":"The Blade-Fixed Reference Frame","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We need to know what the blade is doing aerodynamically before we can predict how loud it is.  Specifically, we need to know at each radial station along each blade the","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"position\nvelocity\nacceleration\njerk (time derivative of acceleration)\ncross-sectional area\nloading per unit span","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"all as a function of time. We'll do this first in a reference frame moving with the blades, i.e., translating and rotating with the blade geometry, that we'll call the blade-fixed reference frame.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"First step is to load up AcousticAnalogies.jl:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticAnalogies","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So, for this example we'll imagine that we have a blade with radial stations that look like this:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"num_blades = 2  # number of blades\nRhub = 0.10  # meters\nRtip = 1.1684  # meters\nradii = [\n    0.92904E-01, 0.11751, 0.15631, 0.20097,\n    0.24792    , 0.29563, 0.34336, 0.39068,\n    0.43727    , 0.48291, 0.52741, 0.57060,\n    0.61234    , 0.65249, 0.69092, 0.72752,\n    0.76218    , 0.79479, 0.82527, 0.85352,\n    0.87947    , 0.90303, 0.92415, 0.94275,\n    0.95880    , 0.97224, 0.98304, 0.99117,\n    0.99660    , 0.99932].*Rtip\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"radii is a Vector of the distance of each blade element's center from the propeller hub, in meters.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Each of the num_blades blades have the same radial coordinates in the blade-fixed frame, but different angular coordinates: blade number 2 will be offset 180° from blade number 1.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"θs = 2*pi/num_blades.*(0:(num_blades-1))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So now we know where each blade element is in the blade-fixed frame: in polar coordinates, element at radial index j and blade k is at radii[j], θs[k].","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We'll also need the length of each blade element. There is a convenience function in AcousticAnalogies.jl called get_dradii that calculates each blade element's length from the element centers and the hub and tip location:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"dradii = get_dradii(radii, Rhub, Rtip)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The compact F1A calculation also requires the cross-sectional area of each element. In many types of propeller codes, the cross-sectional shape at each radial station is defined as having a certain standard shape (e.g., circular near the hub, a given airfoil shape elsewhere).  If we know the cross-sectional area for each relevant airfoil shape with a chord length of one, we can find the cross-sectional area for any chord length by multiplying by the squared chord length. In this example we'll assume the blade uses the same airfoil shape at each radial station, and that this airfoil has a cross-sectional area per unit chord squared of 0.064. After defining the chord length for each radial station, we find the cross-sectional area in units of meters squared:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"cs_area_over_chord_squared = 0.064\nchord = [\n    0.35044     , 0.28260     , 0.22105     , 0.17787     , 0.14760,\n    0.12567     , 0.10927     , 0.96661E-01 , 0.86742E-01 ,\n    0.78783E-01 , 0.72287E-01 , 0.66906E-01 , 0.62387E-01 ,\n    0.58541E-01 , 0.55217E-01 , 0.52290E-01 , 0.49645E-01 ,\n    0.47176E-01 , 0.44772E-01 , 0.42326E-01 , 0.39732E-01 ,\n    0.36898E-01 , 0.33752E-01 , 0.30255E-01 , 0.26401E-01 ,\n    0.22217E-01 , 0.17765E-01 , 0.13147E-01 , 0.85683E-02 ,\n    0.47397E-02].*Rtip\ncs_area = cs_area_over_chord_squared.*chord.^2\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Next, we need the loading on the blade. AcousticAnalogies.jl needs us to specify the loading at each radial station as a 3D vector in units of loading per unit span. But for now, let's imagine that we've run some type of propeller aerodynamic code (I used CCBlade.jl, FYI) and have the normal and circumferential loading as a function of radial position along the blade. The loading is in units of force per unit span (here, Newtons/meter).","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"fn = [32.87810395677037, 99.05130471878633, 190.1751697055377,\n      275.9492967565419, 358.14423433748146, 439.64679797145624,\n      520.1002808148281, 599.1445046901513, 676.2358818769462,\n      751.3409657831587, 824.2087672338118, 894.4465814696498,\n      961.9015451678036, 1026.0112737521583, 1086.2610633094212,\n      1141.4900032393818, 1190.3376703335655, 1230.8999662260915,\n      1260.375390697363, 1275.354422403355, 1271.8827617273287,\n      1245.9059108698596, 1193.9967137923225, 1113.9397490286995,\n      1005.273267675585, 869.4101036003673, 709.8100230053759,\n      532.1946243370355, 346.53986082379265, 180.66763939805125]\n\nfc = [26.09881302938423, 55.5216259955307, 75.84767780212506, 84.84509232798283,\n      89.73045068624886, 93.02999477395113, 95.4384273852926, 97.31647535460424,\n      98.81063179767507, 100.07617771995163, 101.17251941705561, 102.11543878532882,\n      102.94453631586998, 103.63835661864168, 104.18877957193807, 104.51732850056433,\n      104.54735678589765, 104.1688287897138, 103.20319203286938, 101.46246817378582,\n      99.11692436681635, 96.49009546562475, 93.45834266417528, 89.49783586366624,\n      83.87176811707455, 75.83190739325453, 64.88004605331857, 50.98243352318318,\n      34.85525518071079, 19.358679206883078]\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We also need to decide on some atmospheric properties, specifically the ambient air density and speed of sound.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"rho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"And we need to decide on some operating point parameters. Let's assume that the blade is moving forward at 5.0 m/s and rotating at 2200 rev/min.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"v = 0.0  # m/s\nomega = 2200 * 2*pi/60  # rad/s\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We also need to decide over what time period we're going to calculate the blades' acoustics. Let's do one rotation of the blade:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"period = 2*pi/omega\nnum_src_times = 64\ndt = 2*period/(num_src_times-1)\nsrc_times = (0:num_src_times-1).*dt\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So at this point we have all the information needed to define the source elements in a frame of reference that's moving with the blade, i.e., rotating at a rate of omega and moving forward at a speed of v defined above. Let's do that. We want one source element for each radial station along the blade at each src_time and each of the num_blades blades. Sounds kind of complicated, but luckily Julia's broadcasting makes this easy. What we'd like is an array ses of CompactSourceElement types that has size (num_src_times, num_radial, num_blades), where ses[i, j, k] holds the CompactSourceElement at src_time[i], radii[j], and blade number k. So let's reshape the input arrays to make that happen.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"θs = reshape(θs, 1, 1, :)\nradii = reshape(radii, 1, :, 1)\ndradii = reshape(dradii, 1, :, 1)\ncs_area = reshape(cs_area, 1, :, 1)\nfn = reshape(fn, 1, :, 1)\nfc = reshape(fc, 1, :, 1)\nsrc_times = reshape(src_times, :, 1, 1)  # This isn't really necessary.\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, the last thing we need to think about is the coordinate system we're defining these quantities in. Again, right now we are in the blade-fixed frame, which means the coordinate system is rotating with the blades at a rate of omega and translating with a velocity v in the positive x direction. The CompactSourceElement constructor we'll use allows us to specify each source element's location in terms of r and θ, where r is the distance from the origin and θ is the polar angle from the positive y axis, rotating toward the positive z axis. So the radii and θs arrays are set up correctly. ","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, one of the tricky aspects of using an acoustic analogy is getting the direction of the loading on the integration surface (or line in the case of a compact formulation) right. An acoustic analogy requires the loading on the fluid, not on the solid body. One might expect that we just need to switch the sign on the fn and fc arrays above. That's true for the fn array, which represents the loading in the axial direction: if we imagine our propeller is moving in the positive x direction, the propeller would be pushing on the fluid in the negative x direction in normal operation. But what about the circumferential loading? In the blade-fixed frame, we assume the propeller is rotating about the x axis in a positive (i.e., right-handed) sense. So, if we imagine the situation for θ=0, the blade will be initially along the positive y axis, rotating toward the positive z axis. What direction will the circumferential loading on the fluid be? It will be positive, pointing in the same direction as the positive z axis. So we don't need to switch the sign on the fc array.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So let's create all the source elements:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = CompactSourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times)\nsize(ses)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The size of the source element array ended up like we wanted: (num_src_times, num_radial, num_blades).","category":"page"},{"location":"guided_example/#The-Global-Reference-Frame","page":"Guided Example","title":"The Global Reference Frame","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"At this point we have an array of CompactSourceElement that describes the what each blade element \"source\" is doing from the perspective of the blade-fixed reference frame. But in order to perform the F1A calculation, we need to move the sources from the blade-fixed frame to the global reference frame, i.e., the one for which the fluid medium (air) appears to be stationary. This involves just setting the position and loading components of each CompactSourceElement to the correct values (y0dot through y3dot and f0dot and f1dot). This could be done manually, but it's easier to use the KinematicCoordinateTransformations.jl package.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The first transformation we need to perform is a steady rotation around the x axis. So we create a SteadyRotXTransformation:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using KinematicCoordinateTransformations\nt0 = 0.0  # Time at which the angle between the source and target coordinate systems is equal to offest.\noffset = 0.0  # Angular offset between the source and target cooridante systems at t0.\nrot_trans = SteadyRotXTransformation(t0, omega, offset)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Next, we need to orient the rotation axis of the blades as it is the global frame. For example, let's say that it's pointed in the global positive z-axis direction, and the first blade is pointed in the positive y-axis direction. Then we can perform this transformation using the ConstantLinearMap transformation:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using LinearAlgebra: ×\nusing StaticArrays\nrot_axis = @SVector [0.0, 0.0, 1.0]\nblade_axis = @SVector [0.0, 1.0, 0.0]\nglobal_trans = ConstantLinearMap(hcat(rot_axis, blade_axis, rot_axis×blade_axis))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Finally, we need the blade to move with the appropriate forward velocity, and start from the desired location in the global reference frame:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"y0_hub = @SVector [0.0, 0.0, 0.0]  # Position of the hub at time t0\nv0_hub = SVector{3}(v.*rot_axis)   # Constant velocity of the hub in the global reference frame\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now we could apply each of these transformations to the SourceElement array. But it's more efficient to combine these three transformations into one, and then use that on the SourceElements using compose.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"trans = compose.(src_times, Ref(const_vel_trans), compose.(src_times, Ref(global_trans), Ref(rot_trans)))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now trans will perform the three transformations from right to left (rot_trans, global_trans, const_vel_trans). Now we use it on ses:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = ses .|> trans\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So now the ses has been transformed from the blade-fixed reference frame to the global reference frame. We could have created the source elements and transformed them all in one line, too, which is pretty slick:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = AcousticAnalogies.CompactSourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times) .|> trans\nnothing # hide","category":"page"},{"location":"guided_example/#2.-Perform-the-Advanced-Time-Calculation","page":"Guided Example","title":"2. Perform the Advanced Time Calculation","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The ses object now describes how each blade element source is moving through the global reference frame over the time src_time. As it does this, it will emit acoustics that can be sensed by an acoustic observer (a human, or a microphone). The exact \"amount\" of acoustics the observer will experience depends on the relative location and motion between each source and the observer. So we'll need to define our acoustic observer before we can calculate the noise heard by it. For this example, we'll assume that our acoustic observer is stationary in the global frame.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"x0 = @SVector [100*12*0.0254, 0.0, 0.0]  # 100 ft in meters\nobs = StationaryAcousticObserver(x0)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, in order to perform the F1A calculation, we need to know when each acoustic disturbance emitted by the source arrives at the observer. This is referred to an  advanced time calculation, and is done this way:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"obs_time = adv_time.(ses, Ref(obs))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"That returns an array the same size of ses of the time each acoustic disturbance reaches the observer obs:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"@show size(obs_time)\nnothing # hide","category":"page"},{"location":"guided_example/#3.-Perform-the-F1A-Calculation","page":"Guided Example","title":"3. Perform the F1A Calculation","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We're finally ready to do the compact F1A calculation!","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"apth = f1a.(ses, Ref(obs), obs_time)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"When called this way (notice the . after f1a), the f1a routine returns an array of F1AOutput structs, the same size as ses and obs_time. Each F1AOutput struct has three components: the observer time t, the thickness/monopole part of the acoustic pressure p_m, and the loading/dipole part of the acoustic pressure p_d.","category":"page"},{"location":"guided_example/#4.-Combine-the-Acoustic-Pressures","page":"Guided Example","title":"4. Combine the Acoustic Pressures","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We now have a noise prediction for each of the individual source elements in ses at the acoustic observer obs. What we ultimately want is the total noise prediction at obs—we want to add all the acoustic pressures in apth together. But we can't add them directly, yet, since the observer times are not all the same. What we need to do is first interpolate the apth of each source onto a common observer time grid, and then add them up. We'll do this using the AcousticAnalogies.combine function.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"bpp = period/num_blades  # blade passing period\nobs_time_range = 2*bpp\nnum_obs_times = 128\napth_total = combine(apth, obs_time_range, num_obs_times, 1)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"combine returns a single F1AAcousticPressure struct made up of Vectors—it is an \"struct of arrays\" and not an \"array of structs\" like apth:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"@show typeof(apth) typeof(apth_total)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We can now have a look at the total acoustic pressure time history at the observer:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticMetrics\nusing GLMakie\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"monopole, Pa\")\nax2 = fig[2, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"dipole, Pa\")\nax3 = fig[3, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"total, Pa\")\nt_nondim = (AcousticMetrics.time(apth_total) .- AcousticMetrics.starttime(apth_total))./bpp\nl1 = lines!(ax1, t_nondim, apth_total.p_m)\nl2 = lines!(ax2, t_nondim, apth_total.p_d)\nl3 = lines!(ax3, t_nondim, apth_total.p_m.+apth_total.p_d)\nhidexdecorations!(ax1, grid=false)\nhidexdecorations!(ax2, grid=false)\nsave(\"first_example-apth_total.png\", fig)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"(Image: )","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We can now post-process the total acoustic pressure time history in apth_total in any way we'd like.","category":"page"},{"location":"guided_example/#AcousticMetrics.jl-Support","page":"Guided Example","title":"AcousticMetrics.jl Support","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The combine function returns a F1AAcousticPressure struct, which subtypes the AbstractAcousticPressure type from the AcousticMetrics.jl package. Because of this, any of the acoustic metric functions defined in AcousticMetrics.jl relevant to AbstractAcousticPressure objects can be used with the F1AAcousticPressure returned by combine:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticMetrics\n# Calculate the overall sound pressure level from the acoustic pressure time history.\noaspl_from_apth = AcousticMetrics.OASPL(apth_total)\n# Calculate the narrowband spectrum.\nnbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)\n# Calculate the OASPL from the NBS.\noaspl_from_nbs = AcousticMetrics.OASPL(nbs)\n(oaspl_from_apth, oaspl_from_nbs)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The two approaches to calculate the OASPL give essentially the same result.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"CurrentModule = AADocs","category":"page"},{"location":"sqa/#Software-Quality-Assurance","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"","category":"section"},{"location":"sqa/#Tests","page":"Software Quality Assurance","title":"Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticAnalogies.jl uses the usual Julia testing framework to implement and run tests. The tests can be run locally after installing AcousticAnalogies.jl, and are also run automatically on GitHub Actions.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"To run the tests locally, from the Julia REPL, type ] to enter the Pkg prompt, then","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(jl_jncZ1E) pkg> test AcousticAnalogies\n     Testing Running tests...\nTest Summary:       | Pass  Total  Time\nAdvanced time tests |    2      2  7.0s\nTest Summary:           | Pass  Total  Time\nCombine F1AOutput tests |    8      8  2.7s\nTest Summary: | Pass  Total  Time\nF1A tests     |    2      2  5.9s\nTest Summary:               | Pass  Total  Time\nCCBlade private utils tests |    1      1  0.3s\nTest Summary:                     | Pass  Total  Time\nCCBlade CompactSourceElement test |   12     12  3.4s\nTest Summary:     | Pass  Total  Time\nANOPP2 Comparison |  176    176  5.9s\nTest Summary:    | Time\nForwardDiff test | None  14.1s\n     Testing AcousticAnalogies tests passed\n\n(jl_jncZ1E) pkg> ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(The output associated with installing all the dependencies the tests need isn't shown above.)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Here is a description of each category of test:","category":"page"},{"location":"sqa/#Advanced-Time-Tests","page":"Software Quality Assurance","title":"Advanced Time Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The F1A calculation is concerned with roughly two types of objects: acoustic sources and acoustic observers. Acoustic sources are things that make noise, and, for AcousticAnalogies.jl, would typically be a portion of some type of aerodynamic lifting surface (like a propeller blade). An acoustic observer is just a fancy name for a person or microphone that will hear the noise emitted by the source. Both the source and observer may be stationary, but more likely will be moving.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"During the F1A calculation, we need to know the time at which an acoustic wave emitted by the source encounters the observer. Mathematically, we need to solve the equation","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"R(t) = t - left( tau + fracvecx(t) - vecy(τ)c_0 right) = 0","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"whereon","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"τ is the time the source has emitted an acoustic disturbance\nt is the time the observer encounters the acoustic disturbance\nvecy is the position of the source\nvecx is the position of the observer\nc_0 is the speed of sound","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticAnalogies.jl currently uses an advanced time approach to solving this equation. This means we start with knowledge of tau and then calculate t—we \"advance\" the source time to the observer time by adding the amount of time it takes for the acoustic disturbance to travel from y to x.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Now, the R(t) = 0 equation is quite easy to solve if the observer is stationary. In that case, x is not a function of t, and so solving for t just involves moving everything in the parenthesis to the right-hand side. But if the observer is moving, things are more complicated. It may be impossible to solve for t explicitly in that case. It turns out, however, that there is an explicit solution for t in the advanced time approach if the observer is moving at a constant rate (see D. Casolino http://dx.doi.org/10.1016/S0022-460X(02)00986-0). The constant velocity case is actually quite handy, since it's what we need to compare to wind tunnel data.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"So, how do we test that we've implemented the solution to the R(t) = 0 advanced time equation correctly? In AcousticAnalogies.jl, we just use the nonlinear solver provided by NLsolve.jl, and compare its solution to AcousticAnalogies.jl. Here's how to do that:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies: AcousticAnalogies\nusing LinearAlgebra: norm\nusing NLsolve: NLsolve\nusing StaticArrays\n\n# Create a source element for the test.\n# The only things about the source element that matters to the advanced # time calculation is the time and position, and the speed of sound.\n# So everything else will be take on dummy values.\nτ = 2.5\ny = @SVector [-4.0, 3.0, 6.0]\nc0 = 2.0\ndummy0 = 1.0\ndummy3 = @SVector [0.0, 0.0, 0.0]\nse = AcousticAnalogies.CompactSourceElement(dummy0, c0, dummy0, dummy0, y, dummy3, dummy3, dummy3, dummy3, dummy3, τ, dummy3)\n\n# Define a function that solves the advanced time equation using `nlsolve.\nfunction adv_time_nlsolve(se, obs)\n    # Create the residual equation that we'll solve.\n    # nlsolve assumes the residual function takes in and returns arrays.\n    R(t) = [t[1] - (se.τ + norm(obs(t[1]) .- se.y0dot)/se.c0)]\n\n    # Solve the advanced time equation.\n    result = NLsolve.nlsolve(R, [1.0], autodiff=:forward)\n    if !NLsolve.converged(result)\n        @error \"nlsolve advanced time calculation did not converge:\\n$(result)\"\n    end\n    t_obs = result.zero[1]\n    return t_obs\nend\n\n# Let's try it out.\n\n# First, a stationary observer:\nx0 = @SVector [-3.0, 2.0, 8.5]\nobs = AcousticAnalogies.StationaryAcousticObserver(x0)\nt_exact = AcousticAnalogies.adv_time(se, obs)\nt_nlsolve = adv_time_nlsolve(se, obs)\nprintln(\"stationary observer, exact: $(t_exact), nlsorve: $(t_nlsolve), difference = $(t_exact - t_nlsolve)\")\n\n# Next, a constant velocity observer:\nt0 = 3.5\nx0 = @SVector [-2.0, 3.5, 6.25]\nv = @SVector [-1.5, 1.5, 3.25]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0, x0, v)\nt_exact = AcousticAnalogies.adv_time(se, obs)\nt_nlsolve = adv_time_nlsolve(se, obs)\nprintln(\"constant velocity observer, exact: $(t_exact), nlsorve: $(t_nlsolve), difference = $(t_exact - t_nlsolve)\")","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Almost identical results, so things are good!","category":"page"},{"location":"sqa/#Combine-F1AOutput-Tests","page":"Software Quality Assurance","title":"Combine F1AOutput Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The function f1a(se::CompactSourceElement, obs::AcousticObserver) uses Farassat's formulation 1A to perform a prediction of the noise experienced by one observer obs due to one acoustic source se. Typically we will not have just one source, however. For example, the guided example in the docs uses 30 \"source elements\" to model each propeller blade. But we're interested in the acoustics experienced by obs due to all of the source elements, not just one. So, we need to combine the output of f1a for one observer and all of the source elements. In AcousticAnalogies.jl, this is done by interpolating the time history of each source element's acoustics (the \"pressure time history\") onto a common chunk of time, and then adding them up. No big deal.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"But, how do we test the \"interpolating and adding\" routine, aka AcousticAnalogies.combine? That's pretty simple, actually: we just define some arbitrary functions that we'll use to create some pressure time histories, add them using the combine routine, and then compare that result to those created via evaluating those arbitrary functions on the same time grid used by the combine routine. If those match, then the test passes, and everything in the combine routine should be good. Let's try that:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing GLMakie\nusing Random\n\n# Goal is to verify that the code can faithfully combine two acoustic pressures on different time \"grids\" onto a single common grid.\n# These will be our made up functions:\nfa(t) = sin(2*pi*t) + 0.2*cos(4*pi*(t-0.1))\nfb(t) = cos(6*pi*t) + 0.3*sin(8*pi*(t-0.2))\n\n# Now we'll make some made up time grids.\nn = 101\nt1 = collect(range(0.0, 1.0, length=n))\ndt = t1[2] - t1[1]\n# Add a bit of random noise to the time grid.\n# Make sure that the amount of # randomness isn't large enough to make the time values non-monotonically increasing (i.e., they don't overlap).\nnoise = 0.49.*dt.*(1 .- 2 .* rand(size(t1)...))\nt1 .+= noise\n\nt2 = collect(range(0.1, 1.1, length=n))\ndt = t2[2] - t2[1]\nt2 .+= 0.49.*dt.*(1 .- 2 .* rand(size(t2)...))\n\n# Now let's create a bunch of pressure time histories on the time grids we just defined.\napth1 = @. AcousticAnalogies.F1AOutput(t1, fa(t1), 2*fa(t1))\napth2 = @. AcousticAnalogies.F1AOutput(t2, fb(t2), 3*fb(t2))\n\n# Calculate the \"exact\" answer by coming up with a common time, then evaluating the test functions directly on the common time grid.\nperiod = 0.5\nn_out = 51\nt_start = max(t1[1], t2[1])\nt_common = t_start .+ (0:n_out-1).*(period/n_out)\n\np_m = @. fa(t_common)+fb(t_common)\np_d = @. 2*fa(t_common)+3*fb(t_common)\n\neven_length = iseven(n_out)\napth_test = AcousticAnalogies.F1APressureTimeHistory{even_length}(p_m, p_d, step(t_common), first(t_common))\n\n# Put all the acoustic pressures in one array.\napth = hcat(apth1, apth2)\n\n# Combine.\napth_out = AcousticAnalogies.combine(apth, period, n_out)\n\n# Plot the two solutions.\nfig2 = Figure()\nax2_1 = fig2[1, 1] = Axis(fig2, xlabel=\"time\", ylabel=\"acoustic pressure, monopole\")\nax2_2 = fig2[2, 1] = Axis(fig2, xlabel=\"time\", ylabel=\"acoustic pressure, dipole\")\nscatter!(ax2_1, AcousticMetrics.time(apth_out), AcousticAnalogies.pressure_monopole(apth_out); marker=:x, label=\"AcousticAnalogies.combine\")\nscatter!(ax2_2, AcousticMetrics.time(apth_out), AcousticAnalogies.pressure_dipole(apth_out); marker=:x)\nlines!(ax2_1, AcousticMetrics.time(apth_test), AcousticAnalogies.pressure_monopole(apth_test); label=\"Exact\")\nlines!(ax2_2, AcousticMetrics.time(apth_test), AcousticAnalogies.pressure_dipole(apth_test))\nhidexdecorations!(ax2_1, grid=false)\naxislegend(ax2_1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:rt)\nsave(\"combine_test.png\", fig2)\nnothing # hide","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Right on top of each other.","category":"page"},{"location":"sqa/#F1A-Tests","page":"Software Quality Assurance","title":"F1A Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The most complicated part of AcousticAnalogies.jl is the implementation of the F1A calculation itself. For example, the compact form of the F1A dipole term as implemented in AcousticAnalogies.jl (neglecting surface deformation) is","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"4 pi c_0 p_d = int_L=0 left left( dotvecf cdot vecD_1A + vecf cdot vecE_1A right) dr right","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"p_d is the \"dipole\" part of the acoustic pressure\nvecf is the loading per unit span on the source element\nvecdotf is the source-time derivative of the loading per unit span on the source element\ndr is the differential length of the source element\nc_0 is the ambient speed of sound\nvecD_1A and vecE_1A are complicated functions of the position, velocity, and acceleration of the source element\nL = 0 indicates the integration is performed over some curve defined by L = 0.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"How are we going to test that we have all that implemented properly? Well, it turns out that Farassat's original formulation (F1) is much simpler than F1A:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"4 pi c_0 p_d = fracpartialpartial t int_L=0 left( vecf cdot vecB_1right) dr + int_L=0left( vecf cdot vecC_1 right) dr","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where vecB_1 and vecC_1 are again functions of the position of the source element and time derivatives of the same. It might not look that much simpler, but it is, because:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The F1 integrands don't depend on dotvecf\nvecD_1A and vecE_1A from F1A are more complicated than vecB_1 and vecC_1, and involve higher-order time derivatives","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"But the key thing to understand about F1 and F1A is that they are equivalent—going from F1A to F1 involves some fancy math (moving the derivative with respect to the observer time t inside the integral), but should give the same answer. The only trick is this: how will we evaluate the derivatives with respect to the observer time t in the F1 expressions? What we'll do here is just use standard second-order-accurate finite difference approximations, i.e.,","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"fracpartial gpartial t = fracg(t+Delta t) - g(t-Delta t)2 Delta t + mathcalO(Delta t^2)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where the notation mathcalO(Delta t^2) indicates that the error associated with the finite difference approximation should be proportional to Delta t^2. But this means that we can't expect our F1 calculation to exactly match F1A. So, what to do about that? What we can expect is that, if F1A and F1 have been implemented properly, the difference between them should go to zero at a second-order rate. So we can systematically reduce the time step size Delta t used to evaluate F1, and check that goes to zero at the expected rate. If it does, that proves that the only error between the two codes is due to the finite difference approximation, and gives us strong evidence that both F1A and F1 have been implemented properly.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"So, let's try it out! First we'll need a function that evaluates the f1 integrands","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies\nusing LinearAlgebra: norm\nusing NLsolve\nusing Polynomials\nusing GLMakie\n\nfunction f1_integrand(se, obs, t)\n    c0 = se.c0\n\n    # Need to get the retarded time.\n    R(τ) = [t - (τ[1] + norm(obs(t) .- se.y0dot(τ[1]))/c0)]\n    result = nlsolve(R, [-0.1], autodiff=:forward)\n    if !converged(result)\n        @error \"nlsolve retarded time calculation did not converge:\\n$(result)\"\n    end\n    τ = result.zero[1]\n\n    # Position of source at the retarted time.\n    y = se.y0dot(τ)\n\n    # Position vector from source to observer.\n    rv = obs(t) .- y\n\n    # Distance from source to observer.\n    r = AcousticAnalogies.norm_cs_safe(rv)\n\n    # Unit vector pointing from source to observer.\n    rhat = rv./r\n\n    # First time derivative of rv.\n    rv1dot = -se.y1dot(τ)\n\n    # Mach number of the velocity of the source in the direction of the\n    # observer.\n    Mr = AcousticAnalogies.dot_cs_safe(-rv1dot/se.c0, rhat)\n\n    # Now evaluate the integrand.\n    p_m_integrand = se.ρ0/(4*pi)*se.Λ*se.Δr/(r*(1 - Mr))\n\n    # Loading at the retarded time.\n    f0dot = se.f0dot(τ)\n\n    p_d_integrand_ff = (1/(4*pi*c0))*AcousticAnalogies.dot_cs_safe(f0dot, rhat)/(r*(1 - Mr))*se.Δr\n    p_d_integrand_nf = (1/(4*pi*c0))*AcousticAnalogies.dot_cs_safe(f0dot, rhat)*c0/(r^2*(1 - Mr))*se.Δr\n\n    return τ, p_m_integrand, p_d_integrand_ff, p_d_integrand_nf\nend\n","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The f1_integrand function takes a source element se, and acoustic observer obs, and an observer time t and finds the source time and intermediate stuff that will eventually want to differentiate using the finite difference approximation.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Now we need to make up a source and observer that we can test this out with:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"\n# https://docs.makie.org/v0.19/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfunction doit()\n    # Scale up the density to make the error bigger.\n    rho = 1.226e6  # kg/m^3\n    c0 = 340.0  # m/s\n    Rtip = 1.1684  # meters\n    radii = 0.99932*Rtip\n    dradii = (0.99932 - 0.99660)*Rtip  # m\n    area_over_chord_squared = 0.064\n    chord = 0.47397E-02 * Rtip\n    Λ = area_over_chord_squared * chord^2\n\n    theta = 90.0*pi/180.0\n    x0 = [cos(theta), 0.0, sin(theta)].*100.0.*12.0.*0.0254  # 100 ft in meters\n    obs = StationaryAcousticObserver(x0)\n\n    # Need the position and velocity of the source as a function of\n    # source/retarded time. How do I want it to move? I want it to rotate around\n    # an axis on the origin, pointing in the x direction.\n    rpm = 2200\n    omega = 2*pi/60*rpm\n    period = 60/rpm\n    fn = 180.66763939805125\n    fc = 19.358679206883078\n    y0dot(τ) = [0,  radii*cos(omega*τ), radii*sin(omega*τ)]\n    y1dot(τ) = [0, -omega*radii*sin(omega*τ), omega*radii*cos(omega*τ)]\n    y2dot(τ) = [0, -omega^2*radii*cos(omega*τ), -omega^2*radii*sin(omega*τ)]\n    y3dot(τ) = [0, omega^3*radii*sin(omega*τ), -omega^3*radii*cos(omega*τ)]\n    f0dot(τ) = [-fn, -sin(omega*τ)*fc, cos(omega*τ)*fc]\n    f1dot(τ) = [0, -omega*cos(omega*τ)*fc, -omega*sin(omega*τ)*fc]\n    u(τ) = y0dot(τ)./radii\n    sef1 = CompactSourceElement(rho, c0, dradii, Λ, y0dot, y1dot, nothing, nothing, f0dot, nothing, 0.0, u)\n\n    t = 0.0\n    dt = period*0.5^4\n\n    τ0, pmi0, pdiff0, pdinf0 = f1_integrand(sef1, obs, t)\n    sef1a = CompactSourceElement(rho, c0, dradii, Λ, y0dot(τ0), y1dot(τ0), y2dot(τ0), y3dot(τ0), f0dot(τ0), f1dot(τ0), τ0, u(τ0))\n    apth = f1a(sef1a, obs)\n\n    err_prev_pm = nothing\n    err_prev_pd = nothing\n    dt_prev = nothing\n    dt_curr = dt\n    first_time = true\n\n    err_pm = Vector{Float64}()\n    err_pd = Vector{Float64}()\n    dts = Vector{Float64}()\n    ooa_pm = Vector{Float64}()\n    ooa_pd = Vector{Float64}()\n    # Gradually reduce time step size, recording the error and order-of-accuracy each time.\n    for n in 1:7\n        τ_1, pmi_1, pdiff_1, pdinf_1 = f1_integrand(sef1, obs, t-dt_curr)\n        τ1, pmi1, pdiff1, pdinf1 = f1_integrand(sef1, obs, t+dt_curr)\n\n        p_m_f1 = (pmi_1 - 2*pmi0 + pmi1)/(dt_curr^2)\n        p_d_f1 = (pdiff1 - pdiff_1)/(2*dt_curr) + pdinf0\n\n        err_curr_pm = abs(p_m_f1 - apth.p_m)\n        err_curr_pd = abs(p_d_f1 - apth.p_d)\n\n        if first_time\n            first_time = false\n        else\n            push!(ooa_pm, log(err_curr_pm/err_prev_pm)/log(dt_curr/dt_prev))\n            push!(ooa_pd, log(err_curr_pd/err_prev_pd)/log(dt_curr/dt_prev))\n        end\n\n        push!(dts, dt_curr)\n        push!(err_pm, err_curr_pm)\n        push!(err_pd, err_curr_pd)\n\n        dt_prev = dt_curr\n        err_prev_pm = err_curr_pm\n        err_prev_pd = err_curr_pd\n        dt_curr = 0.5*dt_curr\n    end\n\n    # Fit a line through the errors on a log-log plot, then check that the slope\n    # is second-order.\n    l = fit(log.(dts), log.(err_pm), 1)\n    println(\"monopole term convergence rate = $(l.coeffs[2])\")\n\n    l = fit(log.(dts), log.(err_pd), 1)\n    println(\"dipole term convergence rate = $(l.coeffs[2])\")\n\n    # Plot the error and observered order of accuracy.\n    fig = Figure()\n    ax1 = fig[1, 1] = Axis(fig, xlabel=\"time step size\", ylabel=\"error\", xscale=log10, xticks=LogTicks(IntegerTicks()), yscale=log10)\n    ax2 = fig[2, 1] = Axis(fig, xlabel=\"time step size\", ylabel=\"convergence rate\", xscale=log10, xticks=LogTicks(IntegerTicks()))\n    linkxaxes!(ax2, ax1)\n    lines!(ax1, dts, err_pm, label=\"monopole term\")\n    lines!(ax1, dts, err_pd, label=\"dipole term\")\n    lines!(ax2, dts[2:end], ooa_pm, label=\"monopole term\")\n    lines!(ax2, dts[2:end], ooa_pd, label=\"dipole term\")\n    ylims!(ax2, -0.1, 3.1)\n    axislegend(ax1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:lt)\n    save(\"f1a_test.png\", fig)\nend\n\ndoit()","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The convergence rate of the error (the bottom plot) is extremely close to 2, which is what we're looking for.","category":"page"},{"location":"sqa/#ANOPP2-Comparisons","page":"Software Quality Assurance","title":"ANOPP2 Comparisons","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticAnalogies.jl test suite includes comparisons to ANOPP2 predictions. Tests for a hypothetical isolated rotor are performed over a range of RPMs, with both stationary and moving observers. Here is an example using a moving observer:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using GLMakie\nusing FLOWMath: akima\ninclude(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"anopp2_run.jl\"))\nusing .ANOPP2Run\nrpm = 2200.0\nt, p_thickness, p_loading, p_monopole_a2, p_dipole_a2 = ANOPP2Run.get_results(;\n    stationary_observer=false, theta=0.0, f_interp=akima, rpm=rpm, irpm=11)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, monopole, Pa\")\nax2 = fig[2, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, dipole, Pa\")\nlines!(ax1, t, p_thickness, label=\"AcousticAnalogies.jl\")\nscatter!(ax1, t, p_monopole_a2, label=\"ANOPP2\", markersize=6)\nlines!(ax2, t, p_loading)\nscatter!(ax2, t, p_dipole_a2, markersize=6)\nhidexdecorations!(ax1, grid=false)\naxislegend(ax1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:lt)\nsave(\"anopp2_comparison.png\", fig)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The difference between the two codes' predictions is very small (less than 1% error).","category":"page"},{"location":"sqa/#Signed-Commits","page":"Software Quality Assurance","title":"Signed Commits","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticAnalogies.jl GitHub repository requires all commits to the main branch to be signed. See the GitHub docs on signing commits for more information.","category":"page"},{"location":"sqa/#Reporting-Bugs","page":"Software Quality Assurance","title":"Reporting Bugs","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Users can use the GitHub Issues feature to report bugs and submit feature requests.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"CurrentModule = AADocs","category":"page"},{"location":"writevtk_support/#WriteVTK.jl-Support","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"","category":"section"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"\"\"\"\n    XROTORAirfoilConfig(A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\n\n`struct` that holds all the required parameters for XROTOR's approach to handling airfoil lift and drag polars.\n\n# Arguments\n- `A0`: zero lift angle of attack, radians.\n- `DCLDA`: lift curve slope, 1/radians.\n- `CLMAX`: stall Cl.\n- `CLMIN`: negative stall Cl.\n- `DCL_STALL`: CL increment from incipient to total stall.\n- `DCLDA_STALL`: stalled lift curve slope, 1/radian.\n- `CDMIN`: minimum Cd.\n- `CLDMIN`: Cl at minimum Cd.\n- `DCDCL2`: d(Cd)/d(Cl**2).\n- `REREF`: Reynolds Number at which Cd values apply.\n- `REXP`: Exponent for Re scaling of Cd:  Cd ~ Re**exponent\n- `MCRIT`: Critical Mach number.\n\"\"\"\nstruct XROTORAirfoilConfig{TF}\n    A0::TF # = 0.           # zero lift angle of attack   radians\n    DCLDA::TF # =  6.28     # lift curve slope            /radian\n    CLMAX::TF # =   1.5     # stall Cl\n    CLMIN::TF # =  -0.5     # negative stall Cl\n    DCL_STALL::TF # =   0.1 # CL increment from incipient to total stall\n    DCLDA_STALL::TF # = 0.1 # stalled lift curve slope    /radian\n    CDMIN::TF # =  0.013    # minimum Cd\n    CLDMIN::TF # =  0.5     # Cl at minimum Cd\n    DCDCL2::TF # =  0.004   # d(Cd)/d(Cl**2)\n    REREF::TF # =  200000.  # Reynolds Number at which Cd values apply\n    REXP::TF # =  -0.4      # Exponent for Re scaling of Cd:  Cd ~ Re**exponent\n    MCRIT::TF # =  0.8      # Critical Mach number\nend\n\n\nfunction XROTORAirfoilConfig(; A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\n    return XROTORAirfoilConfig(A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\nend\n\n\"\"\"\n    af_xrotor(alpha, Re, Mach, config::XROTORAirfoilConfig)\n\nReturn a tuple of the lift and drag coefficients for a given angle of attach\n`alpha` (in radians), Reynolds number `Re`, and Mach number `Mach`.\n\"\"\"\nfunction af_xrotor(alpha, Re, Mach, config::XROTORAirfoilConfig)\n# C------------------------------------------------------------\n# C     CL(alpha) function\n# C     Note that in addition to setting CLIFT and its derivatives\n# C     CLMAX and CLMIN (+ and - stall CL's) are set in this routine\n# C     In the compressible range the stall CL is reduced by a factor\n# C     proportional to Mcrit-Mach.  Stall limiting for compressible \n# C     cases begins when the compressible drag added CDC > CDMstall\n# C------------------------------------------------------------\n# C     CD(alpha) function - presently CD is assumed to be a sum\n# C     of profile drag + stall drag + compressibility drag\n# C     In the linear lift range drag is CD0 + quadratic function of CL-CLDMIN\n# C     In + or - stall an additional drag is added that is proportional\n# C     to the extent of lift reduction from the linear lift value.\n# C     Compressible drag is based on adding drag proportional to \n# C     (Mach-Mcrit_eff)^MEXP\n# C------------------------------------------------------------\n# C     CM(alpha) function - presently CM is assumed constant,\n# C     varying only with Mach by Prandtl-Glauert scaling\n# C------------------------------------------------------------\n# C\n      # INCLUDE 'XROTOR.INC'\n      # LOGICAL STALLF\n      # DOUBLE PRECISION ECMIN, ECMAX\n# C\n# C---- Factors for compressibility drag model, HHY 10/23/00\n# C     Mcrit is set by user\n# C     Effective Mcrit is Mcrit_eff = Mcrit - CLMFACTOR*(CL-CLDmin) - DMDD\n# C     DMDD is the delta Mach to get CD=CDMDD (usually 0.0020)\n# C     Compressible drag is CDC = CDMFACTOR*(Mach-Mcrit_eff)^MEXP\n# C     CDMstall is the drag at which compressible stall begins\n#\n      A0 = config.A0\n      DCLDA = config.DCLDA\n      CLMAX = config.CLMAX\n      CLMIN = config.CLMIN\n      DCL_STALL = config.DCL_STALL\n      DCLDA_STALL = config.DCLDA_STALL\n      CDMIN = config.CDMIN\n      CLDMIN = config.CLDMIN\n      DCDCL2 = config.DCDCL2\n      REREF = config.REREF\n      REXP = config.REXP\n      MCRIT = config.MCRIT\n      \n      CDMFACTOR = 10.0\n      CLMFACTOR =  0.25\n      MEXP      =  3.0\n      CDMDD     =  0.0020\n      CDMSTALL  =  0.1000\n# C\n# C---- Prandtl-Glauert compressibility factor\n      # MSQ   =   W*W*VEL^2/VSO^2\n      # MSQ_W = 2.0*W*VEL^2/VSO^2\n      # if (MSQ>1.0)\n      #  # WRITE(*,*)\n     # # &  'CLFUNC: Local Mach number limited to 0.99, was ', MSQ\n      #  MSQ = 0.99\n      #  # MSQ_W = 0.\n      # end\n      MSQ = Mach*Mach\n      if MSQ > 1.0\n          MSQ = 0.99\n          Mach = sqrt(MSQ)\n      end\n      PG = 1.0 / sqrt(1.0 - MSQ)\n      # PG_W = 0.5*MSQ_W * PG^3\n# C\n# C---- Mach number and dependence on velocity\n      # Mach = sqrt(MSQ)\n      # MACH_W = 0.0\n      # IF(Mach.NE.0.0) MACH_W = 0.5*MSQ_W/Mach \n      # if ! (mach ≈ 0.0)\n      #     MACH_W =  0.5*MSQ_W/Mach\n      # end\n# C\n# C\n# C------------------------------------------------------------\n# C--- Generate CL from dCL/dAlpha and Prandtl-Glauert scaling\n      CLA     = DCLDA*PG  *(alpha-A0)\n      # CLA_ALF = DCLDA*PG\n      # CLA_W   = DCLDA*PG_W*(ALF-A0)\n# C\n# C--- Effective CLmax is limited by Mach effects\n# C    reduces CLmax to match the CL of onset of serious compressible drag\n      CLMX = CLMAX\n      CLMN = CLMIN\n      DMSTALL  = (CDMSTALL/CDMFACTOR)^(1.0/MEXP)\n      CLMAXM = max(0.0, (MCRIT+DMSTALL-Mach)/CLMFACTOR) + CLDMIN\n      CLMAX  = min(CLMAX,CLMAXM)\n      CLMINM = min(0.0,-(MCRIT+DMSTALL-Mach)/CLMFACTOR) + CLDMIN\n      CLMIN  = max(CLMIN,CLMINM)\n# C\n# C--- CL limiter function (turns on after +-stall \n      ECMAX = exp( min(200.0, (CLA-CLMAX)/DCL_STALL) )\n      ECMIN = exp( min(200.0, (CLMIN-CLA)/DCL_STALL) )\n      CLLIM = DCL_STALL * log( (1.0+ECMAX)/(1.0+ECMIN) )\n      CLLIM_CLA = ECMAX/(1.0+ECMAX) + ECMIN/(1.0+ECMIN)\n# c\n# c      if(CLLIM.GT.0.001) then\n# c      write(*,999) 'cla,cllim,ecmax,ecmin ',cla,cllim,ecmax,ecmin\n# c      endif\n# c 999  format(a,2(1x,f10.6),3(1x,d12.6))\n# C\n# C--- Subtract off a (nearly unity) fraction of the limited CL function\n# C    This sets the dCL/dAlpha in the stalled regions to 1-FSTALL of that\n# C    in the linear lift range\n      FSTALL = DCLDA_STALL/DCLDA\n      CLIFT  = CLA     - (1.0-FSTALL)*CLLIM\n\n      # CL_ALF = CLA_ALF - (1.0-FSTALL)*CLLIM_CLA*CLA_ALF\n      # CL_W   = CLA_W   - (1.0-FSTALL)*CLLIM_CLA*CLA_W\n# C\n      # STALLF = false\n      # IF(CLIFT.GT.CLMAX) STALLF = .TRUE.\n      # IF(CLIFT.LT.CLMIN) STALLF = .TRUE.\n      # STALLF = (CLIFT > CLMAX) || (CLIFT < CLMIN)\n\n# C\n# C\n# C------------------------------------------------------------\n# C--- CM from CMCON and Prandtl-Glauert scaling\n      # CMOM  = PG*CMCON\n      # CM_AL = 0.0\n      # CM_W  = PG_W*CMCON\n# C\n# C\n# C------------------------------------------------------------\n# C--- CD from profile drag, stall drag and compressibility drag \n# C\n# C---- Reynolds number scaling factor\n      if (Re < 0.0)\n        RCORR = 1.0\n        # RCORR_REY = 0.0\n      else\n        RCORR     = (Re/REREF)^REXP\n        # RCORR_REY =  REXP/Re\n      end\n# C\n# C--- In the basic linear lift range drag is a function of lift\n# C    CD = CD0 (constant) + quadratic with CL)\n      CDRAG  = (CDMIN + DCDCL2*(CLIFT-CLDMIN)^2    ) * RCORR\n      # CD_ALF = (    2.0*DCDCL2*(CLIFT-CLDMIN)*CL_ALF) * RCORR\n      # CD_W   = (    2.0*DCDCL2*(CLIFT-CLDMIN)*CL_W  ) * RCORR\n      # CD_REY = CDRAG*RCORR_REY\n# C\n# C--- Post-stall drag added\n      FSTALL = DCLDA_STALL/DCLDA\n      DCDX    = (1.0-FSTALL)*CLLIM/(PG*DCLDA)\n# c      write(*,*) 'cla,cllim,fstall,pg,dclda ',cla,cllim,fstall,pg,dclda\n      DCD     = 2.0* DCDX^2\n      # DCD_ALF = 4.0* DCDX * (1.0-FSTALL)*CLLIM_CLA*CLA_ALF/(PG*DCLDA)\n      # DCD_W = 4.0* DCDX * ( (1.0-FSTALL)*CLLIM_CLA*CLA_W/(PG*DCLDA) - DCD/PG*PG_W )\n# c      write(*,*) 'alf,cl,dcd,dcd_alf,dcd_w ',alf,clift,dcd,dcd_alf,dcd_w\n# C\n# C--- Compressibility drag (accounts for drag rise above Mcrit with CL effects\n# C    CDC is a function of a scaling factor*(M-Mcrit(CL))^MEXP\n# C    DMDD is the Mach difference corresponding to CD rise of CDMDD at MCRIT\n      DMDD = (CDMDD/CDMFACTOR)^(1.0/MEXP)\n      CRITMACH = MCRIT-CLMFACTOR*abs(CLIFT-CLDMIN) - DMDD\n      # CRITMACH_ALF  = -CLMFACTOR*ABS(CL_ALF)\n      # CRITMACH_W    = -CLMFACTOR*ABS(CL_W)\n      if (Mach < CRITMACH)\n        CDC     = 0.0\n        # CDC_ALF = 0.0\n        # CDC_W   = 0.0\n      else\n        CDC = CDMFACTOR*(Mach-CRITMACH)^MEXP\n        # CDC_W   = MEXP*MACH_W*CDC/Mach - MEXP*CRITMACH_W  *CDC/CRITMACH\n        # CDC_ALF =                      - MEXP*CRITMACH_ALF*CDC/CRITMACH\n      end\n# c      write(*,*) 'critmach,mach ',critmach,mach\n# c      write(*,*) 'cdc,cdc_w,cdc_alf ',cdc,cdc_w,cdc_alf\n# C\n      FAC   = 1.0\n      # FAC_W = 0.0\n# C--- Although test data does not show profile drag increases due to Mach # \n# C    you could use something like this to add increase drag by Prandtl-Glauert\n# C    (or any function you choose) \n# cc      FAC   = PG\n# cc      FAC_W = PG_W\n# C--- Total drag terms\n      CDRAG  = FAC*CDRAG              + DCD     + CDC\n      # CD_ALF = FAC*CD_ALF             + DCD_ALF + CDC_ALF\n      # CD_W   = FAC*CD_W + FAC_W*CDRAG + DCD_W   + CDC_W\n      # CD_REY = FAC*CD_REY\n# C\n      return CLIFT, CDRAG\nend","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"AcousticAnalogies.jl can write out CompactSourceElement structs to VTK files, allowing us to easily visualize the state and motion of the acoustic sources in popular visualization tools (e.g. ParaView). This is very useful for checking that the motion, loading, coordinate system, etc. is what we expect.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"To write out VTK files, we just need to pass an array of source elements to the AcousticAnalogies.to_paraview_collection function. We'll use CCBlade.jl to calculate the aerodynamic loads, and the CCBlade.jl helper routines that AcousticAnalogies.jl provides to create the source elements from the CCBlade.jl data.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"using AcousticAnalogies\nusing CCBlade\n\n# Define the blade geometry.\nB = 2\nRhub = 0.10\nRtip = 1.1684  # meters\nradii = Rhub .+ range(0.0, 1.0, length=31).*(Rtip - Rhub)\nradii = 0.5.*(radii[2:end] .+ radii[1:end-1])\n\ncs_area_over_chord_squared = 0.064\nchord = [\n    0.35044     , 0.28260     , 0.22105     , 0.17787     , 0.14760,\n    0.12567     , 0.10927     , 0.96661E-01 , 0.86742E-01 ,\n    0.78783E-01 , 0.72287E-01 , 0.66906E-01 , 0.62387E-01 ,\n    0.58541E-01 , 0.55217E-01 , 0.52290E-01 , 0.49645E-01 ,\n    0.47176E-01 , 0.44772E-01 , 0.42326E-01 , 0.39732E-01 ,\n    0.36898E-01 , 0.33752E-01 , 0.30255E-01 , 0.26401E-01 ,\n    0.22217E-01 , 0.17765E-01 , 0.13147E-01 , 0.85683E-02 ,\n    0.47397E-02].*Rtip\n\ntheta = [\n    40.005, 34.201, 28.149, 23.753, 20.699, 18.516, 16.890, 15.633,\n    14.625, 13.795, 13.094, 12.488, 11.956, 11.481, 11.053, 10.662,\n    10.303, 9.9726, 9.6674, 9.3858, 9.1268, 8.8903, 8.6764, 8.4858,\n    8.3193, 8.1783, 8.0638, 7.9769, 7.9183, 7.8889].*(pi/180)\n\n# Define the operating point.\nrpm = 2200.0\nomega = rpm*(2*pi/60.0)\nrho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nmu = 0.1780e-4  # kg/(m*s)\npitch = 0.0  # rad\nVinf = 5.0  # m/s\n\n# Create an airfoil interpolation object.\nxrotor_config = XROTORAirfoilConfig(\n    A0=0.0, DCLDA=6.2800, CLMAX=1.5, CLMIN=-0.5, DCLDA_STALL=0.1,\n    DCL_STALL=0.1, MCRIT=0.8, CDMIN=0.13e-1, CLDMIN=0.5, DCDCL2=0.4e-2, REREF=0.2e6, REXP=-0.4)\nairfoil_interp(a, r, m) = af_xrotor(a, r, m, xrotor_config)\n\n# Create the CCBlade.jl structs.\nrotor = Rotor(Rhub, Rtip, B)\nsections = Section.(radii, chord, theta, Ref(airfoil_interp))\nops = OperatingPoint.(Vinf, omega.*radii, rho, pitch, mu, c0)\nouts = solve.(Ref(rotor), sections, ops)\n\n# Create the AcousticAnalogies.jl source elements.\nbpp = 60/(rpm*B)\nperiod = 2*bpp\nnum_source_times = 64\nses = source_elements_ccblade(rotor, sections, ops, outs, fill(cs_area_over_chord_squared, length(radii)), period, num_source_times)\n@show size(ses)","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"ses is an array of source elements of shape (num_source_times, num_radial, B), where num_source_times is the number of time steps over which the source elements are defined, num_radial is the number of radial elements each blade is subdivided into, and B is the number of blades.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"Now that we have an array of source elements, we can write them out to VTK files.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"name = \"two_blade_example\"\noutfiles = AcousticAnalogies.to_paraview_collection(name, ses)","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"This will write out one polygonal VTK (.vtp) file per time step, along with a ParaView collection (.pvd) file that allows us to open all of the .vtp files at once.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"Here's an example visualization of the above example, showing an animation of the loading in the y direction, which is normal to the rotation axis of the rotor. (Image: Loading Animation)","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"CurrentModule = AADocs","category":"page"},{"location":"ccblade_example/#Compact-Formulation-1A-CCBlade.jl-Example","page":"CCBlade.jl Example","title":"Compact Formulation 1A CCBlade.jl Example","text":"","category":"section"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"AcousticAnalogies.jl contains routines that take in types defined by CCBlade.jl, a blade element momentum theory (BEMT) code and construct the types used by AcousticAnalogies.jl for acoustic predictions. This makes it simple to go from a BEMT aerodynamic prediction of a propeller or rotor to an acoustic prediction.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"First step is to load up CCBlade.jl.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using CCBlade: parsefile, viterna, AlphaAF, SkinFriction, PrandtlGlauert, DuSeligEggers, PrandtlTipHub, Rotor, Section, OperatingPoint, solve, linearliftcoeff\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Then we'll define some parameters we'll need to create the CCBlade.jl types. First some atmospheric properties:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"gam = 1.4\nR = 287.058  # J/(kg*K)\nrho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nmu = 0.1780e-4  # kg/(m*s)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And some blade geometry parameters:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"num_blades = 3\nnum_radial = 30\nprecone = 0.0                                   # rad\nRtip = 0.5*24*0.0254                            # blade radius, m\nRhub = 0.2*Rtip                                 # hub radius, m\nr_ = range(Rhub, Rtip, length=num_radial+1)     # blade element interfaces\nradii = 0.5.*(r_[2:end] .+ r_[1:end-1])         # blade element centers, m\nc = 1.5*0.0254                                  # (constant) chord, m\nchord = fill(c, num_radial)                     # chord, m\nD = 2*Rtip                                      # blade diameter, m\nP = 16*0.0254                                   # propeller pitch, m\ntwist = @. atan(P/(pi*D*radii/Rtip))            # twist, rad\narea_over_chord_squared = 0.08217849116518001   # Cross-sectional area per chord^2 for NACA0012.\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"We also need airfoil lift and drag coefficients as a function of angle of attack. CCBlade.jl has routines for interpolating and correcting airfoil lift and drag data. Here we're starting with NACA0012 airfoil data from airfoiltools.com:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"af_fname = joinpath(@__DIR__, \"assets\", \"xf-n0012-il-500000.dat\")\ninfo, Re, Mach, alpha, cl, cd = parsefile(af_fname, false)\n\n# Extend the angle of attack with the Viterna method.\ncr75 = c/Rtip\n(alpha, cl, cd) = viterna(alpha, cl, cd, cr75)\naf = AlphaAF(alpha, cl, cd, info, Re, Mach)\n\n# Reynolds number correction. The 0.6 factor seems to match the NACA 0012\n# drag data from airfoiltools.com.\nreynolds = SkinFriction(Re, 0.6)\n\n# Mach number correction.\nmach = PrandtlGlauert()\n\n# Rotational stall delay correction. Need some parameters from the CL curve.\nm, alpha0 = linearliftcoeff(af, 1.0, 1.0)  # dummy values for Re and Mach\n# Create the Du Selig and Eggers correction.\nrotation = DuSeligEggers(1.0, 1.0, 1.0, m, alpha0)\n\n# The usual hub and tip loss correction.\ntip = PrandtlTipHub()\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Finally, the freestream velocity and the rotor rotation rate:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"v = 0.11*c0  # m/s\nomega = 7100 * 2*pi/60  # rad/s\npitch = 0.0 # rad\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we have enough information to create the CCBlade.jl structs we'll need.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"rotor = Rotor(Rhub, Rtip, num_blades; precone=precone, turbine=false, mach=mach, re=reynolds, rotation=rotation, tip=tip)\nsections = Section.(radii, chord, twist, Ref(af))\nops = OperatingPoint.(v, omega.*radii, rho, pitch, mu, c0)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And we can use CCBlade.jl to solve the BEMT equations.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"outs = solve.(Ref(rotor), sections, ops)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And then make some plots.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using GLMakie\nfig1 = Figure()\nax1_1 = fig1[1, 1] = Axis(fig1, xlabel=\"radii/Rtip\", ylabel=\"normal load/span, N/m\")\nax1_2 = fig1[2, 1] = Axis(fig1, xlabel=\"radii/Rtip\", ylabel=\"circum load/span, N/m\")\nlines!(ax1_1, radii./Rtip, getproperty.(outs, :Np))\nlines!(ax1_2, radii./Rtip, getproperty.(outs, :Tp))\nhidexdecorations!(ax1_1, grid=false)\nsave(\"ccblade_example-ccblade_loads.png\", fig1)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"(Image: )","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we can use the CCBlade.jl structs to create AcousticAnalogies.jl source elements. The key function is source_elements_ccblade:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"source_elements_ccblade","category":"page"},{"location":"ccblade_example/#AcousticAnalogies.source_elements_ccblade","page":"CCBlade.jl Example","title":"AcousticAnalogies.source_elements_ccblade","text":"source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, area_per_chord2::Vector{AbstractFloat}, period, num_src_times)\n\nConstruct and return an array of CompactSourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.precone).\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs::Vector of CCBlade output objects.\narea_per_chord2: cross-sectional area divided by the chord squared of the element at each CCBlade.section. Should be a Vector{AbstractFloat}, same length as sections, ops, outputs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\n\n\n\n\n\n","category":"function"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"So let's try that:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using AcousticAnalogies: source_elements_ccblade, ConstVelocityAcousticObserver, f1a, combine, pressure_monopole, pressure_dipole\nbpp = 2*pi/omega/num_blades  # blade passing period\nses = source_elements_ccblade(rotor, sections, ops, outs, [area_over_chord_squared], 4*bpp, 64)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we can use the source elements to perform an acoustic prediction, after we decide on an acoustic observer location.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using AcousticMetrics\n# Sideline microphone location in meters.\nx_obs = [0.0, 2.3033, 2.6842]\nv_obs = [v, 0.0, 0.0]\nobs = ConstVelocityAcousticObserver(0.0, x_obs, v_obs)\napth = f1a.(ses, Ref(obs))\napth_total = combine(apth, 2*bpp, 64)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And finally plot the acoustic pressure time history.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"fig2 = Figure()\nax2_1 = fig2[1, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, monopole, Pa\")\nax2_2 = fig2[2, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, dipole, Pa\")\nax2_3 = fig2[3, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, total, Pa\")\nt = AcousticMetrics.time(apth_total)\nt_nondim = (t .- t[1])./bpp\nlines!(ax2_1, t_nondim, pressure_monopole(apth_total))\nlines!(ax2_2, t_nondim, pressure_dipole(apth_total))\nlines!(ax2_3, t_nondim, AcousticMetrics.pressure(apth_total))\nhidexdecorations!(ax2_1, grid=false)\nhidexdecorations!(ax2_2, grid=false)\nsave(\"ccblade_example-apth.png\", fig2)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AADocs","category":"page"},{"location":"#AcousticAnalogies.jl-Documentation","page":"Introduction","title":"AcousticAnalogies.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Summary: A pure-Julia package for propeller/rotor blade noise prediction with acoustic analogies.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"What's an acoustic analogy?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TL;DR answer:\nAn acoustic analogy is a noise prediction approach that takes information from one area of the fluid domain (e.g., a propeller blade surface, or a fictitious surface surrounding a complicated flow) and calculates the acoustics radiated by the flow. The particular acoustic analogy implemented in AcousticAnalogies.jl is especially well-suited for predicting tonal propeller/rotor noise, and has features that ease its inclusion in gradient-based optimizations.\nMathy answer:\nAn acoustic analogy is a clever rearrangement of the Navier-Stokes equations, the governing equations of fluid flow, into a form that looks like the classical inhomogeneous wave equation. The inhomogeneous term represents sources of sound in the flow. The wave equation can be solved using the appropriate Green's function, which requires the evaluation of two surface integrals and a volume integral (usually neglected). If the integration surface is taken to be a solid surface in the fluid domain (e.g., a propeller blade), we can use the acoustic analogy solution to predict the acoustics caused by the motion of and loading on the integration surface.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of L. Lopes' compact form of Farassat's formulation 1A (see http://dx.doi.org/10.2514/6.2015-2673 or http://dx.doi.org/10.2514/1.C034048 for details).\nSupport for stationary or constant-velocity moving observers, with an explict calculation for the latter from D. Casalino http://dx.doi.org/10.1016/S0022-460X(02)00986-0.\nThoroughly tested: unit tests for everything, and multiple comparisons of the entire calculation to equivalent methods in NASA's ANOPP2 code.\nConvenient, fast coordinate system transformations through KinematicCoordinateTransformations.jl.\nWritten in pure Julia, and compatible with automatic differentiation (AD) tools like ForwardDiff.jl.\nComprehensive docs (TODO).\nFast!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Installation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add AcousticAnalogies","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Usage","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the docs.","category":"page"},{"location":"#Software-Quality-Assurance","page":"Introduction","title":"Software Quality Assurance","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This repository contains extensive tests run by GitHub Actions.\nThis repository only allows signed commits to be merged into the main branch.","category":"page"}]
}
