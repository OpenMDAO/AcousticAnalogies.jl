var documenterSearchIndex = {"docs":
[{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"CurrentModule = AADocs","category":"page"},{"location":"bpm_tests1/#Software-Quality-Assurance,-Cont.","page":"BPM Airfoil Self-Noise Tests","title":"Software Quality Assurance, Cont.","text":"","category":"section"},{"location":"bpm_tests1/#Brooks,-Pope,-and-Marcolini-Airfoil-Self-Noise-Tests","page":"BPM Airfoil Self-Noise Tests","title":"Brooks, Pope, and Marcolini Airfoil Self-Noise Tests","text":"","category":"section"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"The Brooks, Pope, and Marcolini (BPM) report on airfoil self-noise forms the basis of the Brooks and Burley broadband noise modeling approach that is implemented in AcousticAnalogies.jl.","category":"page"},{"location":"bpm_tests1/#Boundary-Layer-Tests","page":"BPM Airfoil Self-Noise Tests","title":"Boundary Layer Tests","text":"","category":"section"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c/10^6\", ylabel=\"δ_0/c\",\n                       xscale=log10, yscale=log10,\n                       xminorticksvisible=true, yminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9), yminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()), yticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure06-bl_thickness-tripped.csv\")\nbpm_tripped = DelimitedFiles.readdlm(fname, ',')\nRe_c_1e6 = bpm_tripped[:, 1]\ndeltastar0_c = bpm_tripped[:, 2]\nscatter!(ax1, Re_c_1e6, deltastar0_c, markersize=4, label=\"tripped, BPM report\", color=colors[1])\n\nRe_c_1e6_jl = range(minimum(Re_c_1e6), maximum(Re_c_1e6); length=50)\ndeltastar0_c_jl = AcousticAnalogies.bl_thickness_0.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), Re_c_1e6_jl.*1e6)\nlines!(ax1, Re_c_1e6_jl, deltastar0_c_jl, label=\"tripped, Julia\", color=colors[1])\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure06-bl_thickness-untripped.csv\")\nbpm_untripped = DelimitedFiles.readdlm(fname, ',')\nRe_c_1e6 = bpm_untripped[:, 1]\ndeltastar0_c = bpm_untripped[:, 2]\nscatter!(ax1, Re_c_1e6, deltastar0_c, markersize=4, label=\"untripped, BPM report\", color=colors[2])\n\nRe_c_1e6_jl = range(minimum(Re_c_1e6), maximum(Re_c_1e6); length=50)\ndeltastar0_c_jl = AcousticAnalogies.bl_thickness_0.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), Re_c_1e6_jl.*1e6)\nlines!(ax1, Re_c_1e6_jl, deltastar0_c_jl, label=\"untripped, Julia\", color=colors[2])\n\nxlims!(ax1, 0.04, 3)\nylims!(ax1, 0.01, 0.2)\naxislegend(ax1)\nsave(\"19890016302-figure06-bl_thickness.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c/10^6\", ylabel=\"δ_0^*/c\",\n                       xscale=log10, yscale=log10,\n                       xminorticksvisible=true, yminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9), yminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()), yticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure06-disp_thickness-tripped.csv\")\nbpm_tripped = DelimitedFiles.readdlm(fname, ',')\nRe_c_1e6 = bpm_tripped[:, 1]\ndeltastar0_c = bpm_tripped[:, 2]\nscatter!(ax1, Re_c_1e6, deltastar0_c, markersize=4, label=\"tripped, BPM report\", color=colors[1])\n\nRe_c_1e6_jl = range(minimum(Re_c_1e6), maximum(Re_c_1e6); length=50)\ndeltastar0_c_jl = AcousticAnalogies.disp_thickness_0.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), Re_c_1e6_jl.*1e6)\nlines!(ax1, Re_c_1e6_jl, deltastar0_c_jl, label=\"tripped, Julia\", color=colors[1])\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure06-disp_thickness-untripped.csv\")\nbpm_untripped = DelimitedFiles.readdlm(fname, ',')\nRe_c_1e6 = bpm_untripped[:, 1]\ndeltastar0_c = bpm_untripped[:, 2]\nscatter!(ax1, Re_c_1e6, deltastar0_c, markersize=4, label=\"untripped, BPM report\", color=colors[2])\n\nRe_c_1e6_jl = range(minimum(Re_c_1e6), maximum(Re_c_1e6); length=50)\ndeltastar0_c_jl = AcousticAnalogies.disp_thickness_0.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), Re_c_1e6_jl.*1e6)\nlines!(ax1, Re_c_1e6_jl, deltastar0_c_jl, label=\"untripped, Julia\", color=colors[2])\n\nxlims!(ax1, 0.04, 3)\nylims!(ax1, 0.001, 0.03)\naxislegend(ax1)\nsave(\"19890016302-figure06-disp_thickness.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"alpha, deg.\", ylabel=\"δ/δ_0\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks())\n                       )\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure07-bl_thickness-pressure_side.csv\")\nbpm_pressure_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_pressure_side[:, 1]\ndelta_bpm = bpm_pressure_side[:, 2]\nscatter!(ax1, alpha_deg, delta_bpm, color=colors[1], markersize=4, label=\"pressure side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndelta_jl = AcousticAnalogies._bl_thickness_p.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, delta_jl; color=colors[1], label=\"pressure side, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure07-bl_thickness-suction_side.csv\")\nbpm_suction_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_suction_side[:, 1]\ndelta_bpm = bpm_suction_side[:, 2]\nscatter!(ax1, alpha_deg, delta_bpm, markersize=4, color=colors[2], label=\"suction side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndelta_jl = AcousticAnalogies._bl_thickness_s.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, delta_jl; color=colors[2], label=\"suction side, Julia\")\n\nxlims!(ax1, 0, 25)\nylims!(ax1, 0.2, 20)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure07-bl_thickness.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"alpha, deg.\", ylabel=\"δ^*/δ_0^*\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks())\n                       )\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure07-pressure_side.csv\")\nbpm_pressure_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_pressure_side[:, 1]\ndeltastar_bpm = bpm_pressure_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, color=colors[1], markersize=4, label=\"pressure side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._disp_thickness_p.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[1], label=\"pressure side, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure07-suction_side.csv\")\nbpm_suction_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_suction_side[:, 1]\ndeltastar_bpm = bpm_suction_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, markersize=4, color=colors[2], label=\"suction side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._disp_thickness_s.(Ref(AcousticAnalogies.TrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[2], label=\"suction side, Julia\")\n\nxlims!(ax1, 0, 25)\nylims!(ax1, 0.2, 200)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure07.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"alpha, deg.\", ylabel=\"δ/δ_0\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks())\n                       )\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure08-bl_thickness-pressure_side.csv\")\nbpm_pressure_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_pressure_side[:, 1]\ndeltastar_bpm = bpm_pressure_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, color=colors[1], markersize=4, label=\"pressure side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._bl_thickness_p.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[1], label=\"pressure side, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure08-bl_thickness-suction_side.csv\")\nbpm_pressure_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_pressure_side[:, 1]\ndeltastar_bpm = bpm_pressure_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, color=colors[2], markersize=4, label=\"suction side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._bl_thickness_s.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[2], label=\"suction side, Julia\")\n\nxlims!(ax1, 0, 25)\nylims!(ax1, 0.2, 40)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure08-bl_thickness.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"alpha, deg.\", ylabel=\"δ^*/δ_0^*\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks())\n                       )\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure08-pressure_side.csv\")\nbpm_pressure_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_pressure_side[:, 1]\ndeltastar_bpm = bpm_pressure_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, color=colors[1], markersize=4, label=\"pressure side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._disp_thickness_p.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[1], label=\"pressure side, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure08-suction_side.csv\")\nbpm_suction_side = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm_suction_side[:, 1]\ndeltastar_bpm = bpm_suction_side[:, 2]\nscatter!(ax1, alpha_deg, deltastar_bpm, markersize=4, color=colors[2], label=\"suction side, BPM report\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\ndeltastar_jl = AcousticAnalogies._disp_thickness_s.(Ref(AcousticAnalogies.UntrippedN0012BoundaryLayer()), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, deltastar_jl; color=colors[2], label=\"suction side, Julia\")\n\nxlims!(ax1, 0, 25)\nylims!(ax1, 0.2, 200)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure08.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/#Turbulent-Boundary-Layer-Trailing-Edge-Shape-Function-Tests","page":"BPM Airfoil Self-Noise Tests","title":"Turbulent Boundary Layer-Trailing Edge Shape Function Tests","text":"","category":"section"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c\", ylabel=\"Peak scaled SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure77.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nRe_c_bpm = bpm[:, 1]\nK_1_bpm = bpm[:, 2]\nscatter!(ax1, Re_c_bpm, K_1_bpm, color=colors[1], markersize=8, label=\"BPM report\")\n\nRe_c_jl = range(minimum(Re_c_bpm), maximum(Re_c_bpm); length=50)\nK_1_jl = AcousticAnalogies.K_1.(Re_c_jl)\nlines!(ax1, Re_c_jl, K_1_jl, color=colors[1], label=\"Julia\")\n\nxlims!(ax1, 10^4, 10^7)\nylims!(ax1, 110.0, 150.0)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure77.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Strouhal number ratio, St/St_peak\", ylabel=\"Function A level, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure78-A_min.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_St_peak_bpm = bpm[:, 1]\nA = bpm[:, 2]\nscatter!(ax1, St_St_peak_bpm, A, color=colors[1], markersize=8, label=\"A_min, BPM report\")\n\nSt_St_peak_jl = range(minimum(St_St_peak_bpm), maximum(St_St_peak_bpm); length=50)\nA_jl = AcousticAnalogies.A.(St_St_peak_jl, 9.5e4)\nlines!(ax1, St_St_peak_jl, A_jl, color=colors[1], label=\"A_min, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure78-A_max.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_St_peak_bpm = bpm[:, 1]\nA = bpm[:, 2]\nscatter!(ax1, St_St_peak_bpm, A, color=colors[2], markersize=8, label=\"A_max, BPM report\")\n\nSt_St_peak_jl = range(minimum(St_St_peak_bpm), maximum(St_St_peak_bpm); length=50)\nA_jl = AcousticAnalogies.A.(St_St_peak_jl, 8.58e5)\nlines!(ax1, St_St_peak_jl, A_jl, color=colors[2], label=\"A_max, Julia\")\n\nxlims!(ax1, 0.1, 20)\nylims!(ax1, -20.0, 0.0)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure78-A.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Strouhal number ratio, St/St_peak\", ylabel=\"Function B level, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure78-B_min.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_St_peak_bpm = bpm[:, 1]\nB = bpm[:, 2]\nscatter!(ax1, St_St_peak_bpm, B, color=colors[1], markersize=8, label=\"B_min, BPM report\")\n\nSt_St_peak_jl = range(0.5, 2; length=50)\nB_jl = AcousticAnalogies.B.(St_St_peak_jl, 9.5e4)\nlines!(ax1, St_St_peak_jl, B_jl, color=colors[1], label=\"B_min, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure78-B_max.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_St_peak_bpm = bpm[:, 1]\nB = bpm[:, 2]\nscatter!(ax1, St_St_peak_bpm, B, color=colors[2], markersize=8, label=\"B_max, BPM report\")\n\nSt_St_peak_jl = range(0.2, 4; length=50)\nB_jl = AcousticAnalogies.B.(St_St_peak_jl, 8.58e5)\nlines!(ax1, St_St_peak_jl, B_jl, color=colors[2], label=\"B_max, Julia\")\n\nxlims!(ax1, 0.1, 20)\nylims!(ax1, -20.0, 0.0)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure78-B.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Angle of attack α^*, deg\", ylabel=\"Peak Strouhal number, St_peak\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure80-M0.093.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nSt_2 = bpm[:, 2]\nscatter!(ax1, alpha_deg, St_2, color=colors[1], markersize=8, label=\"St_2 for M = 0.093, BPM\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\nSt_2_jl = AcousticAnalogies.St_2.(AcousticAnalogies.St_1(0.093), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, St_2_jl, color=colors[1], label=\"St_2 for M = 0.093, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure80-M0.209.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nSt_2 = bpm[:, 2]\nscatter!(ax1, alpha_deg, St_2, color=colors[2], markersize=8, label=\"St_2 for M = 0.209, BPM\")\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=50)\nSt_2_jl = AcousticAnalogies.St_2.(AcousticAnalogies.St_1(0.209), alpha_deg_jl.*pi/180)\nlines!(ax1, alpha_deg_jl, St_2_jl, color=colors[2], label=\"St_2 for M = 0.209, Julia\")\n\nxlims!(ax1, 0.0, 25.0)\nylims!(ax1, 0.01, 1)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure80.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Angle of attack α_*, deg\", ylabel=\"Extracted scaled levels minus K_1, dB\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure82-M0.093.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nK_2_K_1 = bpm[:, 2]\nscatter!(ax1, alpha_deg, K_2_K_1, color=colors[1], markersize=8, label=\"M = 0.093, BPM\", marker='o')\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=200)\nK_2_K_1_jl = AcousticAnalogies.K_2.(1e6, 0.093, alpha_deg_jl.*pi/180) .- AcousticAnalogies.K_1(1e6)\nlines!(ax1, alpha_deg_jl, K_2_K_1_jl, color=colors[1], label=\"M = 0.093, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure82-M0.116.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nK_2_K_1 = bpm[:, 2]\nscatter!(ax1, alpha_deg, K_2_K_1, color=colors[2], markersize=8, label=\"M = 0.116, BPM\", marker='o')\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=200)\nK_2_K_1_jl = AcousticAnalogies.K_2.(1e6, 0.116, alpha_deg_jl.*pi/180) .- AcousticAnalogies.K_1(1e6)\nlines!(ax1, alpha_deg_jl, K_2_K_1_jl, color=colors[2], label=\"M = 0.116, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure82-M0.163.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nK_2_K_1 = bpm[:, 2]\nscatter!(ax1, alpha_deg, K_2_K_1, color=colors[3], markersize=8, label=\"M = 0.163, BPM\", marker='o')\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=200)\nK_2_K_1_jl = AcousticAnalogies.K_2.(1e6, 0.163, alpha_deg_jl.*pi/180) .- AcousticAnalogies.K_1(1e6)\nlines!(ax1, alpha_deg_jl, K_2_K_1_jl, color=colors[3], label=\"M = 0.163, Julia\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure82-M0.209.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalpha_deg = bpm[:, 1]\nK_2_K_1 = bpm[:, 2]\nscatter!(ax1, alpha_deg, K_2_K_1, color=colors[4], markersize=8, label=\"M = 0.209, BPM\", marker='o')\n\nalpha_deg_jl = range(minimum(alpha_deg), maximum(alpha_deg); length=200)\nK_2_K_1_jl = AcousticAnalogies.K_2.(1e6, 0.209, alpha_deg_jl.*pi/180) .- AcousticAnalogies.K_1(1e6)\nlines!(ax1, alpha_deg_jl, K_2_K_1_jl, color=colors[4], label=\"M = 0.209, Julia\")\n\nxlims!(ax1, 0.0, 25.0)\nylims!(ax1, -20, 20)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure82.png\", fig)","category":"page"},{"location":"bpm_tests1/","page":"BPM Airfoil Self-Noise Tests","title":"BPM Airfoil Self-Noise Tests","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"CurrentModule = AADocs","category":"page"},{"location":"sqa/#Software-Quality-Assurance","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"","category":"section"},{"location":"sqa/#Tests","page":"Software Quality Assurance","title":"Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticAnalogies.jl uses the usual Julia testing framework to implement and run tests. The tests can be run locally after installing AcousticAnalogies.jl, and are also run automatically on GitHub Actions.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"To run the tests locally, from the Julia REPL, type ] to enter the Pkg prompt, then","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(jl_jncZ1E) pkg> test AcousticAnalogies\n     Testing Running tests...\nTest Summary:       | Pass  Total  Time\nAdvanced time tests |    2      2  7.0s\nTest Summary:           | Pass  Total  Time\nCombine F1AOutput tests |    8      8  2.7s\nTest Summary: | Pass  Total  Time\nF1A tests     |    2      2  5.9s\nTest Summary:               | Pass  Total  Time\nCCBlade private utils tests |    1      1  0.3s\nTest Summary:                     | Pass  Total  Time\nCCBlade CompactF1ASourceElement test |   12     12  3.4s\nTest Summary:     | Pass  Total  Time\nANOPP2 Comparison |  176    176  5.9s\nTest Summary:    | Time\nForwardDiff test | None  14.1s\n     Testing AcousticAnalogies tests passed\n\n(jl_jncZ1E) pkg> ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(The output associated with installing all the dependencies the tests need isn't shown above.)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Here is a description of each category of test:","category":"page"},{"location":"sqa/#Advanced-Time-Tests","page":"Software Quality Assurance","title":"Advanced Time Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The F1A calculation is concerned with roughly two types of objects: acoustic sources and acoustic observers. Acoustic sources are things that make noise, and, for AcousticAnalogies.jl, would typically be a portion of some type of aerodynamic lifting surface (like a propeller blade). An acoustic observer is just a fancy name for a person or microphone that will hear the noise emitted by the source. Both the source and observer may be stationary, but more likely will be moving.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"During the F1A calculation, we need to know the time at which an acoustic wave emitted by the source encounters the observer. Mathematically, we need to solve the equation","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"R(t) = t - left( tau + fracvecx(t) - vecy(τ)c_0 right) = 0","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"τ is the time the source has emitted an acoustic disturbance\nt is the time the observer encounters the acoustic disturbance\nvecy is the position of the source\nvecx is the position of the observer\nc_0 is the speed of sound","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"AcousticAnalogies.jl currently uses an advanced time approach to solving this equation. This means we start with knowledge of tau and then calculate t—we \"advance\" the source time to the observer time by adding the amount of time it takes for the acoustic disturbance to travel from y to x.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Now, the R(t) = 0 equation is quite easy to solve if the observer is stationary. In that case, x is not a function of t, and so solving for t just involves moving everything in the parenthesis to the right-hand side. But if the observer is moving, things are more complicated. It may be impossible to solve for t explicitly in that case. It turns out, however, that there is an explicit solution for t in the advanced time approach if the observer is moving at a constant rate (see D. Casolino http://dx.doi.org/10.1016/S0022-460X(02)00986-0). The constant velocity case is actually quite handy, since it's what we need to compare to wind tunnel data.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"So, how do we test that we've implemented the solution to the R(t) = 0 advanced time equation correctly? In AcousticAnalogies.jl, we just use the nonlinear solver provided by NLsolve.jl, and compare its solution to AcousticAnalogies.jl. Here's how to do that:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies: AcousticAnalogies\nusing LinearAlgebra: norm\nusing NLsolve: NLsolve\nusing StaticArrays\n\n# Create a source element for the test.\n# The only things about the source element that matters to the advanced # time calculation is the time and position, and the speed of sound.\n# So everything else will be take on dummy values.\nτ = 2.5\ny = @SVector [-4.0, 3.0, 6.0]\nc0 = 2.0\ndummy0 = 1.0\ndummy3 = @SVector [0.0, 0.0, 0.0]\nse = AcousticAnalogies.CompactF1ASourceElement(dummy0, c0, dummy0, dummy0, y, dummy3, dummy3, dummy3, dummy3, dummy3, τ, dummy3)\n\n# Define a function that solves the advanced time equation using `nlsolve.\nfunction adv_time_nlsolve(se, obs)\n    # Create the residual equation that we'll solve.\n    # nlsolve assumes the residual function takes in and returns arrays.\n    R(t) = [t[1] - (se.τ + norm(obs(t[1]) .- se.y0dot)/se.c0)]\n\n    # Solve the advanced time equation.\n    result = NLsolve.nlsolve(R, [1.0], autodiff=:forward)\n    if !NLsolve.converged(result)\n        @error \"nlsolve advanced time calculation did not converge:\\n$(result)\"\n    end\n    t_obs = result.zero[1]\n    return t_obs\nend\n\n# Let's try it out.\n\n# First, a stationary observer:\nx0 = @SVector [-3.0, 2.0, 8.5]\nobs = AcousticAnalogies.StationaryAcousticObserver(x0)\nt_exact = AcousticAnalogies.adv_time(se, obs)\nt_nlsolve = adv_time_nlsolve(se, obs)\nprintln(\"stationary observer, exact: $(t_exact), nlsorve: $(t_nlsolve), difference = $(t_exact - t_nlsolve)\")\n\n# Next, a constant velocity observer:\nt0 = 3.5\nx0 = @SVector [-2.0, 3.5, 6.25]\nv = @SVector [-1.5, 1.5, 3.25]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0, x0, v)\nt_exact = AcousticAnalogies.adv_time(se, obs)\nt_nlsolve = adv_time_nlsolve(se, obs)\nprintln(\"constant velocity observer, exact: $(t_exact), nlsorve: $(t_nlsolve), difference = $(t_exact - t_nlsolve)\")","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Almost identical results, so things are good!","category":"page"},{"location":"sqa/#Combine-F1AOutput-Tests","page":"Software Quality Assurance","title":"Combine F1AOutput Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The function noise(se::CompactF1ASourceElement, obs::AcousticObserver) uses Farassat's formulation 1A to perform a prediction of the noise experienced by one observer obs due to one acoustic source se. Typically we will not have just one source, however. For example, the guided example in the docs uses 30 \"source elements\" to model each propeller blade. But we're interested in the acoustics experienced by obs due to all of the source elements, not just one. So, we need to combine the output of noise for one observer and all of the source elements. In AcousticAnalogies.jl, this is done by interpolating the time history of each source element's acoustics (the \"pressure time history\") onto a common chunk of time, and then adding them up. No big deal.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"But, how do we test the \"interpolating and adding\" routine, aka AcousticAnalogies.combine? That's pretty simple, actually: we just define some arbitrary functions that we'll use to create some pressure time histories, add them using the combine routine, and then compare that result to those created via evaluating those arbitrary functions on the same time grid used by the combine routine. If those match, then the test passes, and everything in the combine routine should be good. Let's try that:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing GLMakie\nusing Random\n\n# Goal is to verify that the code can faithfully combine two acoustic pressures on different time \"grids\" onto a single common grid.\n# These will be our made up functions:\nfa(t) = sin(2*pi*t) + 0.2*cos(4*pi*(t-0.1))\nfb(t) = cos(6*pi*t) + 0.3*sin(8*pi*(t-0.2))\n\n# Now we'll make some made up time grids.\nn = 101\nt1 = collect(range(0.0, 1.0, length=n))\ndt = t1[2] - t1[1]\n# Add a bit of random noise to the time grid.\n# Make sure that the amount of # randomness isn't large enough to make the time values non-monotonically increasing (i.e., they don't overlap).\nnoise = 0.49.*dt.*(1 .- 2 .* rand(size(t1)...))\nt1 .+= noise\n\nt2 = collect(range(0.1, 1.1, length=n))\ndt = t2[2] - t2[1]\nt2 .+= 0.49.*dt.*(1 .- 2 .* rand(size(t2)...))\n\n# Now let's create a bunch of pressure time histories on the time grids we just defined.\napth1 = @. AcousticAnalogies.F1AOutput(t1, fa(t1), 2*fa(t1))\napth2 = @. AcousticAnalogies.F1AOutput(t2, fb(t2), 3*fb(t2))\n\n# Calculate the \"exact\" answer by coming up with a common time, then evaluating the test functions directly on the common time grid.\nperiod = 0.5\nn_out = 51\nt_start = max(t1[1], t2[1])\nt_common = t_start .+ (0:n_out-1).*(period/n_out)\n\np_m = @. fa(t_common)+fb(t_common)\np_d = @. 2*fa(t_common)+3*fb(t_common)\n\neven_length = iseven(n_out)\napth_test = AcousticAnalogies.F1APressureTimeHistory{even_length}(p_m, p_d, step(t_common), first(t_common))\n\n# Put all the acoustic pressures in one array.\napth = hcat(apth1, apth2)\n\n# Combine.\napth_out = AcousticAnalogies.combine(apth, period, n_out)\n\n# Plot the two solutions.\nfig2 = Figure()\nax2_1 = fig2[1, 1] = Axis(fig2, xlabel=\"time\", ylabel=\"acoustic pressure, monopole\")\nax2_2 = fig2[2, 1] = Axis(fig2, xlabel=\"time\", ylabel=\"acoustic pressure, dipole\")\nscatter!(ax2_1, AcousticMetrics.time(apth_out), AcousticAnalogies.pressure_monopole(apth_out); marker=:x, label=\"AcousticAnalogies.combine\")\nscatter!(ax2_2, AcousticMetrics.time(apth_out), AcousticAnalogies.pressure_dipole(apth_out); marker=:x)\nlines!(ax2_1, AcousticMetrics.time(apth_test), AcousticAnalogies.pressure_monopole(apth_test); label=\"Exact\")\nlines!(ax2_2, AcousticMetrics.time(apth_test), AcousticAnalogies.pressure_dipole(apth_test))\nhidexdecorations!(ax2_1, grid=false)\naxislegend(ax2_1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:rt)\nsave(\"combine_test.png\", fig2)\nnothing # hide","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Right on top of each other.","category":"page"},{"location":"sqa/#F1A-Tests","page":"Software Quality Assurance","title":"F1A Tests","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The most complicated part of AcousticAnalogies.jl is the implementation of the F1A calculation itself. For example, the compact form of the F1A dipole term as implemented in AcousticAnalogies.jl (neglecting surface deformation) is","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"4 pi c_0 p_d = int_L=0 left left( dotvecf cdot vecD_1A + vecf cdot vecE_1A right) dr right","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where ","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"p_d is the \"dipole\" part of the acoustic pressure\nvecf is the loading per unit span on the source element\nvecdotf is the source-time derivative of the loading per unit span on the source element\ndr is the differential length of the source element\nc_0 is the ambient speed of sound\nvecD_1A and vecE_1A are complicated functions of the position, velocity, and acceleration of the source element\nL = 0 indicates the integration is performed over some curve defined by L = 0.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"How are we going to test that we have all that implemented properly? Well, it turns out that Farassat's original formulation (F1) is much simpler than F1A:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"4 pi c_0 p_d = fracpartialpartial t int_L=0 left( vecf cdot vecB_1right) dr + int_L=0left( vecf cdot vecC_1 right) dr","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where vecB_1 and vecC_1 are again functions of the position of the source element and time derivatives of the same. It might not look that much simpler, but it is, because:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The F1 integrands don't depend on dotvecf\nvecD_1A and vecE_1A from F1A are more complicated than vecB_1 and vecC_1, and involve higher-order time derivatives","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"But the key thing to understand about F1 and F1A is that they are equivalent—going from F1A to F1 involves some fancy math (moving the derivative with respect to the observer time t inside the integral), but should give the same answer. The only trick is this: how will we evaluate the derivatives with respect to the observer time t in the F1 expressions? What we'll do here is just use standard second-order-accurate finite difference approximations, i.e.,","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"fracpartial gpartial t = fracg(t+Delta t) - g(t-Delta t)2 Delta t + mathcalO(Delta t^2)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"where the notation mathcalO(Delta t^2) indicates that the error associated with the finite difference approximation should be proportional to Delta t^2. But this means that we can't expect our F1 calculation to exactly match F1A. So, what to do about that? What we can expect is that, if F1A and F1 have been implemented properly, the difference between them should go to zero at a second-order rate. So we can systematically reduce the time step size Delta t used to evaluate F1, and check that goes to zero at the expected rate. If it does, that proves that the only error between the two codes is due to the finite difference approximation, and gives us strong evidence that both F1A and F1 have been implemented properly.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"So, let's try it out! First we'll need a function that evaluates the f1 integrands","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using AcousticAnalogies\nusing LinearAlgebra: norm\nusing NLsolve\nusing Polynomials\nusing GLMakie\n\nfunction f1_integrand(se, obs, t)\n    c0 = se.c0\n\n    # Need to get the retarded time.\n    R(τ) = [t - (τ[1] + norm(obs(t) .- se.y0dot(τ[1]))/c0)]\n    result = nlsolve(R, [-0.1], autodiff=:forward)\n    if !converged(result)\n        @error \"nlsolve retarded time calculation did not converge:\\n$(result)\"\n    end\n    τ = result.zero[1]\n\n    # Position of source at the retarted time.\n    y = se.y0dot(τ)\n\n    # Position vector from source to observer.\n    rv = obs(t) .- y\n\n    # Distance from source to observer.\n    r = AcousticAnalogies.norm_cs_safe(rv)\n\n    # Unit vector pointing from source to observer.\n    rhat = rv./r\n\n    # First time derivative of rv.\n    rv1dot = -se.y1dot(τ)\n\n    # Mach number of the velocity of the source in the direction of the\n    # observer.\n    Mr = AcousticAnalogies.dot_cs_safe(-rv1dot/se.c0, rhat)\n\n    # Now evaluate the integrand.\n    p_m_integrand = se.ρ0/(4*pi)*se.Λ*se.Δr/(r*(1 - Mr))\n\n    # Loading at the retarded time.\n    f0dot = se.f0dot(τ)\n\n    p_d_integrand_ff = (1/(4*pi*c0))*AcousticAnalogies.dot_cs_safe(f0dot, rhat)/(r*(1 - Mr))*se.Δr\n    p_d_integrand_nf = (1/(4*pi*c0))*AcousticAnalogies.dot_cs_safe(f0dot, rhat)*c0/(r^2*(1 - Mr))*se.Δr\n\n    return τ, p_m_integrand, p_d_integrand_ff, p_d_integrand_nf\nend\n","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The f1_integrand function takes a source element se, and acoustic observer obs, and an observer time t and finds the source time and intermediate stuff that will eventually want to differentiate using the finite difference approximation.","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Now we need to make up a source and observer that we can test this out with:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"\n# https://docs.makie.org/v0.19/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfunction doit()\n    # Scale up the density to make the error bigger.\n    rho = 1.226e6  # kg/m^3\n    c0 = 340.0  # m/s\n    Rtip = 1.1684  # meters\n    radii = 0.99932*Rtip\n    dradii = (0.99932 - 0.99660)*Rtip  # m\n    area_over_chord_squared = 0.064\n    chord = 0.47397E-02 * Rtip\n    Λ = area_over_chord_squared * chord^2\n\n    theta = 90.0*pi/180.0\n    x0 = [cos(theta), 0.0, sin(theta)].*100.0.*12.0.*0.0254  # 100 ft in meters\n    obs = StationaryAcousticObserver(x0)\n\n    # Need the position and velocity of the source as a function of\n    # source/retarded time. How do I want it to move? I want it to rotate around\n    # an axis on the origin, pointing in the x direction.\n    rpm = 2200\n    omega = 2*pi/60*rpm\n    period = 60/rpm\n    fn = 180.66763939805125\n    fc = 19.358679206883078\n    y0dot(τ) = [0,  radii*cos(omega*τ), radii*sin(omega*τ)]\n    y1dot(τ) = [0, -omega*radii*sin(omega*τ), omega*radii*cos(omega*τ)]\n    y2dot(τ) = [0, -omega^2*radii*cos(omega*τ), -omega^2*radii*sin(omega*τ)]\n    y3dot(τ) = [0, omega^3*radii*sin(omega*τ), -omega^3*radii*cos(omega*τ)]\n    f0dot(τ) = [-fn, -sin(omega*τ)*fc, cos(omega*τ)*fc]\n    f1dot(τ) = [0, -omega*cos(omega*τ)*fc, -omega*sin(omega*τ)*fc]\n    u(τ) = y0dot(τ)./radii\n    sef1 = CompactF1ASourceElement(rho, c0, dradii, Λ, y0dot, y1dot, nothing, nothing, f0dot, nothing, 0.0, u)\n\n    t = 0.0\n    dt = period*0.5^4\n\n    τ0, pmi0, pdiff0, pdinf0 = f1_integrand(sef1, obs, t)\n    sef1a = CompactF1ASourceElement(rho, c0, dradii, Λ, y0dot(τ0), y1dot(τ0), y2dot(τ0), y3dot(τ0), f0dot(τ0), f1dot(τ0), τ0, u(τ0))\n    apth = noise(sef1a, obs)\n\n    err_prev_pm = nothing\n    err_prev_pd = nothing\n    dt_prev = nothing\n    dt_curr = dt\n    first_time = true\n\n    err_pm = Vector{Float64}()\n    err_pd = Vector{Float64}()\n    dts = Vector{Float64}()\n    ooa_pm = Vector{Float64}()\n    ooa_pd = Vector{Float64}()\n    # Gradually reduce time step size, recording the error and order-of-accuracy each time.\n    for n in 1:7\n        τ_1, pmi_1, pdiff_1, pdinf_1 = f1_integrand(sef1, obs, t-dt_curr)\n        τ1, pmi1, pdiff1, pdinf1 = f1_integrand(sef1, obs, t+dt_curr)\n\n        p_m_f1 = (pmi_1 - 2*pmi0 + pmi1)/(dt_curr^2)\n        p_d_f1 = (pdiff1 - pdiff_1)/(2*dt_curr) + pdinf0\n\n        err_curr_pm = abs(p_m_f1 - apth.p_m)\n        err_curr_pd = abs(p_d_f1 - apth.p_d)\n\n        if first_time\n            first_time = false\n        else\n            push!(ooa_pm, log(err_curr_pm/err_prev_pm)/log(dt_curr/dt_prev))\n            push!(ooa_pd, log(err_curr_pd/err_prev_pd)/log(dt_curr/dt_prev))\n        end\n\n        push!(dts, dt_curr)\n        push!(err_pm, err_curr_pm)\n        push!(err_pd, err_curr_pd)\n\n        dt_prev = dt_curr\n        err_prev_pm = err_curr_pm\n        err_prev_pd = err_curr_pd\n        dt_curr = 0.5*dt_curr\n    end\n\n    # Fit a line through the errors on a log-log plot, then check that the slope\n    # is second-order.\n    l = fit(log.(dts), log.(err_pm), 1)\n    println(\"monopole term convergence rate = $(l.coeffs[2])\")\n\n    l = fit(log.(dts), log.(err_pd), 1)\n    println(\"dipole term convergence rate = $(l.coeffs[2])\")\n\n    # Plot the error and observered order of accuracy.\n    fig = Figure()\n    ax1 = fig[1, 1] = Axis(fig, xlabel=\"time step size\", ylabel=\"error\", xscale=log10, xticks=LogTicks(IntegerTicks()), yscale=log10)\n    ax2 = fig[2, 1] = Axis(fig, xlabel=\"time step size\", ylabel=\"convergence rate\", xscale=log10, xticks=LogTicks(IntegerTicks()))\n    linkxaxes!(ax2, ax1)\n    lines!(ax1, dts, err_pm, label=\"monopole term\")\n    lines!(ax1, dts, err_pd, label=\"dipole term\")\n    lines!(ax2, dts[2:end], ooa_pm, label=\"monopole term\")\n    lines!(ax2, dts[2:end], ooa_pd, label=\"dipole term\")\n    ylims!(ax2, -0.1, 3.1)\n    axislegend(ax1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:lt)\n    save(\"f1a_test.png\", fig)\nend\n\ndoit()","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The convergence rate of the error (the bottom plot) is extremely close to 2, which is what we're looking for.","category":"page"},{"location":"sqa/#ANOPP2-Comparisons","page":"Software Quality Assurance","title":"ANOPP2 Comparisons","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticAnalogies.jl test suite includes comparisons to ANOPP2 predictions. Tests for a hypothetical isolated rotor are performed over a range of RPMs, with both stationary and moving observers. Here is an example using a moving observer:","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"using GLMakie\nusing FLOWMath: akima\ninclude(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"anopp2_run.jl\"))\nusing .ANOPP2Run\nrpm = 2200.0\nt, p_thickness, p_loading, p_monopole_a2, p_dipole_a2 = ANOPP2Run.get_results(;\n    stationary_observer=false, theta=0.0, f_interp=akima, rpm=rpm, irpm=11)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, monopole, Pa\")\nax2 = fig[2, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, dipole, Pa\")\nlines!(ax1, t, p_thickness, label=\"AcousticAnalogies.jl\")\nscatter!(ax1, t, p_monopole_a2, label=\"ANOPP2\", markersize=6)\nlines!(ax2, t, p_loading)\nscatter!(ax2, t, p_dipole_a2, markersize=6)\nhidexdecorations!(ax1, grid=false)\naxislegend(ax1; merge=true, unique=true, framevisible=false, bgcolor=:transparent, position=:lt)\nsave(\"anopp2_comparison.png\", fig)","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"(Image: )","category":"page"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The difference between the two codes' predictions is very small (less than 1% error).","category":"page"},{"location":"sqa/#Brooks,-Pope-and-Marcolini-Tests","page":"Software Quality Assurance","title":"Brooks, Pope & Marcolini Tests","text":"","category":"section"},{"location":"sqa/#Signed-Commits","page":"Software Quality Assurance","title":"Signed Commits","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"The AcousticAnalogies.jl GitHub repository requires all commits to the main branch to be signed. See the GitHub docs on signing commits for more information.","category":"page"},{"location":"sqa/#Reporting-Bugs","page":"Software Quality Assurance","title":"Reporting Bugs","text":"","category":"section"},{"location":"sqa/","page":"Software Quality Assurance","title":"Software Quality Assurance","text":"Users can use the GitHub Issues feature to report bugs and submit feature requests.","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"CurrentModule = AADocs","category":"page"},{"location":"bpm_tests2/#Software-Quality-Assurance,-Cont.","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Software Quality Assurance, Cont.","text":"","category":"section"},{"location":"bpm_tests2/#Brooks,-Pope,-and-Marcolini-Airfoil-Self-Noise-Tests,-Cont.","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Brooks, Pope, and Marcolini Airfoil Self-Noise Tests, Cont.","text":"","category":"section"},{"location":"bpm_tests2/#Laminar-Boundary-Layer-Vortex-Shedding-Tests","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Laminar Boundary Layer-Vortex Shedding Tests","text":"","category":"section"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c\", ylabel=\"Peak Strouhal number, St'_peak\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure86-St_1_prime.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nRe_c_bpm = bpm[:, 1]\nSt_1_prime_bpm = bpm[:, 2]\nscatter!(ax1, Re_c_bpm, St_1_prime_bpm, color=colors[1], markersize=4, label=\"BPM\")\n\nRe_c_jl = 10.0.^(range(4, 7; length=100))\nSt_1_prime_jl = AcousticAnalogies.St_1_prime.(Re_c_jl)\nlines!(ax1, Re_c_jl, St_1_prime_jl, color=colors[1], label=\"Julia\")\n\nxlims!(ax1, 1e4, 1e7)\nylims!(ax1, 0.01, 1)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure86.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"St'/St'_peak\", ylabel=\"Function G_1 level, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure85-G1.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\ne_bpm = bpm[:, 1]\nG1_bpm = bpm[:, 2]\nscatter!(ax1, e_bpm, G1_bpm, color=colors[1], markersize=4, label=\"BPM\")\n\ne_jl = 10.0.^(range(-1, 1; length=101))\nG1_jl = AcousticAnalogies.G1.(e_jl)\n\nlines!(ax1, e_jl, G1_jl, color=colors[1], label=\"Julia\")\n\nxlims!(ax1, 0.1, 10)\nylims!(ax1, -30, 0)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure85.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"alpha^*, deg\", ylabel=\"St'_peak/St'_1\",\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure87.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nalphastar_bpm = bpm[:, 1]\nSt_peak_ratio_bpm = bpm[:, 2]\nscatter!(ax1, alphastar_bpm, St_peak_ratio_bpm, color=colors[1], markersize=4, label=\"BPM\")\n\nSt_1_prime = 0.25  # Just make up a value, since we're multiplying and then dividing by it anyway.\nalphastar_jl = range(0.0*pi/180, 7.0*pi/180; length=21)\nSt_peak_ratio_jl = AcousticAnalogies.St_peak_prime.(St_1_prime, alphastar_jl)./St_1_prime\nlines!(ax1, alphastar_jl.*180/pi, St_peak_ratio_jl, color=colors[1], label=\"Julia\")\n\nxlims!(ax1, 0, 7)\nylims!(ax1, 0.5, 2)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure87.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c/Re_c0\", ylabel=\"G2 + G3\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure88-G2-alpha0.csv\")\nalphastar = 0.0*pi/180\nbpm = DelimitedFiles.readdlm(fname, ',')\nRe_c_bpm = bpm[:, 1]\nG2_bpm = bpm[:, 2]\nscatter!(ax1, Re_c_bpm, G2_bpm, color=colors[1], markersize=4, label=\"BPM - α^* = $(alphastar*180/pi)°\")\n\nRe_c_jl = 10.0.^range(log10(first(Re_c_bpm)), log10(last(Re_c_bpm)), length=51)\nRe_c0 = AcousticAnalogies.Re_c0(alphastar)\nRe_ratio_jl = Re_c_jl./Re_c0\n# G2_jl = AcousticAnalogies.G2.(Re_ratio_jl) .+ 171.04 .- 3.03*(alphastar*180/pi)\nG2_jl = AcousticAnalogies.G2.(Re_ratio_jl) .+ AcousticAnalogies.G3.(alphastar)\nlines!(ax1, Re_c_jl, G2_jl, color=colors[1], label=\"Julia - α^* = $(alphastar*180/pi)°\")\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure88-G2-alpha6.csv\")\nalphastar = 6.0*pi/180\nbpm = DelimitedFiles.readdlm(fname, ',')\nRe_c_bpm = bpm[:, 1]\nG2_bpm = bpm[:, 2]\nscatter!(ax1, Re_c_bpm, G2_bpm, color=colors[2], markersize=4, label=\"BPM - α^* = $(alphastar*180/pi)°\")\n\nRe_c_jl = 10.0.^range(log10(first(Re_c_bpm)), log10(last(Re_c_bpm)), length=51)\nRe_c0 = AcousticAnalogies.Re_c0(alphastar)\nRe_ratio_jl = Re_c_jl./Re_c0\n# G2_jl = AcousticAnalogies.G2.(Re_ratio_jl) .+ 171.04 .- 3.03*(alphastar*180/pi)\nG2_jl = AcousticAnalogies.G2.(Re_ratio_jl) .+ AcousticAnalogies.G3.(alphastar)\nlines!(ax1, Re_c_jl, G2_jl, color=colors[2], label=\"Julia - α^* = $(alphastar*180/pi)°\")\n\nxlims!(ax1, 10^4, 10^7)\nylims!(ax1, 125, 175)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure88.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing ColorSchemes: colorschemes\nusing DelimitedFiles: DelimitedFiles\n# using FLOWMath: linear\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\ncolors = colorschemes[:tab10]\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Re_c/Re_c0\", ylabel=\"G2\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()))\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure89.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nRe_ratio_bpm = bpm[:, 1]\nG2_bpm = bpm[:, 2]\nscatter!(ax1, Re_ratio_bpm, G2_bpm, color=colors[1], markersize=4, label=\"BPM\")\n\nRe_ratio_jl = 10.0.^range(-1, 1, length=51)\nG2_jl = AcousticAnalogies.G2.(Re_ratio_jl)\nlines!(ax1, Re_ratio_jl, G2_jl, color=colors[1], label=\"Julia\")\n\nxlims!(ax1, 0.1, 100)\nylims!(ax1, -45, 5)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure89.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/#Trailing-Edge-Bluntness-Vortex-Shedding-Tests","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Trailing Edge Bluntness-Vortex Shedding Tests","text":"","category":"section"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure95-0Psi.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nh_over_deltastar_0Psi = bpm[:, 1]\nSt_3prime_peak_0Psi = bpm[:, 2]\n \nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure95-14Psi.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nh_over_deltastar_14Psi = bpm[:, 1]\nSt_3prime_peak_14Psi = bpm[:, 2]\n\nh_over_deltastar_jl = 10.0.^(range(-1, 1; length=51))\nSt_3prime_peak_0Psi_jl = AcousticAnalogies.St_3prime_peak.(h_over_deltastar_jl, 0.0*pi/180)\nSt_3prime_peak_14Psi_jl = AcousticAnalogies.St_3prime_peak.(h_over_deltastar_jl, 14.0*pi/180)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Thickness ratio, h/δ^*\", ylabel=\"Peak Strouhal number, St'''_peak\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       yscale=log10,\n                       yminorticksvisible=true,\n                       yminorticks=IntervalsBetween(9),\n                       yticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 95\")\n\nscatter!(ax1, h_over_deltastar_0Psi, St_3prime_peak_0Psi; marker='o', label=\"Ψ = 0°, BPM\")\nlines!(ax1, h_over_deltastar_jl, St_3prime_peak_0Psi_jl; label=\"Ψ = 0°, Julia\")\n\nscatter!(ax1, h_over_deltastar_14Psi, St_3prime_peak_14Psi; marker='o', label=\"Ψ = 14°, BPM\")\nlines!(ax1, h_over_deltastar_jl, St_3prime_peak_14Psi_jl; label=\"Ψ = 14°, Julia\")\n\nxlims!(ax1, 0.2, 10.0)\nylims!(ax1, 0.05, 0.3)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure95.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure96-0Psi.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nh_over_deltastar_0Psi = bpm[:, 1]\nG4_0Psi = bpm[:, 2]\n \nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure96-14Psi.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nh_over_deltastar_14Psi = bpm[:, 1]\nG4_14Psi = bpm[:, 2]\n\nh_over_deltastar_jl = 10.0.^(range(-1, 1; length=51))\nG4_0Psi_jl = AcousticAnalogies.G4.(h_over_deltastar_jl, 0.0*pi/180)\nG4_14Psi_jl = AcousticAnalogies.G4.(h_over_deltastar_jl, 14.0*pi/180)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Thickness ratio, h/δ^*\", ylabel=\"Scaled peak SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 96\")\n\nscatter!(ax1, h_over_deltastar_0Psi, G4_0Psi; marker='o', label=\"Ψ = 0°, BPM\")\nlines!(ax1, h_over_deltastar_jl, G4_0Psi_jl; label=\"Ψ = 0°, Julia\")\n\nscatter!(ax1, h_over_deltastar_14Psi, G4_14Psi; marker='o', label=\"Ψ = 14°, BPM\")\nlines!(ax1, h_over_deltastar_jl, G4_14Psi_jl; label=\"Ψ = 14°, Julia\")\n\nxlims!(ax1, 0.1, 10.0)\nylims!(ax1, 110, 180)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure96.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar0p25.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p25 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg0p25 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar0p43.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p43 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg0p43 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar0p50.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p50 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg0p50 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar0p54.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p54 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg0p54 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar0p62.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p62 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg0p62 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi14-h_over_deltastar1p20.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_1p20 = bpm[:, 1]\nG5_14Psi_h_over_deltastar_avg1p20 = bpm[:, 2]\n\nSt_3prime_over_St_3prime_peak_jl = 10.0.^(range(-1, 10; length=1001))\nG5_14Psi_h_over_deltastar_avg0p25_jl = AcousticAnalogies.G5_Psi14.(0.25, St_3prime_over_St_3prime_peak_jl)\nG5_14Psi_h_over_deltastar_avg0p43_jl = AcousticAnalogies.G5_Psi14.(0.43, St_3prime_over_St_3prime_peak_jl)\nG5_14Psi_h_over_deltastar_avg0p50_jl = AcousticAnalogies.G5_Psi14.(0.50, St_3prime_over_St_3prime_peak_jl)\nG5_14Psi_h_over_deltastar_avg0p54_jl = AcousticAnalogies.G5_Psi14.(0.54, St_3prime_over_St_3prime_peak_jl)\nG5_14Psi_h_over_deltastar_avg0p62_jl = AcousticAnalogies.G5_Psi14.(0.62, St_3prime_over_St_3prime_peak_jl)\nG5_14Psi_h_over_deltastar_avg1p20_jl = AcousticAnalogies.G5_Psi14.(1.20, St_3prime_over_St_3prime_peak_jl)\n \nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Strouhal ratio, St'''/St'''_peak\", ylabel=\"G_5, Ψ=14°\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 97a\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p25, G5_14Psi_h_over_deltastar_avg0p25; label=\"h/δ^* = 0.25, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg0p25_jl; label=\"h/δ^* = 0.25, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p43, G5_14Psi_h_over_deltastar_avg0p43; label=\"h/δ^* = 0.43, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg0p43_jl; label=\"h/δ^* = 0.43, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p50, G5_14Psi_h_over_deltastar_avg0p50; label=\"h/δ^* = 0.50, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg0p50_jl; label=\"h/δ^* = 0.50, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p54, G5_14Psi_h_over_deltastar_avg0p54; label=\"h/δ^* = 0.54, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg0p54_jl; label=\"h/δ^* = 0.54, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p62, G5_14Psi_h_over_deltastar_avg0p62; label=\"h/δ^* = 0.62, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg0p62_jl; label=\"h/δ^* = 0.62, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_1p20, G5_14Psi_h_over_deltastar_avg1p20; label=\"h/δ^* = 1.20, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_14Psi_h_over_deltastar_avg1p20_jl; label=\"h/δ^* = 1.20, Julia\")\n\nxlims!(ax1, 0.1, 10.0)\nylims!(ax1, -30, 10)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure97a.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar0p25.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p25 = bpm[:, 1]\nG5_0Psi_h_over_deltastar_avg0p25 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar0p43.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p43 = bpm[:, 1]\nG5_0Psi_h_over_deltastar_avg0p43 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar0p50.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p50 = bpm[:, 1]\nG5_0Psi_h_over_deltastar_avg0p50 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar0p54.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_0p54 = bpm[:, 1]\nG5_0Psi_h_over_deltastar_avg0p54 = bpm[:, 2]\n\n# fname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar0p62.csv\")\n# bpm = DelimitedFiles.readdlm(fname, ',')\n# St_3prime_over_St_3prime_peak_0p62 = bpm[:, 1]\n# G5_0Psi_h_over_deltastar_avg0p62 = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure97-Psi0-h_over_deltastar1p20.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nSt_3prime_over_St_3prime_peak_1p20 = bpm[:, 1]\nG5_0Psi_h_over_deltastar_avg1p20 = bpm[:, 2]\n\nSt_3prime_over_St_3prime_peak_jl = 10.0.^(range(-1, 10; length=1001))\nG5_0Psi_h_over_deltastar_avg0p25_jl = AcousticAnalogies.G5_Psi0.(0.25, St_3prime_over_St_3prime_peak_jl)\nG5_0Psi_h_over_deltastar_avg0p43_jl = AcousticAnalogies.G5_Psi0.(0.43, St_3prime_over_St_3prime_peak_jl)\nG5_0Psi_h_over_deltastar_avg0p50_jl = AcousticAnalogies.G5_Psi0.(0.50, St_3prime_over_St_3prime_peak_jl)\nG5_0Psi_h_over_deltastar_avg0p54_jl = AcousticAnalogies.G5_Psi0.(0.54, St_3prime_over_St_3prime_peak_jl)\n# G5_0Psi_h_over_deltastar_avg0p62_jl = AcousticAnalogies.G5_Psi0.(0.62, St_3prime_over_St_3prime_peak_jl)\nG5_0Psi_h_over_deltastar_avg1p20_jl = AcousticAnalogies.G5_Psi0.(1.20, St_3prime_over_St_3prime_peak_jl)\n \nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"Strouhal ratio, St'''/St'''_peak\", ylabel=\"G_5, Ψ=0°\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 97b\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p25, G5_0Psi_h_over_deltastar_avg0p25; label=\"h/δ^* = 0.25, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg0p25_jl; label=\"h/δ^* = 0.25, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p43, G5_0Psi_h_over_deltastar_avg0p43; label=\"h/δ^* = 0.43, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg0p43_jl; label=\"h/δ^* = 0.43, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p50, G5_0Psi_h_over_deltastar_avg0p50; label=\"h/δ^* = 0.50, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg0p50_jl; label=\"h/δ^* = 0.50, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_0p54, G5_0Psi_h_over_deltastar_avg0p54; label=\"h/δ^* = 0.54, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg0p54_jl; label=\"h/δ^* = 0.54, Julia\")\n\n# scatter!(ax1, St_3prime_over_St_3prime_peak_0p62, G5_0Psi_h_over_deltastar_avg0p62; label=\"h/δ^* = 0.62, BPM\", marker='o')\n# lines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg0p62_jl; label=\"h/δ^* = 0.62, Julia\")\n\nscatter!(ax1, St_3prime_over_St_3prime_peak_1p20, G5_0Psi_h_over_deltastar_avg1p20; label=\"h/δ^* = 1.20, BPM\", marker='o')\nlines!(ax1, St_3prime_over_St_3prime_peak_jl, G5_0Psi_h_over_deltastar_avg1p20_jl; label=\"h/δ^* = 1.20, Julia\")\n\nxlims!(ax1, 0.1, 10.0)\nylims!(ax1, -30, 10)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure97b.png\", fig)","category":"page"},{"location":"bpm_tests2/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"CurrentModule = AADocs","category":"page"},{"location":"bpm_tests3/#Software-Quality-Assurance,-Cont.","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Software Quality Assurance, Cont.","text":"","category":"section"},{"location":"bpm_tests3/#Brooks,-Pope,-and-Marcolini-Airfoil-Self-Noise-Tests,-Cont.","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Brooks, Pope, and Marcolini Airfoil Self-Noise Tests, Cont.","text":"","category":"section"},{"location":"bpm_tests3/#Airfoil-Self-Noise-Predictions","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"Airfoil Self-Noise Predictions","text":"","category":"section"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure11-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# At zero angle of attack the pressure and suction side predictions are the same.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 11 (a) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure11-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure11-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# At zero angle of attack the pressure and suction side predictions are the same.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 55.5  # freestream velocity in m/s\n# M = 0.163  # Mach number, corresponds to U = 55.5 m/s in BPM report\nM = U/340.46\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nD_h = AcousticAnalogies.Dbar_h(θ_e, Φ_e, M, M_c)\nalphastar = 0.0\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 11 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure11-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure11-c-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# At zero angle of attack the pressure and suction side predictions are the same.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\n# M = 0.116  # Mach number, corresponds to U = 36.6 m/s in BPM report\nM = U/340.46\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nD_h = AcousticAnalogies.Dbar_h(θ_e, Φ_e, M, M_c)\nalphastar = 0.0\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 11 (c) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure11-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure11-d-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# At zero angle of attack the pressure and suction side predictions are the same.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # Mach number, corresponds to U = 31.7 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nD_h = AcousticAnalogies.Dbar_h(θ_e, Φ_e, M, M_c)\nalphastar = 0.0\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 11 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure11-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-U71.3-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-U71.3-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-U71.3-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 1.5*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 12 (a) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure12-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-b-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure12-b-TBL-TE-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 36.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 1.5*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 12 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure12-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure26-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Pressure and suction sides are the same for zero angle of attack.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 26 (a) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\n# scatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure26-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure26-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Pressure and suction sides are the same for zero angle of attack.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 55.5  # freestream velocity in m/s\nM = 0.163  # Mach number, corresponds to U = 55.5 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 26 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\n# scatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure26-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure26-c-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Pressure and suction sides are the same for zero angle of attack.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 26 (c) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure26-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure26-d-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Pressure and suction sides are the same for zero angle of attack.\nf_p = f_s\nSPL_p = SPL_s\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # Mach number, corresponds to U = 31.7 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 26 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\n# scatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure26-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-a-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-a-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 6.7*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 28 (a) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure28-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-b-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-b-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 55.5  # freestream velocity in m/s\nM = 0.163  # Mach number, corresponds to U = 55.5 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 6.7*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 28 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure28-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-c-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-c-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-c-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 6.7*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 28 (c) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure28-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-d-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-d-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure28-d-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # mach number, corresponds to u = 31.7 m/s in bpm report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 6.7*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"figure 28 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure28-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure38-d-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# fname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure38-d-TBL-TE-pressure.csv\")\n# bpm = DelimitedFiles.readdlm(fname, ',')\n# f_p = bpm[:, 1]\n# SPL_p = bpm[:, 2]\n# \n# fname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure38-d-separation.csv\")\n# bpm = DelimitedFiles.readdlm(fname, ',')\n# f_alpha = bpm[:, 1]\n# SPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 2.54e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # mach number, corresponds to u = 31.7 m/s in bpm report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"figure 38 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\n# scatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\n# lines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n# \n# scatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\n# lines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure38-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure39-d-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure39-d-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure39-d-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 2.54e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # mach number, corresponds to u = 31.7 m/s in bpm report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 4.8*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"figure 39 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure39-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure45-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure45-a-TBL-TE-pressure.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure45-a-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure45-a-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 30.48e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 1.5*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 45 (a) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker='◇', label=\"LBL-VS, BPM\")\nscatterlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; marker='◇', label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure45-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure48-c-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 22.86e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 48 (c) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 20, 60)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure48-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure54-a-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 15.24e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 2.7*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 54 (a) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 50, 90)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure54-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure59-c-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 59 (c) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure59-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure60-c-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 3.3*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 60 (c) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure60-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure60-d-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 10.16e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # mach number, corresponds to u = 31.7 m/s in bpm report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 3.3*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 60 (d) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure60-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure65-d-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 5.08e-2  # chord in meters\nU = 31.7  # freestream velocity in m/s\nM = 0.093  # mach number, corresponds to u = 31.7 m/s in bpm report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 65 (d) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 50, 90)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure65-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure66-b-LBL-VS.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_lbl_vs = bpm[:, 1]\nSPL_lbl_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 5.08e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 4.2*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_lbl_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_lblvs=true)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 66 (b) - U = $U m/s\")\n\nscatter!(ax1, f_lbl_vs, SPL_lbl_vs; marker=:diamond, label=\"LBL-VS, BPM\")\nscatterlines!(ax1, f_jl./1e3, SPL_lbl_vs_jl; label=\"LBL-VS, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure66-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure69-a-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 5.08e-2  # chord in meters\nU = 71.3  # freestream velocity in m/s\nM = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 15.4*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 69 (a) - U = $U m/s\")\n# scatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\n# scatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 60, 100)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure69-a.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# TBL-TE suction and pressure aren't significant sources for this case (deep stall).\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure69-b-separation.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_alpha = bpm[:, 1]\nSPL_alpha = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 5.08e-2  # chord in meters\nU = 39.6  # freestream velocity in m/s\nM = 0.116  # Mach number, corresponds to U = 39.6 m/s in BPM report\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 15.4*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 69 (b) - U = $U m/s\")\n# scatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\n# scatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_alpha, SPL_alpha; marker='△', label=\"separation, BPM\")\nlines!(ax1, f_jl./1e3, SPL_alpha_jl; label=\"separation, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure69-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure91-tip.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_tip = bpm[:, 1]\nSPL_tip = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 30.48e-2  # span in meters\nchord = 15.24e-2  # chord in meters\nspeedofsound = 340.46\nU = 71.3  # freestream velocity in m/s\n# M = 0.209  # Mach number, corresponds to U = 71.3 m/s in BPM report\nM = U/speedofsound\nM_c = 0.8*M\n# speedofsound = U/M\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nalphastar = 10.8*pi/180\n\nbl = AcousticAnalogies.UntrippedN0012BoundaryLayer()\nblade_tip = AcousticAnalogies.RoundedTip(AcousticAnalogies.BPMTipAlphaCorrection(), 0.0)\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_tip_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tip_vortex=true, blade_tip=blade_tip)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 91\")\nscatter!(ax1, f_tip, SPL_tip; marker='o', label=\"Tip, BPM\")\nlines!(ax1, f_jl./1e3, SPL_tip_jl; label=\"Tip, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 90)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure91.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 98 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-b-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 69.5  # freestream velocity in m/s\nM = U/340.46\nh = 1.1e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 98 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure98-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 98 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-c-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 69.5  # freestream velocity in m/s\nM = U/340.46\nh = 1.9e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 98 (c) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure98-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 98 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-a-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure98-d-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 69.5  # freestream velocity in m/s\nM = U/340.46\nh = 2.5e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 98 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 40, 80)\naxislegend(ax1, position=:lt)\nsave(\"19890016302-figure98-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 99 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 38.6  # freestream velocity in m/s\nM = U/340.46\nh = 1.1e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 99 (b) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure99-b.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 99 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-c-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 38.6  # freestream velocity in m/s\nM = U/340.46\nh = 1.9e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 99 (c) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure99-c.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: ExactThirdOctaveCenterBands\nusing DelimitedFiles: DelimitedFiles\nusing GLMakie\n\n# https://docs.makie.org/stable/examples/blocks/axis/index.html#logticks\nstruct IntegerTicks end\nMakie.get_tickvalues(::IntegerTicks, vmin, vmax) = ceil(Int, vmin) : floor(Int, vmax)\n\n# Figures 99 a-d only differ in trailing edge bluntness, so the other sources are all the same.\n# And TBL-TE is the only significant source, other than bluntness.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_s = bpm[:, 1]\nSPL_s = bpm[:, 2]\n\n# Suction and pressure are the same for zero angle of attack.\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-b-TBL-TE-suction.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_p = bpm[:, 1]\nSPL_p = bpm[:, 2]\n\nfname = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"brooks_airfoil_self_noise_and_prediction_1989\", \"19890016302-figure99-d-bluntness.csv\")\nbpm = DelimitedFiles.readdlm(fname, ',')\nf_teb_vs = bpm[:, 1]\nSPL_teb_vs = bpm[:, 2]\n\nnu = 1.4529e-5  # kinematic viscosity, m^2/s\nL = 45.72e-2  # span in meters\nchord = 60.96e-2  # chord in meters\nU = 38.6  # freestream velocity in m/s\nM = U/340.46\nh = 2.5e-3  # trailing edge bluntness in meters\nPsi = 14*pi/180  # bluntness angle in radians\nr_e = 1.22 # radiation distance in meters\nθ_e = 90*pi/180 \nΦ_e = 90*pi/180\nM_c = 0.8*M\nalphastar = 0.0*pi/180\n\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\nf_jl, SPL_s_jl, SPL_p_jl, SPL_alpha_jl, SPL_teb_vs_jl = AcousticAnalogies.calculate_bpm_test(nu, L, chord, U, M, r_e, θ_e, Φ_e, alphastar, bl; do_tebvs=true, h=h, Psi=Psi)\n\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig; xlabel=\"frequency, kHz\", ylabel=\"SPL_1/3, dB\",\n                       xscale=log10,\n                       xminorticksvisible=true,\n                       xminorticks=IntervalsBetween(9),\n                       xticks=LogTicks(IntegerTicks()),\n                       title=\"Figure 99 (d) - U = $U m/s\")\nscatter!(ax1, f_s, SPL_s; marker='o', label=\"TBL-TE suction side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_s_jl; label=\"TBL-TE suction side, Julia\")\n\nscatter!(ax1, f_p, SPL_p; marker='□', label=\"TBL-TE pressure side, BPM\")\nlines!(ax1, f_jl./1e3, SPL_p_jl; label=\"TBL-TE pressure side, Julia\")\n\nscatter!(ax1, f_teb_vs, SPL_teb_vs; marker='◺', label=\"Bluntness, BPM\")\nlines!(ax1, f_jl./1e3, SPL_teb_vs_jl; label=\"Bluntness, Julia\")\n\nxlims!(ax1, 0.2, 20.0)\nylims!(ax1, 30, 70)\naxislegend(ax1, position=:rt)\nsave(\"19890016302-figure99-d.png\", fig)","category":"page"},{"location":"bpm_tests3/","page":"BPM Airfoil Self-Noise Tests, Cont.","title":"BPM Airfoil Self-Noise Tests, Cont.","text":"(Image: )","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"CurrentModule = AADocs","category":"page"},{"location":"ccblade_example/#Compact-Formulation-1A-CCBlade.jl-Example","page":"CCBlade.jl Example","title":"Compact Formulation 1A CCBlade.jl Example","text":"","category":"section"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"AcousticAnalogies.jl contains routines that take in types defined by CCBlade.jl, a blade element momentum theory (BEMT) code and construct the types used by AcousticAnalogies.jl for acoustic predictions. This makes it simple to go from a BEMT aerodynamic prediction of a propeller or rotor to an acoustic prediction.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"First step is to load up CCBlade.jl.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using CCBlade: parsefile, viterna, AlphaAF, SkinFriction, PrandtlGlauert, DuSeligEggers, PrandtlTipHub, Rotor, Section, OperatingPoint, solve, linearliftcoeff\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Then we'll define some parameters we'll need to create the CCBlade.jl types. First some atmospheric properties:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"gam = 1.4\nR = 287.058  # J/(kg*K)\nrho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nmu = 0.1780e-4  # kg/(m*s)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And some blade geometry parameters:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"num_blades = 3\nnum_radial = 30\nprecone = 0.0                                   # rad\nRtip = 0.5*24*0.0254                            # blade radius, m\nRhub = 0.2*Rtip                                 # hub radius, m\nr_ = range(Rhub, Rtip, length=num_radial+1)     # blade element interfaces\nradii = 0.5.*(r_[2:end] .+ r_[1:end-1])         # blade element centers, m\nc = 1.5*0.0254                                  # (constant) chord, m\nchord = fill(c, num_radial)                     # chord, m\nD = 2*Rtip                                      # blade diameter, m\nP = 16*0.0254                                   # propeller pitch, m\ntwist = @. atan(P/(pi*D*radii/Rtip))            # twist, rad\narea_over_chord_squared = 0.08217849116518001   # Cross-sectional area per chord^2 for NACA0012.\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"We also need airfoil lift and drag coefficients as a function of angle of attack. CCBlade.jl has routines for interpolating and correcting airfoil lift and drag data. Here we're starting with NACA0012 airfoil data from airfoiltools.com:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"af_fname = joinpath(@__DIR__, \"assets\", \"xf-n0012-il-500000.dat\")\ninfo, Re, Mach, alpha, cl, cd = parsefile(af_fname, false)\n\n# Extend the angle of attack with the Viterna method.\ncr75 = c/Rtip\n(alpha, cl, cd) = viterna(alpha, cl, cd, cr75)\naf = AlphaAF(alpha, cl, cd, info, Re, Mach)\n\n# Reynolds number correction. The 0.6 factor seems to match the NACA 0012\n# drag data from airfoiltools.com.\nreynolds = SkinFriction(Re, 0.6)\n\n# Mach number correction.\nmach = PrandtlGlauert()\n\n# Rotational stall delay correction. Need some parameters from the CL curve.\nm, alpha0 = linearliftcoeff(af, 1.0, 1.0)  # dummy values for Re and Mach\n# Create the Du Selig and Eggers correction.\nrotation = DuSeligEggers(1.0, 1.0, 1.0, m, alpha0)\n\n# The usual hub and tip loss correction.\ntip = PrandtlTipHub()\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Finally, the freestream velocity and the rotor rotation rate:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"v = 0.11*c0  # m/s\nomega = 7100 * 2*pi/60  # rad/s\npitch = 0.0 # rad\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we have enough information to create the CCBlade.jl structs we'll need.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"rotor = Rotor(Rhub, Rtip, num_blades; precone=precone, turbine=false, mach=mach, re=reynolds, rotation=rotation, tip=tip)\nsections = Section.(radii, chord, twist, Ref(af))\nops = OperatingPoint.(v, omega.*radii, rho, pitch, mu, c0)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And we can use CCBlade.jl to solve the BEMT equations.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"outs = solve.(Ref(rotor), sections, ops)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And then make some plots.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using GLMakie\nfig1 = Figure()\nax1_1 = fig1[1, 1] = Axis(fig1, xlabel=\"radii/Rtip\", ylabel=\"normal load/span, N/m\")\nax1_2 = fig1[2, 1] = Axis(fig1, xlabel=\"radii/Rtip\", ylabel=\"circum load/span, N/m\")\nlines!(ax1_1, radii./Rtip, getproperty.(outs, :Np))\nlines!(ax1_2, radii./Rtip, getproperty.(outs, :Tp))\nhidexdecorations!(ax1_1, grid=false)\nsave(\"ccblade_example-ccblade_loads.png\", fig1)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"(Image: )","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we can use the CCBlade.jl structs to create AcousticAnalogies.jl source elements. The key function is f1a_source_elements_ccblade:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"f1a_source_elements_ccblade","category":"page"},{"location":"ccblade_example/#AcousticAnalogies.f1a_source_elements_ccblade","page":"CCBlade.jl Example","title":"AcousticAnalogies.f1a_source_elements_ccblade","text":"f1a_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, area_per_chord2::Vector{AbstractFloat}, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of CompactF1ASourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs::Vector of CCBlade output objects.\narea_per_chord2: cross-sectional area divided by the chord squared of the element at each CCBlade.section. Should be a Vector{AbstractFloat}, same length as sections, ops, outputs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"function"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"So let's try that:","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using AcousticAnalogies: f1a_source_elements_ccblade, ConstVelocityAcousticObserver, noise, combine, pressure_monopole, pressure_dipole\nbpp = 2*pi/omega/num_blades  # blade passing period\npositive_x_rotation = true\nses = f1a_source_elements_ccblade(rotor, sections, ops, outs, [area_over_chord_squared], 4*bpp, 64, positive_x_rotation)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"Now we can use the source elements to perform an acoustic prediction, after we decide on an acoustic observer location.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"using AcousticMetrics\n# Sideline microphone location in meters.\nx_obs = [0.0, 2.3033, 2.6842]\nv_obs = [v, 0.0, 0.0]\nobs = ConstVelocityAcousticObserver(0.0, x_obs, v_obs)\napth = noise.(ses, Ref(obs))\napth_total = combine(apth, 2*bpp, 64)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"And finally plot the acoustic pressure time history.","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"fig2 = Figure()\nax2_1 = fig2[1, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, monopole, Pa\")\nax2_2 = fig2[2, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, dipole, Pa\")\nax2_3 = fig2[3, 1] = Axis(fig2, xlabel=\"time, blade passes\", ylabel=\"acoustic pressure, total, Pa\")\nt = AcousticMetrics.time(apth_total)\nt_nondim = (t .- t[1])./bpp\nlines!(ax2_1, t_nondim, pressure_monopole(apth_total))\nlines!(ax2_2, t_nondim, pressure_dipole(apth_total))\nlines!(ax2_3, t_nondim, AcousticMetrics.pressure(apth_total))\nhidexdecorations!(ax2_1, grid=false)\nhidexdecorations!(ax2_2, grid=false)\nsave(\"ccblade_example-apth.png\", fig2)\nnothing # hide","category":"page"},{"location":"ccblade_example/","page":"CCBlade.jl Example","title":"CCBlade.jl Example","text":"(Image: )","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"CurrentModule = AADocs","category":"page"},{"location":"openfast_example/#Compact-Formulation-1A-OpenFAST-Example","page":"OpenFAST Example","title":"Compact Formulation 1A OpenFAST Example","text":"","category":"section"},{"location":"openfast_example/#Introduction","page":"OpenFAST Example","title":"Introduction","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"This example loads a .out file generated by the popular aeroserohydroelastic solver OpenFAST, which is released by the U.S. National Renewable Energy Laboratory to simulate wind turbines,  and then constructs the types used by AcousticAnalogies.jl for acoustic predictions.  The example simulates the acoustic emissions of the 3.4MW land-based reference wind turbine released by the International Wind Energy Agency. The OpenFAST model is available at https://github.com/IEAWindTask37/IEA-3.4-130-RWT.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"We start by loading Julia dependencies, which are available in the General registry","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"using AcousticAnalogies: AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing ColorSchemes: colorschemes\nusing FillArrays: FillArrays, getindex_value\nusing GLMakie\nusing KinematicCoordinateTransformations: SteadyRotYTransformation\nusing StaticArrays: @SVector\nnothing # hide","category":"page"},{"location":"openfast_example/#Inputs","page":"OpenFAST Example","title":"Inputs","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Next, we set the user-defined inputs:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"number of blades, usually 3 for modern wind turbines\nhub radius in m, it is specified in the ElastoDyn main input file of OpenFAST\nblade spanwise grid in m and the corresponding chord, also in m. The two arrays are specified in the AeroDyn15 blade input file\nObserver location in the global coordinate frame (located at the rotor center, x points downwind, z points vertically up, and y points sideways). In this case we picked the IEC-prescribed location (turbine height on the ground) by specifying the hub height of 110 m.\nAir density and speed of sound\nPath to the OpenFAST .out file. The file must contain these channels: Time (always available), Wind1VelX from InflowWind, RotSpeed from ElastoDyn, Nodal outputs Fxl and Fyl from AeroDyn15. the file is available in the repo under test/gen_test_data/openfast_data.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"# num_blades = 3\nRhub = 2.\nBlSpn = [0.0000e+00, 2.1692e+00, 4.3385e+00, 6.5077e+00, 8.6770e+00, 1.0846e+01, 1.3015e+01, 1.5184e+01, \n    1.7354e+01, 1.9523e+01, 2.1692e+01, 2.3861e+01, 2.6031e+01, 2.8200e+01, 3.0369e+01, 3.2538e+01, \n    3.4708e+01, 3.6877e+01, 3.9046e+01, 4.1215e+01, 4.3385e+01, 4.5554e+01, 4.7723e+01, \n    4.9892e+01, 5.2062e+01, 5.4231e+01, 5.6400e+01, 5.8570e+01, 6.0739e+01, 6.2908e+01]\nChord = [2.600e+00, 2.645e+00, 3.020e+00, 3.437e+00, 3.781e+00, 4.036e+00, 4.201e+00, \n    4.284e+00, 4.288e+00, 4.223e+00, 4.098e+00, 3.923e+00, 3.709e+00, 3.468e+00, 3.220e+00, \n    2.986e+00, 2.770e+00, 2.581e+00, 2.412e+00, 2.266e+00, 2.142e+00, 2.042e+00, 1.964e+00, \n    1.909e+00, 1.870e+00, 1.807e+00, 1.666e+00, 1.387e+00, 9.172e-01, 1.999e-01]\nfile_path = joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_test_data\", \"openfast_data\", \"IEA-3.4-130-RWT.out\")\nHH = 110. # m\nRSpn = BlSpn .+ Rhub\nx0 = @SVector [HH .+ RSpn[end], 0.0, -HH]\nrho = 1.225  # kg/m^3\nc0 = 340.0  # m/s\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"For the monopole/thickness noise, we need the cross-sectional area at each radial station. If we know the cross-sectional area per chord squared, we can find the cross-sectional area this way:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"# Cross-sectional area of each element in m**2. This is taking a bit of a shortcut—the value of `cs_area_over_chord_squared` does not actually correspond to the IEAWindTask37 turbine blade.\ncs_area_over_chord_squared = 0.064\ncs_area = cs_area_over_chord_squared .* Chord.^2\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Next, we'll use the read_openfast_file function to read the OpenFAST output file:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"# Read the data from the file and create an `OpenFASTData` object, a simple struct with fields like `time`, `omega`, `axial_loading`, etc.\ndata = AcousticAnalogies.read_openfast_file(file_path, RSpn, cs_area; average_freestream_vel=true, average_omega=true)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"That will read the data in the file, but also do a bit of processing necessary for an acoustic prediction.  Specifically, it will...","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"interpolate the cross-sectional area and loading from the blade element interfaces to the cell centers,\nuse second-order finite differences to differentiate the loading with respect to time,\naverage the freestream velocity and RPM (if average_freestream_vel or average_omega keyword arguments are true)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The read_openfast_file doc string has more information.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The output of read_openfast_file is a OpenFASTData struct that has fields like time, omega, axial_loading, etc. that are read from the output file, and also fields like radii_mid, circum_loading_mid_dot that are created after the output file is read. Check out the OpenFASTData doc string for a list of all the fields.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"We can get the averaged rotation rate value from the OpenFASTData struct this way:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"omega_avg = getindex_value(data.omega)\n@show omega_avg\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(When averaging rotation rate or freestream velocity, read_openfast_file uses a Fill struct from the FillArrays.jl package to lazily represent the average omega value as a length-num_times Vector, and getindex_value is a function from FillArrays.jl that returns that single averaged value. Could have also just indexed the data.omega array at the first value, or last, etc..)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"@show data.omega[1] data.omega[8] data.omega[end]\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Before we actually try an acoustic prediction, let's have a look at the loading. We'll use the Makie plotting package to make the plots, and only plot 1 out of every 500 time steps (as seen in the for tidx line):","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"ntimes_loading = size(data.axial_loading_mid, 1)\nfig = Figure()\nax11 = fig[1, 1] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fx (N/m)\", title=\"blade 1\")\nax21 = fig[2, 1] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fy (N/m)\")\nax12 = fig[1, 2] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fx (N/m)\", title=\"blade 2\")\nax22 = fig[2, 2] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fy (N/m)\")\nax13 = fig[1, 3] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fx (N/m)\", title=\"blade 3\")\nax23 = fig[2, 3] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"Fy (N/m)\")\nnum_blades = data.num_blades\ncolormap = colorschemes[:viridis]\ntime = data.time\nsim_length_s = time[end] - time[begin]\nfor tidx in 1:500:ntimes_loading\n    cidx = (time[tidx] - time[1])/sim_length_s\n    l1 = lines!(ax11, data.radii_mid, data.axial_loading_mid[tidx,:,1], label =\"b1\", color=colormap[cidx])\n    l1 = lines!(ax12, data.radii_mid, data.axial_loading_mid[tidx,:,2], label =\"b2\", color=colormap[cidx])\n    l1 = lines!(ax13, data.radii_mid, data.axial_loading_mid[tidx,:,3], label =\"b3\", color=colormap[cidx])\n    l2 = lines!(ax21, data.radii_mid, data.circum_loading_mid[tidx,:,1], label =\"b1\", color=colormap[cidx])\n    l2 = lines!(ax22, data.radii_mid, data.circum_loading_mid[tidx,:,2], label =\"b2\", color=colormap[cidx])\n    l2 = lines!(ax23, data.radii_mid, data.circum_loading_mid[tidx,:,3], label =\"b3\", color=colormap[cidx])\nend\n\nlinkxaxes!(ax21, ax11)\nlinkxaxes!(ax12, ax11)\nlinkxaxes!(ax22, ax11)\nlinkxaxes!(ax13, ax11)\nlinkxaxes!(ax23, ax11)\n\nlinkyaxes!(ax12, ax11)\nlinkyaxes!(ax13, ax11)\n\nlinkyaxes!(ax22, ax21)\nlinkyaxes!(ax23, ax21)\n\nhidexdecorations!(ax11, grid=false)\nhidexdecorations!(ax12, grid=false)\nhidexdecorations!(ax13, grid=false)\nhideydecorations!(ax12, grid=false)\nhideydecorations!(ax13, grid=false)\nhideydecorations!(ax22, grid=false)\nhideydecorations!(ax23, grid=false)\n\ncbar = fig[:, 4] = Colorbar(fig; limits=(time[begin], time[end]), colormap=:viridis, label=\"time (sec)\")\n\nsave(joinpath(@__DIR__, \"openfast_example_loading.png\"), fig)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(Image: Loading)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The x axis of each subplot is the radial position along the blade, from hub to tip. The top three plots show the axial loading, bottom three the circumferential, and there's one column for each blade. And the colorbar indicates the simulation time. The plot shows significant unsteadiness, which is cool to see.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"We can also plot the loading time derivative in a similar form:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"ntimes_loading = size(data.axial_loading_mid_dot, 1)\nfig = Figure()\nax11 = fig[1, 1] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fx/∂t (N/(m*s))\", title=\"blade 1\")\nax21 = fig[2, 1] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fy/∂t (N/(m*s))\")\nax12 = fig[1, 2] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fx/∂t (N/(m*s))\", title=\"blade 2\")\nax22 = fig[2, 2] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fy/∂t (N/(m*s))\")\nax13 = fig[1, 3] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fx/∂t (N/(m*s))\", title=\"blade 3\")\nax23 = fig[2, 3] = Axis(fig, xlabel=\"Span Position (m)\", ylabel=\"∂Fy/∂t (N/(m*s))\")\nnum_blades = data.num_blades\ncolormap = colorschemes[:viridis]\ntime = data.time\nsim_length_s = time[end] - time[begin]\nfor tidx in 1:500:ntimes_loading\n    cidx = (time[tidx] - time[1])/sim_length_s\n    l1 = lines!(ax11, data.radii_mid, data.axial_loading_mid_dot[tidx,:,1], label =\"b1\", color=colormap[cidx])\n    l1 = lines!(ax12, data.radii_mid, data.axial_loading_mid_dot[tidx,:,2], label =\"b2\", color=colormap[cidx])\n    l1 = lines!(ax13, data.radii_mid, data.axial_loading_mid_dot[tidx,:,3], label =\"b3\", color=colormap[cidx])\n    l2 = lines!(ax21, data.radii_mid, data.circum_loading_mid_dot[tidx,:,1], label =\"b1\", color=colormap[cidx])\n    l2 = lines!(ax22, data.radii_mid, data.circum_loading_mid_dot[tidx,:,2], label =\"b2\", color=colormap[cidx])\n    l2 = lines!(ax23, data.radii_mid, data.circum_loading_mid_dot[tidx,:,3], label =\"b3\", color=colormap[cidx])\nend\n\nlinkxaxes!(ax21, ax11)\nlinkxaxes!(ax12, ax11)\nlinkxaxes!(ax22, ax11)\nlinkxaxes!(ax13, ax11)\nlinkxaxes!(ax23, ax11)\n\nlinkyaxes!(ax12, ax11)\nlinkyaxes!(ax13, ax11)\n\nlinkyaxes!(ax22, ax21)\nlinkyaxes!(ax23, ax21)\n\nhidexdecorations!(ax11, grid=false)\nhidexdecorations!(ax12, grid=false)\nhidexdecorations!(ax13, grid=false)\nhideydecorations!(ax12, grid=false)\nhideydecorations!(ax13, grid=false)\nhideydecorations!(ax22, grid=false)\nhideydecorations!(ax23, grid=false)\n\ncbar = fig[:, 4] = Colorbar(fig; limits=(time[begin], time[end]), colormap=:viridis, label=\"time (sec)\")\n\nsave(joinpath(@__DIR__, \"openfast_example_loading_dot.png\"), fig)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(Image: Loading Time Derivative)","category":"page"},{"location":"openfast_example/#Constructing-the-Source-Elements","page":"OpenFAST Example","title":"Constructing the Source Elements","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now, the next step is to turn the OpenFAST data into source elements. This step is pretty easy, since there is a function called f1a_source_elements_openfast that takes the OpenFASTData struct and a few other parameters and will create the source elements for us. But first we need to think about the coordinate system we'd like our source elements to be in. Eventually, we want the turbine blades to be rotating about the positive x axis, with the freestream velocity pointing in the positive x axis direction. But there are two things we need to account for to make that happen:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"To do a proper noise prediction, AcousticAnalogies.jl needs the source elements' motion to be defined in a reference frame relative to the ambient fluid, not the ground. Put another way, we need to manipulate the source elements in a way so that it appears that there is no freestream velocity—that the ambient fluid is stationary. So instead of having blade elements that are only rotating about a fixed hub position relative to the ground in a freestream pointed in the positive x direction, we will have the blade elements translate in the negative x direction as they rotate, with no freestream velocity.\nThe f1a_source_elements_openfast routine puts the source elements in the Standard AcousticAnalogies.jl Reference Frame™, where the source elements \nbegin with the hub (rotation center) at coordinate system origin at source time t = 0,\nrotate about either the positive x or negative x axis (depending on the value of the positive_x_rotation argument),\ntranslate in the positive x direction.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"So, to make all this work, we'll initially have the source elements translate in the positive x direction (as required by f1a_source_elements_openfast) and rotate about the negative x axis. Then we'll rotate the source elements 180° about the y axis, which will mean they will be translating in the negative x axis, rotating about the positive x axis, just like what we intend.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"So, here's the first step: create the source elements from the OpenFASTData struct, where they'll be rotating about the negative x axis, translating along the positive x axis.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"positive_x_rotation = false\nses_before_roty = AcousticAnalogies.f1a_source_elements_openfast(data, rho, c0, positive_x_rotation)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The f1a_source_elements_openfast returns an array of CompactF1ASourceElement structs. The array is of size (num_times, num_radial, num_blades), where ses[i, j, k] refers to the source element of the ith time step, jth radial position, and kth blade:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"@show size(ses_before_roty)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now we'll rotate each source element 180° about the positive y axis.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"# Create the object from KinematicCoordinateTransformations.jl defining the 180° rotation about the y axis.\nrot180degy = SteadyRotYTransformation(0, 0, pi)\n\n# Now rotate the source elements.\nses = rot180degy.(ses_before_roty)\n\n# Could have combined all that in one line, i.e.,\n# ses = rot180degy.(AcousticAnalogies.f1a_source_elements_openfast(data, rho, c0, positive_x_rotation))\nnothing # hide","category":"page"},{"location":"openfast_example/#Defining-the-Observer","page":"OpenFAST Example","title":"Defining the Observer","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The last thing we need before we can perform the noise prediction is an acoustic observer. The observer is just the computational equivalent of the microphone—a fictitious, possibly moving point in space that will \"receive\" the noise produced by each source element. In this case we picked the IEC-prescribed location (turbine height on the ground) by specifying the hub height of 110 m. So we need the observer to be 110 m below the hub. We'll also have the observer positioned downstream of the turbine rotation plane by a certain amount.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"x0_obs = @SVector [HH + RSpn[end], 0.0, -HH]\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(The @SVector macro creates a statically-size vector using the StaticArrays.jl package, which is good for performance but not required.)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now, just like with the source elements, we need to define the motion of the observer relative to the fluid, not the ground. So, we'll use the same trick that we used with the source elements: have the observer translate in the negative x direction to account for the freestream velocity that's pointed in the positive x direction:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"# Get the average freestream velocity from the OpenFAST data.\nv_avg = getindex_value(data.v)\n\n# Create a vector defining the velocity of the observer.\nv_obs = @SVector [-v_avg, 0, 0]\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Since the observer is moving, its position is obviously changing. So the x0_obs will be the position of the observer at the start of the simulation, at the first source time level of the source elements. We can get that first source time level this way:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"t0_obs = data.time[1]\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now we have enough information to create the observer object:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"obs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"That says that we want our observer to start at the location x0_obs at time t0_obs, and then move with constant velocity v_obs forever after. After creating the observer, we can query its location at any time value after this way:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"@show obs(t0_obs) # should be equal to `x0_obs`\n@show obs(t0_obs + 1)\nnothing # hide","category":"page"},{"location":"openfast_example/#Visualization-with-VTK-Files","page":"OpenFAST Example","title":"Visualization with VTK Files","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"That was a lot. How will we know we did all that correctly? The answer is: write out the source elements and observer we just created to VTK files, and then visualize them with our favorite visualization software (ParaView at the moment).","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The function we want is to_paraview_collection. Using it is simple:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"AcousticAnalogies.to_paraview_collection(\"openfast_example_with_obs\", (ses,); observers=(obs,))\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(This form of to_paraview_collection expects multiple arrays of source elements and multiple observers. But here we just have one array of source elements (ses) and one observer (obs), so we wrap each in a single-entry tuple, i.e., (ses,) and (obs,).)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"That will write out a bunch of VTK files showing the motion of the source elements and the observer, all starting with the name argument to the function (openfast_example_with_obs here). The one to focus on is openfast_example_with_obs.pvd, a ParaView data file that describes how all the many VTK files that to_paraview_collection writes out fit together.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The VTK files for the source elements will also contain all the data defined in the source element structs (the loading, cross-sectional area, etc.). That's really handy for checking that the loading is in the correct direction (remember, it needs to be the loading on the fluid, i.e. exactly opposite the loading on the blades).","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"To that end, here's an animation of the blades and observer, with the blades colored by the loading per unit span in the y direction:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(Image: LoadingY, Iso)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Things look pretty good: the observer (i.e. the gray sphere) and the blades are all translating in the negative x direction, and the blades are rotating about the positive x axis. (The gray smearing along the path of the observer is an artifact of the compression process the gif went through to make the file smaller.) The y-component of the loading also appears to be in the correction direction: for a wind turbine, we'd expect the loading on the fluid to oppose the motion of the blade in the circumferential direction, which is what the animation shows.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"One thing that is troubling about the previous animation is the location of the observer relative to the blades in the y direction. Since the rotor hub starts at the origin and moves along the negative x axis, and since y component of the observer position is always zero, the observer should only be offset in the x and z directions relative to the hub path. That's hard to see in the previous animation, but if we switch our perspective to be looking directly downstream (i.e., looking in the positive-x direction), everything appears as it should be:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(Image: LoadingY, Downstream)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Both the blade hub and the observer appear to be moving in the y=0 plane.","category":"page"},{"location":"openfast_example/#Noise-Prediction","page":"OpenFAST Example","title":"Noise Prediction","text":"","category":"section"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now we're finally ready to do a noise prediction! The relevant function for that is noise, which takes in a source element and observer and returns an F1AOutput struct, representing the acoustic pressure experienced by the observer due to the source:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"apth = AcousticAnalogies.noise.(ses, Ref(obs))\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Notice that we used a . after the noise function, which broadcasts the noise call over all source element-observer combinations. (The Ref(obs) makes the single observer struct act as a scalar during broadcasting, meaning the same observer object is passed to each noise call.) Because of the broadcasting, apth is an Array of F1AOutput structs with the same size as ses:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"@show size(ses) size(apth)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"We now have a noise prediction for each of the individual source elements in ses at the acoustic observer obs—specifically, apth[i, j, k] represents the acoustic pressure for the i time step, j radial location, and k blade. What we ultimately want is the total noise prediction at obs—we want to add all the acoustic pressures for each time level in apth together.  But we can't add them directly, yet, since the observer times—the time at which each source's noise reaches the observer—are not all the same. What we need to do is first interpolate the acoustic pressure time history of each source onto a common series of observer time levels, and then add them up.  We'll do this using the combine function. First, we need to decide on the length of the observer time series and how many points it will contain. If the motion and loading of the blades was steady, then one blade pass would be sufficient, but for this example that is not the case, so we'll use a longer observer time:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"rev_period = 2*pi/omega_avg\nbpp = rev_period/num_blades  # blade passing period\nomega_rpm = omega_avg * 60/(2*pi)\nobs_time_range = sim_length_s/60*omega_rpm*bpp\nnum_obs_times = length(data.time)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"So that says that we'll have an output observer time length of obs_time_range with num_obs_times points. Note that we need to be careful to avoid extrapolation in the combine calculation, which will happen if the observer time specified via the obs_time_range and num_obs_times arguments to combine extends past the times contained in the apth array. That won't happen in this case, since obs_time_range/sim_length_s is 1/3, so the observer time range is much less than the source time range.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"Now we call combine to get the total acoustic pressure time history:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"time_axis = 1\napth_total = AcousticAnalogies.combine(apth, obs_time_range, num_obs_times, time_axis)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"With that, we're finally able to plot the acoustic pressure time history:","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"fig = Figure()\nax1 = fig[1, 1] = Axis(fig, xlabel=\"time, s\", ylabel=\"monopole, Pa\")\nax2 = fig[2, 1] = Axis(fig, xlabel=\"time, s\", ylabel=\"dipole, Pa\")\nax3 = fig[3, 1] = Axis(fig, xlabel=\"time, s\", ylabel=\"total, Pa\")\nl1 = lines!(ax1, time, apth_total.p_m)\nl2 = lines!(ax2, time, apth_total.p_d)\nl3 = lines!(ax3, time, apth_total.p_m.+apth_total.p_d)\nhidexdecorations!(ax1, grid=false)\nhidexdecorations!(ax2, grid=false)\nsave(joinpath(@__DIR__, \"openfast-apth_total.png\"), fig)\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"(Image: Acoustic Pressure Time History)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The plot shows that the monopole/thickness noise is much lower than the dipole/loading noise. Wind turbine blades are relatively slender, which would tend to reduce thickness noise. Also the observer is downstream of the rotation plane, which is where loading noise is traditionally  thought to dominate (monopole/thickness noise is more significant in the rotor rotation plane, usually). (Although we didn't use the actual cross-sectional area for the blades, which directly affects the monopole/thickness noise.)","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"We now calculate the overall sound pressure level from the acoustic pressure time history. Next, we will calculate the narrowband spectrum. Finally, we will calculate the overall sound pressure level from the narrowband spectrum.","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"oaspl_from_apth = AcousticMetrics.OASPL(apth_total)\nnbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)\noaspl_from_nbs = AcousticMetrics.OASPL(nbs)\n@show oaspl_from_apth oaspl_from_nbs\nnothing # hide","category":"page"},{"location":"openfast_example/","page":"OpenFAST Example","title":"OpenFAST Example","text":"The OASPL values calculated from the acoustic pressure time history and the narrowband spectrum are the same, as they should be according to Parseval's theorem.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = AADocs","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [AcousticAnalogies]","category":"page"},{"location":"api/#AcousticAnalogies.AbstractAcousticObserver","page":"API Reference","title":"AcousticAnalogies.AbstractAcousticObserver","text":"Supertype for an object that recieves a noise prediction when combined with an acoustic analogy source; computational equivalent of a microphone.\n\n(obs::AbstractAcousticObserver)(t)\n\nCalculate the position of the acoustic observer at time t.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.CombinedNoTipBroadbandSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, Any}","page":"API Reference","title":"AcousticAnalogies.CombinedNoTipBroadbandSourceElement","text":"CombinedNoTipBroadbandSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, h, Psi, τ, Δτ, bl::AbstractBoundaryLayer, positive_x_rotation)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, and trailing edge bluntness-vortex shedding (TEBVS) noise using the BPM/Brooks and Burley method from CCBlade structs.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedNoTipBroadbandSourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{15, Any}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.CombinedNoTipBroadbandSourceElement","text":"CombinedNoTipBroadbandSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, U, α, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, and trailing edge bluntness-vortex shedding (TEBVS) noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedNoTipBroadbandSourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{16, Any}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.CombinedNoTipBroadbandSourceElement","text":"CombinedNoTipBroadbandSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, vn, vr, vc, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, and trailing edge bluntness-vortex shedding (TEBVS) noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedNoTipOutput","page":"API Reference","title":"AcousticAnalogies.CombinedNoTipOutput","text":"CombinedNoTipOutput(G_s, G_p, G_alpha, G_teb, cbands, dt, t)\n\nOutput of the combined broadband noise calculation not including tip vortex noise: the acoustic pressure autospectrum centered at time t over observer duration dt and observer frequencies cbands for the TBLTE suction side G_s, TBLTE pressure side G_p, TBLTE separation noise G_alpha, and trailing edge bluntness noise G_teb.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.CombinedWithTipBroadbandSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, AcousticAnalogies.AbstractBladeTip, Any}","page":"API Reference","title":"AcousticAnalogies.CombinedWithTipBroadbandSourceElement","text":"CombinedWithTipBroadbandSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, h, Psi, τ, Δτ, bl::AbstractBoundaryLayer, blade_tip::AbstractBladeTip, positive_x_rotation)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, trailing edge bluntness-vortex shedding (TEBVS), and tip vortex noise using the BPM/Brooks and Burley method from CCBlade structs.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedWithTipBroadbandSourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{16, Any}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.CombinedWithTipBroadbandSourceElement","text":"CombinedWithTipBroadbandSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, U, α, τ, Δτ, bl, blade_tip, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, trailing edge bluntness-vortex shedding (TEBVS), and tip vortex noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedWithTipBroadbandSourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{17, Any}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.CombinedWithTipBroadbandSourceElement","text":"CombinedWithTipBroadbandSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, vn, vr, vc, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE), laminar boundary layer-vortex shedding (LBLVS) noise, trailing edge bluntness-vortex shedding (TEBVS) noise, and tip vortex noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CombinedWithTipOutput","page":"API Reference","title":"AcousticAnalogies.CombinedWithTipOutput","text":"CombinedWithTipOutput(G_s, G_p, G_alpha, G_teb, G_tip, cbands, dt, t)\n\nOutput of the combined broadband noise calculation: the acoustic pressure autospectrum centered at time t over observer duration dt and observer frequencies cbands for the TBLTE suction side G_s, TBLTE pressure side G_p, TBLTE separation noise G_alpha, trailing edge bluntness noise G_teb, and tip vortex noise G_tip.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.CompactF1ASourceElement-NTuple{10, Any}","page":"API Reference","title":"AcousticAnalogies.CompactF1ASourceElement","text":"CompactF1ASourceElement(ρ0, c0, r, θ, Δr, Λ, fn, fr, fc, τ)\n\nConstruct a source element to be used with the compact form of Farassat's formulation 1A, using position and loading data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the fn, fr, and fc arguments are used to define the normal, radial, and circumferential loading per unit span on the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nρ0: Ambient air density (kg/m^3)\nc0: Ambient speed of sound (m/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nΛ: cross-sectional area of the element (m^2)\nfn: normal load per unit span on the fluid (N/m)\nfr: radial load on the fluid (N/m)\nfc: circumferential load on the fluid (N/m)\nτ: source time (s)\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CompactF1ASourceElement-NTuple{13, Any}","page":"API Reference","title":"AcousticAnalogies.CompactF1ASourceElement","text":"CompactF1ASourceElement(ρ0, c0, r, θ, Δr, Λ, fn, fndot, fr, frdot, fc, fcdot, τ)\n\nConstruct a source element to be used with the compact form of Farassat's formulation 1A, using position and loading data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the fn, fr, and fc arguments are used to define the normal, radial, and circumferential loading per unit span on the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The fndot, frdot, and fcdot arguments are the time-derivative of the normal, radial, and circumferential loading per unit span, again on the fluid and in a reference frame moving with the element, in the cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nρ0: Ambient air density (kg/m^3)\nc0: Ambient speed of sound (m/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nΛ: cross-sectional area of the element (m^2)\nfn: normal load per unit span on the fluid (N/m)\nfndot: time derivative of the normal load per unit span on the fluid (N/(m*s))\nfr: radial load on the fluid (N/m)\nfrdot: time derivative of the radial load on the fluid (N/(m*s))\nfc: circumferential load on the fluid (N/m)\nfcdot: time derivative of the circumferential load on the fluid (N/(m*s))\nτ: source time (s)\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.CompactF1ASourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Vararg{Any, 5}}","page":"API Reference","title":"AcousticAnalogies.CompactF1ASourceElement","text":"CompactF1ASourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, area_per_chord2, τ, positive_x_rotation=true)\n\nConstruct a source element to be used with the compact form of Farassat's formulation 1A from CCBlade objects.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.precone.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element.\narea_per_chord2: cross-sectional area divided by the chord squared of the element.\nτ: source time of the element.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.ConstVelocityAcousticObserver","page":"API Reference","title":"AcousticAnalogies.ConstVelocityAcousticObserver","text":"ConstVelocityAcousticObserver(t0, x0, v)\n\nConstruct an acoustic observer moving with a constant velocity v, located at x0 at time t0.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1AOutput","page":"API Reference","title":"AcousticAnalogies.F1AOutput","text":"Output of the F1A calculation: the acoustic pressure value at time t, broken into monopole component p_m and dipole component p_d.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1APressureTimeHistory","page":"API Reference","title":"AcousticAnalogies.F1APressureTimeHistory","text":"F1APressureTimeHistory(apth::AbstractArray{<:F1AOutput}, period::AbstractFloat, n::Integer, axis::Integer=1)\n\nConstruct an F1APressureTimeHistory struct suitable for containing an acoustic prediction from an array of F1AOutput struct.\n\nThe elapsed time and length of the returned F1APressureTimeHistory will be period and n, respectively. axis indicates which axis the apth structs time varies. (period, n, axis are passed to common_obs_time.)\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.F1APressureTimeHistory-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"API Reference","title":"AcousticAnalogies.F1APressureTimeHistory","text":"F1APressureTimeHistory([T=Float64,] n, dt, t0)\n\nConstruct an F1APressureTimeHistory struct suitable for containing an acoustic prediction of length n, starting at time t0 with time step dt.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.LBLVSSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, Any}","page":"API Reference","title":"AcousticAnalogies.LBLVSSourceElement","text":"LBLVSSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, τ, Δτ, bl::AbstractBoundaryLayer, positive_x_rotation)\n\nConstruct a source element to be used to predict laminary boundary layer-vortex shedding (LBLVS) noise.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.LBLVSSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{13, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.LBLVSSourceElement","text":"LBLVSSourceElement(c0, nu, r, θ, Δr, chord, ϕ, U, α, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting laminar boundary layer-vortex shedding (LBLVS) noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.LBLVSSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{14, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.LBLVSSourceElement","text":"LBLVSSourceElement(c0, nu, r, θ, Δr, chord, ϕ, vn, vr, vc, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting laminar boundary layer-vortex shedding (LBLVS) noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.OpenFASTData","page":"API Reference","title":"AcousticAnalogies.OpenFASTData","text":"Struct for holding data from an OpenFAST (AeroDyn?) output file.\n\nFields:\n\ntime: vector of simulation times with size (num_times,)\ndtime_dtau: vector of derivative of simulation times with respect to non-dimensional/computational time with size (num_times,)\nv: vector of freestream velocity time history with size (num_times,)\nazimuth: vector of azimuth angle time history with size (num_times,)\nomega: vector of rotation rate time history with size (num_times,)\npitch: array of pitch angle time history with size (num_times, num_blades)\nradii: vector of blade radial locations with size (num_radial,)\nradii_mid: vector of cell-centered/midpoint blade radial locations with size (num_radial-1,)\ncs_area: vector of cross-sectional areas with size (num_radial,).\ncs_area_mid: vector of cell-centered/midpoint cross-sectional areas with size (num_radial-1,).\naxial_loading: array of axial loading time history with size (num_times, num_radial, num_blades)\naxial_loading_mid: array of axial loading time history at cell-centered blade radial locations with size (num_times, num_radial-1, num_blades)\naxial_loading_mid_dot: array of axial loading temporal derivative time history at cell-centered blade radial locations with size (num_times, num_radial-1, num_blades)\ncircum_loading: array of circumferential loading time history with size (num_times, num_radial, num_blades)\ncircum_loading_mid: array of circum loading time history at cell-centered blade radial locations with size (num_times, num_radial-1, num_blades)\ncircum_loading_mid_dot: array of circum loading temporal derivative time history at cell-centered blade radial locations with size (num_times, num_radial-1, num_blades)\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.StationaryAcousticObserver","page":"API Reference","title":"AcousticAnalogies.StationaryAcousticObserver","text":"StationaryAcousticObserver(x)\n\nConstruct an acoustic observer that does not move with position x (m).\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.TBLTEOutput","page":"API Reference","title":"AcousticAnalogies.TBLTEOutput","text":"Output of the turbulent boundary layer-trailing edge (TBL-TE) calculation: the acoustic pressure autospectrum centered at time t over observer duration dt and observer frequencies cbands for the suction side G_s, pressure side G_p, and the separation G_alpha.\n\n\n\n\n\n","category":"type"},{"location":"api/#AcousticAnalogies.TBLTESourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, Any}","page":"API Reference","title":"AcousticAnalogies.TBLTESourceElement","text":"TBLTESourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, τ, Δτ, bl::AbstractBoundaryLayer, positive_x_rotation)\n\nConstruct a source element to be used to predict turbulent boundary layer-trailing edge (TBLTE) noise.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TBLTESourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{13, Any}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TBLTESourceElement","text":"TBLTESourceElement(c0, nu, r, θ, Δr, chord, ϕ, U, α, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE) noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TBLTESourceElement-Union{Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Bool}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TBLTESourceElement","text":"TBLTESourceElement(c0, nu, r, θ, Δr, chord, ϕ, vn, vr, vc, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE) noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TEBVSSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, Any}","page":"API Reference","title":"AcousticAnalogies.TEBVSSourceElement","text":"TEBVSSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, h, Psi, τ, Δτ, bl::AbstractBoundaryLayer, positive_x_rotation)\n\nConstruct a source element to be used to predict trailing edge bluntness-vortex shedding (TEBVS) noise.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TEBVSSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{15, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TEBVSSourceElement","text":"TEBVSSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, U, α, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting trailing edge bluntness-vortex shedding (TEBVS) noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TEBVSSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{16, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TEBVSSourceElement","text":"TEBVSSourceElement(c0, nu, r, θ, Δr, chord, ϕ, h, Psi, vn, vr, vc, τ, Δτ, bl, twist_about_positive_y)\n\nConstruct a source element for predicting trailing edge bluntness-vortex shedding (TEBVS) noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nnu: Kinematic viscosity (m^2/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nh: trailing edge thickness (m)\nPsi: solid angle between the blade surfaces immediately upstream of the trailing edge (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TipVortexSourceElement-Tuple{CCBlade.Rotor, CCBlade.Section, CCBlade.OperatingPoint, CCBlade.Outputs, Any, Any, Any, Any, AcousticAnalogies.AbstractBoundaryLayer, AcousticAnalogies.AbstractBladeTip, Any}","page":"API Reference","title":"AcousticAnalogies.TipVortexSourceElement","text":"TipVortexSourceElement(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, out::CCBlade.Outputs, θ, Δr, τ, Δτ, bl::AbstractBoundaryLayer, blade_tip::AbstractBladeTip, positive_x_rotation)\n\nConstruct a source element to be used to predict tip vortex noise.\n\nThe source element's position is calculated from section.r, rotor.precone, and the θ argument using\n\n    sθ, cθ = sincos(θ)\n    spc, cpc = sincos(precone)\n    y0dot = [r*spc, r*cpc*cθ, r*cpc*sθ]\n\nwhere y0dot is the position of the source element.\n\nArguments\n\nrotor::CCBlade.Rotor: CCBlade rotor object, needed for the precone angle.\nsection::CCBlade.Section: CCBlade section object, needed for the radial location and chord length of the element.\nop::CCBlade.OperatingPoint: CCBlade operating point, needed for atmospheric properties.\nout::CCBlade.Outputs: CCBlade outputs object, needed for the loading.\nθ: polar coordinate of the element, in radians.\nΔr: length of the element, in meters.\nτ: source time of the element, in seconds.\nΔτ: source time duration, in seconds.\nbl: AcousticAnalogies.AbstractBoundaryLayer, needed for boundary layer properties.\nblade_tip: AcousticAnalogies.AbstractBladeTip\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TipVortexSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{13, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TipVortexSourceElement","text":"TipVortexSourceElement(c0, r, θ, Δr, chord, ϕ, U, α, τ, Δτ, bl, blade_tip, twist_about_positive_y)\n\nConstruct a source element for predicting tip vortex noise using the BPM/Brooks and Burley method, using the velocity magnitude U and angle of attack α.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. The U and α arguments are the velocity magnitude normal to the source element length and the angle of attack, respectively. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nU: velocity magnitude (m/s)\nα: angle of attack (rad)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.TipVortexSourceElement-Union{Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}, NTuple{14, Any}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"AcousticAnalogies.TipVortexSourceElement","text":"TipVortexSourceElement(c0, r, θ, Δr, chord, ϕ, vn, vr, vc, τ, Δτ, bl, blade_tip, twist_about_positive_y)\n\nConstruct a source element for predicting turbulent boundary layer-trailing edge (TBLTE) noise using the BPM/Brooks and Burley method, using position and velocity data expressed in a cylindrical coordinate system.\n\nThe r and θ arguments are used to define the radial and circumferential position of the source element in a cylindrical coordinate system. Likewise, the vn, vr, and vc arguments are used to define the normal, radial, and circumferential velocity of the fluid (in a reference frame moving with the element) in the same cylindrical coordinate system. The cylindrical coordinate system is defined as follows:\n\nThe normal/axial direction is in the positive x axis\nThe circumferential/azimuth angle θ is defined such that θ = 0 means the radial direction is aligned with the positive y axis, and a positive θ indicates a right-handed rotation around the positive x axis.\n\nThe twist_about_positive_y is a Bool controling how the ϕ argument is handled, which in turn controls the orientation of a unit vector defining chord_uvec indicating the orientation of the chord line, from leading edge to trailing edge. If twist_about_positive_y is true, chord_uvec will initially be pointed in the negative-z direction, and then rotated around the positive y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the positive x axis.) If twist_about_positive_y is false, chord_uvec will initially be pointed in the positive-z direction, and then rotated around the negative y axis by an amount ϕ before being rotated by the azimuth angle θ. (This would typcially be appropriate for a source element rotating around the negative x axis.)\n\nNote that, for a proper noise prediction, the source element needs to be transformed into the \"global\" frame, aka, the reference frame of the fluid. This can be done easily with the transformations provided by the KinematicCoordinateTransformations package, or manually by modifying the components of the source element struct.\n\nArguments\n\nc0: Ambient speed of sound (m/s)\nr: radial coordinate of the element in the blade-fixed coordinate system (m)\nθ: angular offest of the element in the blade-fixed coordinate system (rad)\nΔr: length of the element (m)\nchord: chord length of blade element (m)\nϕ: twist of blade element (rad)\nvn: normal velocity of fluid (m/s)\nvr: radial velocity of fluid (m/s)\nvc: circumferential velocity of the fluid (m/s)\nτ: source time (s)\nΔτ: source time duration (s)\nbl: Boundary layer struct, i.e. an AbstractBoundaryLayer.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip.\ntwistaboutpositive_y: if true, apply twist ϕ about positive y axis, negative y axis otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Tuple{AcousticAnalogies.CompactF1ASourceElement}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::CompactF1ASourceElement)\n\nTransform the position and forces of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.CombinedNoTipBroadbandSourceElement{TDirect, TUInduction, TMachCorrection, TDoppler}}, Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::CombinedNoTipBroadbandSourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.CombinedWithTipBroadbandSourceElement{TDirect, TUInduction, TMachCorrection, TDoppler}}, Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::CombinedWithTipBroadbandSourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.LBLVSSourceElement{TDirect, TUInduction, TDoppler}}, Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::LBLVSSourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.TBLTESourceElement{TDirect, TUInduction, TMachCorrection, TDoppler}}, Tuple{TDoppler}, Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TMachCorrection, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::TBLTESourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.TEBVSSourceElement{TDirect, TUInduction, TDoppler}}, Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::TEBVSSourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#KinematicCoordinateTransformations.KinematicTransformation-Union{Tuple{AcousticAnalogies.TipVortexSourceElement{TDirect, TUInduction, TDoppler}}, Tuple{TDoppler}, Tuple{TUInduction}, Tuple{TDirect}} where {TDirect, TUInduction, TDoppler}","page":"API Reference","title":"KinematicCoordinateTransformations.KinematicTransformation","text":"(trans::KinematicTransformation)(se::TipVortexSourceElement)\n\nTransform the position and orientation of a source element according to the coordinate system transformation trans.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.adv_time-Tuple{AcousticAnalogies.AbstractCompactSourceElement, AcousticAnalogies.AbstractAcousticObserver}","page":"API Reference","title":"AcousticAnalogies.adv_time","text":"adv_time(se::AbstractCompactSourceElement, obs::AbstractAcousticObserver)\n\nCalculate the time an acoustic wave emmited by source se at time se.τ is recieved by observer obs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.combine","page":"API Reference","title":"AcousticAnalogies.combine","text":"combine(apth::AbstractArray{<:F1AOutput}, period::AbstractFloat, n::Integer, time_axis=1; f_interp=akima)\n\nCombine the acoustic pressures of multiple sources (apth) into a single acoustic pressure time history on a time grid of size n extending over time length period.\n\ntime_axis is an integer indicating the timeaxis of the apth array along which time varies. For example, if `timeaxis == 1andapthis a three-dimensional array, thenapth[:, i, j]would be theF1AOutputobjects of thei,jsource element for all time. But iftime_axis == 3, thenapth[i, j, :]would be theF1AOutputobjects of thei,j` source element for all time.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.combine!-Tuple{Any, Any, Any}","page":"API Reference","title":"AcousticAnalogies.combine!","text":"combine!(apth_out::F1APressureTimeHistory, apth::AbstractArray{<:F1AOutput}, time_axis; f_interp=akima)\n\nCombine the acoustic pressures of multiple sources (apth) into a single acoustic pressure time history apth_out.\n\nThe input acoustic pressures apth are interpolated onto the time grid returned by time(apth_out). The interpolation is performed by the function f_intep(xpt, ypt, x), where xpt and ytp are the input grid and function values, respectively, and x is the output grid. time_axis is an integer indicating the timeaxis of the apth array along which time varies. For example, if `timeaxis == 1andapthis a three-dimensional array, thenapth[:, i, j]would be theF1AOutputobjects of thei,jsource element for all time. But iftime_axis == 3, thenapth[i, j, :]would be theF1AOutputobjects of thei,j` source element for all time.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.combined_broadband_source_elements_ccblade-NTuple{11, Any}","page":"API Reference","title":"AcousticAnalogies.combined_broadband_source_elements_ccblade","text":"combined_broadband_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, hs::Vector{Float64}, Psis::Vector{Float64}, bls::Vector{AbstractBoundaryLayer}, blade_tip::AbstractBladeTip, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of broadband prediction source element objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs: Vector of CCBlade output objects.\nhs: Vector of trailing edge thicknesses (m)\nPsis: Vector of solid angles between the blade surfaces immediately upstream of the trailing edge (rad)\nbls::Vector of boundary layer AbstractBoundaryLayer structs.\nblade_tip: Blade tip struct, i.e. an AbstractBladeTip.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.common_obs_time","page":"API Reference","title":"AcousticAnalogies.common_obs_time","text":"common_obs_time(apth::AbstractArray{<:F1AOutput}, period, n, axis=1)\n\nReturn a suitable time range for the collection of F1A acoustic pressures in apth.\n\nThe time range will begin near the latest start time of the acoustic pressures in apth, and be an AbstractVector (really a StepRangeLen) of size n and of time length period. axis indicates which axis of apth the time for a source varies.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.doppler_factor-Tuple{AcousticAnalogies.AbstractBroadbandSourceElement, AcousticAnalogies.AbstractAcousticObserver}","page":"API Reference","title":"AcousticAnalogies.doppler_factor","text":"doppler_factor(se::AbstractBroadbandSourceElement, obs::AbstractAcousticObserver)\n\nCalculate the Doppler shift factor for noise emitted by source element se and recieved by observer obs, i.e. the ratio between an observer frequency f and emitted frequency f_0.\n\nThe correct value for t_obs will be found using adv_time internally.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.doppler_factor-Union{Tuple{TMachCorrection}, Tuple{TUInduction}, Tuple{TDirect}, Tuple{AcousticAnalogies.AbstractBroadbandSourceElement{TDirect, TUInduction, TMachCorrection, true}, AcousticAnalogies.AbstractAcousticObserver, Any}} where {TDirect, TUInduction, TMachCorrection}","page":"API Reference","title":"AcousticAnalogies.doppler_factor","text":"doppler_factor(se::AbstractBroadbandSourceElement, obs::AbstractAcousticObserver, t_obs)\n\nCalculate the Doppler shift factor for noise emitted by source element se and recieved by observer obs at time t_obs, i.e. the ratio between an observer frequency f and emitted frequency f_0.\n\nThe correct value for t_obs can be found using adv_time.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.endpoints-Tuple{AcousticAnalogies.AbstractCompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.endpoints","text":"endpoints(se::AbstractCompactSourceElement)\n\nReturn the Tuple containing the endpoint locations of the compact source element se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.f1a_source_elements_ccblade-NTuple{8, Any}","page":"API Reference","title":"AcousticAnalogies.f1a_source_elements_ccblade","text":"f1a_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, area_per_chord2::Vector{AbstractFloat}, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of CompactF1ASourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs::Vector of CCBlade output objects.\narea_per_chord2: cross-sectional area divided by the chord squared of the element at each CCBlade.section. Should be a Vector{AbstractFloat}, same length as sections, ops, outputs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.f1a_source_elements_openfast","page":"API Reference","title":"AcousticAnalogies.f1a_source_elements_openfast","text":"f1a_source_elements_openfast(data::OpenFASTData, rho0, c0, area_per_chord2::Vector, positive_x_rotation::Bool=true)\n\nConstruct and return an array of CompactF1ASourceElement objects from OpenFAST data.\n\nArguments\n\ndata: OpenFAST data object.\nrho0: Ambient air density (kg/m^3)\nc0: Ambient speed of sound (m/s)\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.get_ccblade_dradii-Tuple{Any, Any}","page":"API Reference","title":"AcousticAnalogies.get_ccblade_dradii","text":"get_ccblade_dradii(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section})\n\nConstruct and return a Vector of the lengths of each CCBlade section.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.get_dradii-Tuple{Any, Any, Any}","page":"API Reference","title":"AcousticAnalogies.get_dradii","text":"get_dradii(radii, Rhub, Rtip)\n\nCompute the spacing between blade elements given the radial locations of the element midpoints in radii and the hub and tip radius in Rhub and Rtip, respectively.\n\nAssume the interfaces between elements are midway between adjacent element's midpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.lblvs_source_elements_ccblade-NTuple{8, Any}","page":"API Reference","title":"AcousticAnalogies.lblvs_source_elements_ccblade","text":"lblvs_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, bls::Vector{AbstractBoundaryLayer}, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of LBLVSSourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs: Vector of CCBlade output objects.\nbls::Vector of boundary layer AbstractBoundaryLayer structs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.noise-Tuple{AcousticAnalogies.CompactF1ASourceElement, AcousticAnalogies.AbstractAcousticObserver, Any}","page":"API Reference","title":"AcousticAnalogies.noise","text":"noise(se::CompactF1ASourceElement, obs::AbstractAcousticObserver, t_obs)\n\nCalculate the acoustic pressure emitted by source element se and recieved by observer obs at time t_obs, returning an F1AOutput object.\n\nThe correct value for t_obs can be found using adv_time.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.noise-Tuple{AcousticAnalogies.CompactF1ASourceElement, AcousticAnalogies.AbstractAcousticObserver}","page":"API Reference","title":"AcousticAnalogies.noise","text":"noise(se::CompactF1ASourceElement, obs::AbstractAcousticObserver)\n\nCalculate the acoustic pressure emitted by source element se and recieved by observer obs, returning an F1AOutput object.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.orientation-Tuple{AcousticAnalogies.AbstractCompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.orientation","text":"orientation(se::AbstractCompactSourceElement)\n\nReturn a length-3 unit vector indicating the spanwise orientation of se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.position-Tuple{AcousticAnalogies.AbstractCompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.position","text":"position(se::AbstractCompactSourceElement)\n\nReturn a length-3 vector indicating the position of se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.read_openfast_file","page":"API Reference","title":"AcousticAnalogies.read_openfast_file","text":"read_openfast_file(fname, radii, cs_area=nothing;\n    header_keyword=\"Time\",\n    has_units_header=true,\n    time_column_name=\"Time\", \n    freestream_vel_column_name=\"Wind1VelX\",\n    azimuth_column_name=\"Azimuth\",\n    omega_column_name=\"RotSpeed\",\n    pitch_fmt=r\"BlPitch(?<blade>[[:digit:]]+)\",\n    axial_loading_fmt=r\"AB(?<blade>[[:digit:]]+)N(?<radial>[[:digit:]]+)Fxl\",\n    circum_loading_fmt=r\"AB(?<blade>[[:digit:]]+)N(?<radial>[[:digit:]]+)Fyl\",\n    radial_interp_method=FLOWLinearInterp,\n    time_deriv_method=SecondOrderFiniteDiff)\n\nRead an OpenFAST output file and return a OpenFASTData object.\n\nThe Azimuth and BlPitch columns are assumed to be in degrees and will be converted to radians. Likewise, the RotSpeed column is assumed to be in revolutions per minute and will be converted to radians per second.\n\nArguments\n\nfname: name of the OpenFAST output file to read\nradii: Vector of blade radial coordinates\ncs_area: Vector of radial distribution of cross-sectional areas, or nothing to ignore\nheader_keyword=\"Time\": string at the beginning of the header line (maybe always \"Time\"?)\nhas_units_header=true: if true, assume the file has a line directly after the header line with the units of each column\ntime_column_name=header_keyword: name of time column in file. Set to nothing to skip.\nfreestream_vel_column_name: name of the freestream velocity column in the file. Set to nothing to skip.\nazimuth_column_name: name of the azimuth column in the file. Set to nothing to skip.\nomega_column_name: name of the omega (rotation rate) Set to nothing to skip.\npitch_fmt: Format for finding all pitch columns in the file. Should be a regex with a capture group named blade for the blade index, or nothing to skip.\naxial_loading_fmt: Format for finding all axial loading columns in the file. Should be a regex with a captures groups named blade and radial for the blade and radial indices, or nothing to skip.\ncircum_loading_fmt: Format for finding all radial loading columns in the file. Should be a regex with a captures groups named blade and radial for the blade and radial indices, or nothing to skip.\nradial_interp_method: <:AbstractRadialInterpMethod indicating method used to interpolate loading from blade element \"interfaces\" to midpoints.\ntime_deriv_method: <:AbstractTimeDerivMethod indicating the method used to calculate the loading time derivatives.\naverage_freestream_vel=false: Store possibily unsteady freestream velocity in the OpenFASTData object if false, store average value otherwise.\naverage_omega=false: Store possibily unsteady omega (rotation rate) in the OpenFASTData object if false, store average value otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#AcousticAnalogies.source_time-Tuple{AcousticAnalogies.AbstractCompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.source_time","text":"source_time(se::AbstractCompactSourceElement)\n\nReturn the source time of se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.speed_of_sound-Tuple{Any}","page":"API Reference","title":"AcousticAnalogies.speed_of_sound","text":"speed_of_sound(se::AbstractCompactSourceElement)\n\nReturn the ambient speed of sound associated with se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.tblte_source_elements_ccblade-NTuple{8, Any}","page":"API Reference","title":"AcousticAnalogies.tblte_source_elements_ccblade","text":"tblte_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, bls::Vector{AbstractBoundaryLayer}, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of TBLTESourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs: Vector of CCBlade output objects.\nbls::Vector of boundary layer AbstractBoundaryLayer structs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.tebvs_source_elements_ccblade-NTuple{10, Any}","page":"API Reference","title":"AcousticAnalogies.tebvs_source_elements_ccblade","text":"tebvs_source_elements_ccblade(rotor::CCBlade.Rotor, sections::Vector{CCBlade.Section}, ops::Vector{CCBlade.OperatingPoint}, outputs::Vector{CCBlade.Outputs}, hs, Psis, bls::Vector{AbstractBoundaryLayer}, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of TEBVSSourceElement objects from CCBlade structs.\n\nArguments\n\nrotor: CCBlade rotor object.\nsections: Vector of CCBlade section object.\nops: Vector of CCBlade operating point.\noutputs: Vector of CCBlade output objects.\nhs: Vector of trailing edge thicknesses\nPsis: Vector of solid angles between the blade surfaces immediately upstream of the trailing edge (rad)\nbls::Vector of boundary layer AbstractBoundaryLayer structs.\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.tip_vortex_source_elements_ccblade-NTuple{10, Any}","page":"API Reference","title":"AcousticAnalogies.tip_vortex_source_elements_ccblade","text":"tip_vortex_source_elements_ccblade(rotor::CCBlade.Rotor, section::CCBlade.Section, op::CCBlade.OperatingPoint, output::CCBlade.Outputs, bl::AbstractBoundaryLayer, blade_tip::AbstractBladeTip, period, num_src_times, positive_x_rotation)\n\nConstruct and return an array of TipVortexSourceElement objects from CCBlade structs.\n\nNote that unlike the other *_source_elements_ccblade functions, tip_vortex_source_elements_ccblade expects scalar arguments instead of vectors for section, op, etc. as a blade only has one tip.\n\nArguments\n\nrotor: CCBlade rotor object.\nsection: CCBlade section object at the blade tip.\nop: CCBlade operating point object at the blade tip.\noutput: CCBlade output object at the blade tip.\nΔr: radial spacing.\nbl:: Boundary layer struct at the blade tip.\nblade_tip: AcousticAnalogies.AbstractBladeTip\nperiod: length of the source time over which the returned source elements will evaluated.\nnum_src_times: number of source times.\npositive_x_rotation: rotate blade around the positive-x axis if true, negative-x axis otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.to_paraview_collection-Tuple{Any, AbstractArray{<:AcousticAnalogies.AbstractCompactSourceElement}}","page":"API Reference","title":"AcousticAnalogies.to_paraview_collection","text":"to_paraview_collection(name::AbstractString, ses::AbstractArray{<:AbstractCompactSourceElement}; time_axis::Integer=1)\n\nConstruct and write out a ParaView collection data file (.pvd) object for an array of AbstractCompactSourceElements with name name.pvd (i.e., the name argument should not contain a file extension).\n\ntime_axis indicates the timeaxis of ses over which the source time for the source elements in ses vary. One VTK PolyData (.vtp) file will be written for each valid index along `timeaxis`.\n\nReturns a list of filenames written out by WriteVTK.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.to_vtp-Tuple{Any, AbstractArray{<:AcousticAnalogies.AbstractCompactSourceElement}}","page":"API Reference","title":"AcousticAnalogies.to_vtp","text":"to_vtp(name::AbstractString, ses::AbstractArray{<:AbstractCompactSourceElement})\n\nConstruct and return a VTK polygonal (.vtp) data file object for an array of AbstractCompactSourceElement with name name.vtp (i.e., the name argument should not contain a file extension).\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.velocity-Tuple{AcousticAnalogies.AbstractCompactSourceElement}","page":"API Reference","title":"AcousticAnalogies.velocity","text":"velocity(se::AbstractCompactSourceElement)\n\nReturn the current velocity of se.\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.velocity-Tuple{Any, AcousticAnalogies.ConstVelocityAcousticObserver}","page":"API Reference","title":"AcousticAnalogies.velocity","text":"velocity(t_obs, obs::ConstVelocityAcousticObserver)\n\nReturn the velocity of obs at time t_obs (hint—will always be the same)\n\n\n\n\n\n","category":"method"},{"location":"api/#AcousticAnalogies.velocity-Tuple{Any, AcousticAnalogies.StationaryAcousticObserver}","page":"API Reference","title":"AcousticAnalogies.velocity","text":"velocity(t_obs, obs::StationaryAcousticObserver)\n\nReturn the velocity of obs at time t_obs (hint—will always be zero ☺)\n\n\n\n\n\n","category":"method"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"CurrentModule = AADocs","category":"page"},{"location":"guided_example/#guided_example","page":"Guided Example","title":"Compact Formulation 1A Guided Example","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"There are four steps to predicting propeller/rotor noise with AcousticAnalogies.jl.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Define the blade's motion and loading as a function of source time\nPerform the advanced time calculation\nPropagate the acoustics caused by each blade section to the acoustic observer(s) using the F1A formulation\nCombine all the acoustic pressures resulting from step 3 into one acoustic pressure time history","category":"page"},{"location":"guided_example/#1.-Define-the-Blade","page":"Guided Example","title":"1. Define the Blade","text":"","category":"section"},{"location":"guided_example/#The-Blade-Fixed-Reference-Frame","page":"Guided Example","title":"The Blade-Fixed Reference Frame","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We need to know what the blade is doing aerodynamically before we can predict how loud it is.  Specifically, we need to know at each radial station along each blade the","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"position\nvelocity\nacceleration\njerk (time derivative of acceleration)\ncross-sectional area\nloading per unit span","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"all as a function of time. We'll do this first in a reference frame moving with the blades, i.e., translating and rotating with the blade geometry, that we'll call the blade-fixed reference frame.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"First step is to load up AcousticAnalogies.jl:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticAnalogies","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So, for this example we'll imagine that we have a blade with radial stations that look like this:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"num_blades = 2  # number of blades\nRhub = 0.10  # meters\nRtip = 1.1684  # meters\nradii = [\n    0.92904E-01, 0.11751, 0.15631, 0.20097,\n    0.24792    , 0.29563, 0.34336, 0.39068,\n    0.43727    , 0.48291, 0.52741, 0.57060,\n    0.61234    , 0.65249, 0.69092, 0.72752,\n    0.76218    , 0.79479, 0.82527, 0.85352,\n    0.87947    , 0.90303, 0.92415, 0.94275,\n    0.95880    , 0.97224, 0.98304, 0.99117,\n    0.99660    , 0.99932].*Rtip\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"radii is a Vector of the distance of each blade element's center from the propeller hub, in meters.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Each of the num_blades blades have the same radial coordinates in the blade-fixed frame, but different angular coordinates: blade number 2 will be offset 180° from blade number 1.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"θs = 2*pi/num_blades.*(0:(num_blades-1))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So now we know where each blade element is in the blade-fixed frame: in polar coordinates, element at radial index j and blade k is at radii[j], θs[k].","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We'll also need the length of each blade element. There is a convenience function in AcousticAnalogies.jl called get_dradii that calculates each blade element's length from the element centers and the hub and tip location:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"dradii = get_dradii(radii, Rhub, Rtip)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The compact F1A calculation also requires the cross-sectional area of each element. In many types of propeller codes, the cross-sectional shape at each radial station is defined as having a certain standard shape (e.g., circular near the hub, a given airfoil shape elsewhere).  If we know the cross-sectional area for each relevant airfoil shape with a chord length of one, we can find the cross-sectional area for any chord length by multiplying by the squared chord length. In this example we'll assume the blade uses the same airfoil shape at each radial station, and that this airfoil has a cross-sectional area per unit chord squared of 0.064. After defining the chord length for each radial station, we find the cross-sectional area in units of meters squared:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"cs_area_over_chord_squared = 0.064\nchord = [\n    0.35044     , 0.28260     , 0.22105     , 0.17787     , 0.14760,\n    0.12567     , 0.10927     , 0.96661E-01 , 0.86742E-01 ,\n    0.78783E-01 , 0.72287E-01 , 0.66906E-01 , 0.62387E-01 ,\n    0.58541E-01 , 0.55217E-01 , 0.52290E-01 , 0.49645E-01 ,\n    0.47176E-01 , 0.44772E-01 , 0.42326E-01 , 0.39732E-01 ,\n    0.36898E-01 , 0.33752E-01 , 0.30255E-01 , 0.26401E-01 ,\n    0.22217E-01 , 0.17765E-01 , 0.13147E-01 , 0.85683E-02 ,\n    0.47397E-02].*Rtip\ncs_area = cs_area_over_chord_squared.*chord.^2\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Next, we need the loading on the blade. AcousticAnalogies.jl needs us to specify the loading at each radial station as a 3D vector in units of loading per unit span. But for now, let's imagine that we've run some type of propeller aerodynamic code (I used CCBlade.jl, FYI) and have the normal and circumferential loading as a function of radial position along the blade. The loading is in units of force per unit span (here, Newtons/meter).","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"fn = [32.87810395677037, 99.05130471878633, 190.1751697055377,\n      275.9492967565419, 358.14423433748146, 439.64679797145624,\n      520.1002808148281, 599.1445046901513, 676.2358818769462,\n      751.3409657831587, 824.2087672338118, 894.4465814696498,\n      961.9015451678036, 1026.0112737521583, 1086.2610633094212,\n      1141.4900032393818, 1190.3376703335655, 1230.8999662260915,\n      1260.375390697363, 1275.354422403355, 1271.8827617273287,\n      1245.9059108698596, 1193.9967137923225, 1113.9397490286995,\n      1005.273267675585, 869.4101036003673, 709.8100230053759,\n      532.1946243370355, 346.53986082379265, 180.66763939805125]\n\nfc = [26.09881302938423, 55.5216259955307, 75.84767780212506, 84.84509232798283,\n      89.73045068624886, 93.02999477395113, 95.4384273852926, 97.31647535460424,\n      98.81063179767507, 100.07617771995163, 101.17251941705561, 102.11543878532882,\n      102.94453631586998, 103.63835661864168, 104.18877957193807, 104.51732850056433,\n      104.54735678589765, 104.1688287897138, 103.20319203286938, 101.46246817378582,\n      99.11692436681635, 96.49009546562475, 93.45834266417528, 89.49783586366624,\n      83.87176811707455, 75.83190739325453, 64.88004605331857, 50.98243352318318,\n      34.85525518071079, 19.358679206883078]\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We also need to decide on some atmospheric properties, specifically the ambient air density and speed of sound.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"rho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"And we need to decide on some operating point parameters. Let's assume that the blade is moving forward at 5.0 m/s and rotating at 2200 rev/min.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"v = 0.0  # m/s\nomega = 2200 * 2*pi/60  # rad/s\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We also need to decide over what time period we're going to calculate the blades' acoustics. Let's do one rotation of the blade:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"period = 2*pi/omega\nnum_src_times = 64\ndt = 2*period/(num_src_times-1)\nsrc_times = (0:num_src_times-1).*dt\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So at this point we have all the information needed to define the source elements in a frame of reference that's moving with the blade, i.e., rotating at a rate of omega and moving forward at a speed of v defined above. Let's do that. We want one source element for each radial station along the blade at each src_time and each of the num_blades blades. Sounds kind of complicated, but luckily Julia's broadcasting makes this easy. What we'd like is an array ses of CompactF1ASourceElement types that has size (num_src_times, num_radial, num_blades), where ses[i, j, k] holds the CompactF1ASourceElement at src_time[i], radii[j], and blade number k. So let's reshape the input arrays to make that happen.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"θs = reshape(θs, 1, 1, :)\nradii = reshape(radii, 1, :, 1)\ndradii = reshape(dradii, 1, :, 1)\ncs_area = reshape(cs_area, 1, :, 1)\nfn = reshape(fn, 1, :, 1)\nfc = reshape(fc, 1, :, 1)\nsrc_times = reshape(src_times, :, 1, 1)  # This isn't really necessary.\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, the last thing we need to think about is the coordinate system we're defining these quantities in. Again, right now we are in the blade-fixed frame, which means the coordinate system is rotating with the blades at a rate of omega and translating with a velocity v in the positive x direction. The CompactF1ASourceElement constructor we'll use allows us to specify each source element's location in terms of r and θ, where r is the distance from the origin and θ is the polar angle from the positive y axis, rotating toward the positive z axis. So the radii and θs arrays are set up correctly. ","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, one of the tricky aspects of using an acoustic analogy is getting the direction of the loading on the integration surface (or line in the case of a compact formulation) right. An acoustic analogy requires the loading on the fluid, not on the solid body. One might expect that we just need to switch the sign on the fn and fc arrays above. That's true for the fn array, which represents the loading in the axial direction: if we imagine our propeller is moving in the positive x direction, the propeller would be pushing on the fluid in the negative x direction in normal operation. But what about the circumferential loading? In the blade-fixed frame, we assume the propeller is rotating about the x axis in a positive (i.e., right-handed) sense. So, if we imagine the situation for θ=0, the blade will be initially along the positive y axis, rotating toward the positive z axis. What direction will the circumferential loading on the fluid be? It will be positive, pointing in the same direction as the positive z axis. So we don't need to switch the sign on the fc array.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So let's create all the source elements:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = CompactF1ASourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times)\nsize(ses)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The size of the source element array ended up like we wanted: (num_src_times, num_radial, num_blades).","category":"page"},{"location":"guided_example/#The-Global-Reference-Frame","page":"Guided Example","title":"The Global Reference Frame","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"At this point we have an array of CompactF1ASourceElement that describes the what each blade element \"source\" is doing from the perspective of the blade-fixed reference frame. But in order to perform the F1A calculation, we need to move the sources from the blade-fixed frame to the global reference frame, i.e., the one for which the fluid medium (air) appears to be stationary. This involves just setting the position and loading components of each CompactF1ASourceElement to the correct values (y0dot through y3dot and f0dot and f1dot). This could be done manually, but it's easier to use the KinematicCoordinateTransformations.jl package.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The first transformation we need to perform is a steady rotation around the x axis. So we create a SteadyRotXTransformation:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using KinematicCoordinateTransformations\nt0 = 0.0  # Time at which the angle between the source and target coordinate systems is equal to offest.\noffset = 0.0  # Angular offset between the source and target cooridante systems at t0.\nrot_trans = SteadyRotXTransformation(t0, omega, offset)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Next, we need to orient the rotation axis of the blades as it is the global frame. For example, let's say that it's pointed in the global positive z-axis direction, and the first blade is pointed in the positive y-axis direction. Then we can perform this transformation using the ConstantLinearMap transformation:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using LinearAlgebra: ×\nusing StaticArrays\nrot_axis = @SVector [0.0, 0.0, 1.0]\nblade_axis = @SVector [0.0, 1.0, 0.0]\nglobal_trans = ConstantLinearMap(hcat(rot_axis, blade_axis, rot_axis×blade_axis))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Finally, we need the blade to move with the appropriate forward velocity, and start from the desired location in the global reference frame:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"y0_hub = @SVector [0.0, 0.0, 0.0]  # Position of the hub at time t0\nv0_hub = SVector{3}(v.*rot_axis)   # Constant velocity of the hub in the global reference frame\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now we could apply each of these transformations to the SourceElement array. But it's more efficient to combine these three transformations into one, and then use that on the SourceElements using compose.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"trans = compose.(src_times, Ref(const_vel_trans), compose.(src_times, Ref(global_trans), Ref(rot_trans)))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now trans will perform the three transformations from right to left (rot_trans, global_trans, const_vel_trans). Now we use it on ses:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = ses .|> trans\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"So now the ses has been transformed from the blade-fixed reference frame to the global reference frame. We could have created the source elements and transformed them all in one line, too, which is pretty slick:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"ses = AcousticAnalogies.CompactF1ASourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times) .|> trans\nnothing # hide","category":"page"},{"location":"guided_example/#2.-Perform-the-Advanced-Time-Calculation","page":"Guided Example","title":"2. Perform the Advanced Time Calculation","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The ses object now describes how each blade element source is moving through the global reference frame over the time src_time. As it does this, it will emit acoustics that can be sensed by an acoustic observer (a human, or a microphone). The exact \"amount\" of acoustics the observer will experience depends on the relative location and motion between each source and the observer. So we'll need to define our acoustic observer before we can calculate the noise heard by it. For this example, we'll assume that our acoustic observer is stationary in the global frame.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"x0 = @SVector [100*12*0.0254, 0.0, 0.0]  # 100 ft in meters\nobs = StationaryAcousticObserver(x0)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"Now, in order to perform the F1A calculation, we need to know when each acoustic disturbance emitted by the source arrives at the observer. This is referred to an  advanced time calculation, and is done this way:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"obs_time = adv_time.(ses, Ref(obs))\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"That returns an array the same size of ses of the time each acoustic disturbance reaches the observer obs:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"@show size(obs_time)\nnothing # hide","category":"page"},{"location":"guided_example/#3.-Perform-the-F1A-Calculation","page":"Guided Example","title":"3. Perform the F1A Calculation","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We're finally ready to do the compact F1A calculation!","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"apth = noise.(ses, Ref(obs), obs_time)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"When called this way (notice the . after noise), the noise routine returns an array of F1AOutput structs, the same size as ses and obs_time. Each F1AOutput struct has three components: the observer time t, the thickness/monopole part of the acoustic pressure p_m, and the loading/dipole part of the acoustic pressure p_d.","category":"page"},{"location":"guided_example/#4.-Combine-the-Acoustic-Pressures","page":"Guided Example","title":"4. Combine the Acoustic Pressures","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We now have a noise prediction for each of the individual source elements in ses at the acoustic observer obs. What we ultimately want is the total noise prediction at obs—we want to add all the acoustic pressures in apth together. But we can't add them directly, yet, since the observer times are not all the same. What we need to do is first interpolate the apth of each source onto a common observer time grid, and then add them up. We'll do this using the AcousticAnalogies.combine function.","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"bpp = period/num_blades  # blade passing period\nobs_time_range = 2*bpp\nnum_obs_times = 128\napth_total = combine(apth, obs_time_range, num_obs_times, 1)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"combine returns a single F1AAcousticPressure struct made up of Vectors—it is an \"struct of arrays\" and not an \"array of structs\" like apth:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"@show typeof(apth) typeof(apth_total)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We can now have a look at the total acoustic pressure time history at the observer:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticMetrics\nusing GLMakie\nfig = Figure()\nax1 = fig[1, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"monopole, Pa\")\nax2 = fig[2, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"dipole, Pa\")\nax3 = fig[3, 1] = Axis(fig, xlabel=\"time, blade passes\", ylabel=\"total, Pa\")\nt_nondim = (AcousticMetrics.time(apth_total) .- AcousticMetrics.starttime(apth_total))./bpp\nl1 = lines!(ax1, t_nondim, apth_total.p_m)\nl2 = lines!(ax2, t_nondim, apth_total.p_d)\nl3 = lines!(ax3, t_nondim, apth_total.p_m.+apth_total.p_d)\nhidexdecorations!(ax1, grid=false)\nhidexdecorations!(ax2, grid=false)\nsave(\"first_example-apth_total.png\", fig)\nnothing # hide","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"(Image: )","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"We can now post-process the total acoustic pressure time history in apth_total in any way we'd like.","category":"page"},{"location":"guided_example/#AcousticMetrics.jl-Support","page":"Guided Example","title":"AcousticMetrics.jl Support","text":"","category":"section"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The combine function returns a F1AAcousticPressure struct, which subtypes the AbstractAcousticPressure type from the AcousticMetrics.jl package. Because of this, any of the acoustic metric functions defined in AcousticMetrics.jl relevant to AbstractAcousticPressure objects can be used with the F1AAcousticPressure returned by combine:","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"using AcousticMetrics\n# Calculate the overall sound pressure level from the acoustic pressure time history.\noaspl_from_apth = AcousticMetrics.OASPL(apth_total)\n# Calculate the narrowband spectrum of mean-squared pressure.\nnbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)\n# Calculate the OASPL from the NBS.\noaspl_from_nbs = AcousticMetrics.OASPL(nbs)\n(oaspl_from_apth, oaspl_from_nbs)","category":"page"},{"location":"guided_example/","page":"Guided Example","title":"Guided Example","text":"The two approaches to calculate the OASPL give essentially the same result.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"CurrentModule = AADocs","category":"page"},{"location":"writevtk_support/#WriteVTK.jl-Support","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"","category":"section"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"\"\"\"\n    XROTORAirfoilConfig(A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\n\n`struct` that holds all the required parameters for XROTOR's approach to handling airfoil lift and drag polars.\n\n# Arguments\n- `A0`: zero lift angle of attack, radians.\n- `DCLDA`: lift curve slope, 1/radians.\n- `CLMAX`: stall Cl.\n- `CLMIN`: negative stall Cl.\n- `DCL_STALL`: CL increment from incipient to total stall.\n- `DCLDA_STALL`: stalled lift curve slope, 1/radian.\n- `CDMIN`: minimum Cd.\n- `CLDMIN`: Cl at minimum Cd.\n- `DCDCL2`: d(Cd)/d(Cl**2).\n- `REREF`: Reynolds Number at which Cd values apply.\n- `REXP`: Exponent for Re scaling of Cd:  Cd ~ Re**exponent\n- `MCRIT`: Critical Mach number.\n\"\"\"\nstruct XROTORAirfoilConfig{TF}\n    A0::TF # = 0.           # zero lift angle of attack   radians\n    DCLDA::TF # =  6.28     # lift curve slope            /radian\n    CLMAX::TF # =   1.5     # stall Cl\n    CLMIN::TF # =  -0.5     # negative stall Cl\n    DCL_STALL::TF # =   0.1 # CL increment from incipient to total stall\n    DCLDA_STALL::TF # = 0.1 # stalled lift curve slope    /radian\n    CDMIN::TF # =  0.013    # minimum Cd\n    CLDMIN::TF # =  0.5     # Cl at minimum Cd\n    DCDCL2::TF # =  0.004   # d(Cd)/d(Cl**2)\n    REREF::TF # =  200000.  # Reynolds Number at which Cd values apply\n    REXP::TF # =  -0.4      # Exponent for Re scaling of Cd:  Cd ~ Re**exponent\n    MCRIT::TF # =  0.8      # Critical Mach number\nend\n\n\nfunction XROTORAirfoilConfig(; A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\n    return XROTORAirfoilConfig(A0, DCLDA, CLMAX, CLMIN, DCL_STALL, DCLDA_STALL, CDMIN, CLDMIN, DCDCL2, REREF, REXP, MCRIT)\nend\n\n\"\"\"\n    af_xrotor(alpha, Re, Mach, config::XROTORAirfoilConfig)\n\nReturn a tuple of the lift and drag coefficients for a given angle of attach\n`alpha` (in radians), Reynolds number `Re`, and Mach number `Mach`.\n\"\"\"\nfunction af_xrotor(alpha, Re, Mach, config::XROTORAirfoilConfig)\n# C------------------------------------------------------------\n# C     CL(alpha) function\n# C     Note that in addition to setting CLIFT and its derivatives\n# C     CLMAX and CLMIN (+ and - stall CL's) are set in this routine\n# C     In the compressible range the stall CL is reduced by a factor\n# C     proportional to Mcrit-Mach.  Stall limiting for compressible \n# C     cases begins when the compressible drag added CDC > CDMstall\n# C------------------------------------------------------------\n# C     CD(alpha) function - presently CD is assumed to be a sum\n# C     of profile drag + stall drag + compressibility drag\n# C     In the linear lift range drag is CD0 + quadratic function of CL-CLDMIN\n# C     In + or - stall an additional drag is added that is proportional\n# C     to the extent of lift reduction from the linear lift value.\n# C     Compressible drag is based on adding drag proportional to \n# C     (Mach-Mcrit_eff)^MEXP\n# C------------------------------------------------------------\n# C     CM(alpha) function - presently CM is assumed constant,\n# C     varying only with Mach by Prandtl-Glauert scaling\n# C------------------------------------------------------------\n# C\n      # INCLUDE 'XROTOR.INC'\n      # LOGICAL STALLF\n      # DOUBLE PRECISION ECMIN, ECMAX\n# C\n# C---- Factors for compressibility drag model, HHY 10/23/00\n# C     Mcrit is set by user\n# C     Effective Mcrit is Mcrit_eff = Mcrit - CLMFACTOR*(CL-CLDmin) - DMDD\n# C     DMDD is the delta Mach to get CD=CDMDD (usually 0.0020)\n# C     Compressible drag is CDC = CDMFACTOR*(Mach-Mcrit_eff)^MEXP\n# C     CDMstall is the drag at which compressible stall begins\n#\n      A0 = config.A0\n      DCLDA = config.DCLDA\n      CLMAX = config.CLMAX\n      CLMIN = config.CLMIN\n      DCL_STALL = config.DCL_STALL\n      DCLDA_STALL = config.DCLDA_STALL\n      CDMIN = config.CDMIN\n      CLDMIN = config.CLDMIN\n      DCDCL2 = config.DCDCL2\n      REREF = config.REREF\n      REXP = config.REXP\n      MCRIT = config.MCRIT\n      \n      CDMFACTOR = 10.0\n      CLMFACTOR =  0.25\n      MEXP      =  3.0\n      CDMDD     =  0.0020\n      CDMSTALL  =  0.1000\n# C\n# C---- Prandtl-Glauert compressibility factor\n      # MSQ   =   W*W*VEL^2/VSO^2\n      # MSQ_W = 2.0*W*VEL^2/VSO^2\n      # if (MSQ>1.0)\n      #  # WRITE(*,*)\n     # # &  'CLFUNC: Local Mach number limited to 0.99, was ', MSQ\n      #  MSQ = 0.99\n      #  # MSQ_W = 0.\n      # end\n      MSQ = Mach*Mach\n      if MSQ > 1.0\n          MSQ = 0.99\n          Mach = sqrt(MSQ)\n      end\n      PG = 1.0 / sqrt(1.0 - MSQ)\n      # PG_W = 0.5*MSQ_W * PG^3\n# C\n# C---- Mach number and dependence on velocity\n      # Mach = sqrt(MSQ)\n      # MACH_W = 0.0\n      # IF(Mach.NE.0.0) MACH_W = 0.5*MSQ_W/Mach \n      # if ! (mach ≈ 0.0)\n      #     MACH_W =  0.5*MSQ_W/Mach\n      # end\n# C\n# C\n# C------------------------------------------------------------\n# C--- Generate CL from dCL/dAlpha and Prandtl-Glauert scaling\n      CLA     = DCLDA*PG  *(alpha-A0)\n      # CLA_ALF = DCLDA*PG\n      # CLA_W   = DCLDA*PG_W*(ALF-A0)\n# C\n# C--- Effective CLmax is limited by Mach effects\n# C    reduces CLmax to match the CL of onset of serious compressible drag\n      CLMX = CLMAX\n      CLMN = CLMIN\n      DMSTALL  = (CDMSTALL/CDMFACTOR)^(1.0/MEXP)\n      CLMAXM = max(0.0, (MCRIT+DMSTALL-Mach)/CLMFACTOR) + CLDMIN\n      CLMAX  = min(CLMAX,CLMAXM)\n      CLMINM = min(0.0,-(MCRIT+DMSTALL-Mach)/CLMFACTOR) + CLDMIN\n      CLMIN  = max(CLMIN,CLMINM)\n# C\n# C--- CL limiter function (turns on after +-stall \n      ECMAX = exp( min(200.0, (CLA-CLMAX)/DCL_STALL) )\n      ECMIN = exp( min(200.0, (CLMIN-CLA)/DCL_STALL) )\n      CLLIM = DCL_STALL * log( (1.0+ECMAX)/(1.0+ECMIN) )\n      CLLIM_CLA = ECMAX/(1.0+ECMAX) + ECMIN/(1.0+ECMIN)\n# c\n# c      if(CLLIM.GT.0.001) then\n# c      write(*,999) 'cla,cllim,ecmax,ecmin ',cla,cllim,ecmax,ecmin\n# c      endif\n# c 999  format(a,2(1x,f10.6),3(1x,d12.6))\n# C\n# C--- Subtract off a (nearly unity) fraction of the limited CL function\n# C    This sets the dCL/dAlpha in the stalled regions to 1-FSTALL of that\n# C    in the linear lift range\n      FSTALL = DCLDA_STALL/DCLDA\n      CLIFT  = CLA     - (1.0-FSTALL)*CLLIM\n\n      # CL_ALF = CLA_ALF - (1.0-FSTALL)*CLLIM_CLA*CLA_ALF\n      # CL_W   = CLA_W   - (1.0-FSTALL)*CLLIM_CLA*CLA_W\n# C\n      # STALLF = false\n      # IF(CLIFT.GT.CLMAX) STALLF = .TRUE.\n      # IF(CLIFT.LT.CLMIN) STALLF = .TRUE.\n      # STALLF = (CLIFT > CLMAX) || (CLIFT < CLMIN)\n\n# C\n# C\n# C------------------------------------------------------------\n# C--- CM from CMCON and Prandtl-Glauert scaling\n      # CMOM  = PG*CMCON\n      # CM_AL = 0.0\n      # CM_W  = PG_W*CMCON\n# C\n# C\n# C------------------------------------------------------------\n# C--- CD from profile drag, stall drag and compressibility drag \n# C\n# C---- Reynolds number scaling factor\n      if (Re < 0.0)\n        RCORR = 1.0\n        # RCORR_REY = 0.0\n      else\n        RCORR     = (Re/REREF)^REXP\n        # RCORR_REY =  REXP/Re\n      end\n# C\n# C--- In the basic linear lift range drag is a function of lift\n# C    CD = CD0 (constant) + quadratic with CL)\n      CDRAG  = (CDMIN + DCDCL2*(CLIFT-CLDMIN)^2    ) * RCORR\n      # CD_ALF = (    2.0*DCDCL2*(CLIFT-CLDMIN)*CL_ALF) * RCORR\n      # CD_W   = (    2.0*DCDCL2*(CLIFT-CLDMIN)*CL_W  ) * RCORR\n      # CD_REY = CDRAG*RCORR_REY\n# C\n# C--- Post-stall drag added\n      FSTALL = DCLDA_STALL/DCLDA\n      DCDX    = (1.0-FSTALL)*CLLIM/(PG*DCLDA)\n# c      write(*,*) 'cla,cllim,fstall,pg,dclda ',cla,cllim,fstall,pg,dclda\n      DCD     = 2.0* DCDX^2\n      # DCD_ALF = 4.0* DCDX * (1.0-FSTALL)*CLLIM_CLA*CLA_ALF/(PG*DCLDA)\n      # DCD_W = 4.0* DCDX * ( (1.0-FSTALL)*CLLIM_CLA*CLA_W/(PG*DCLDA) - DCD/PG*PG_W )\n# c      write(*,*) 'alf,cl,dcd,dcd_alf,dcd_w ',alf,clift,dcd,dcd_alf,dcd_w\n# C\n# C--- Compressibility drag (accounts for drag rise above Mcrit with CL effects\n# C    CDC is a function of a scaling factor*(M-Mcrit(CL))^MEXP\n# C    DMDD is the Mach difference corresponding to CD rise of CDMDD at MCRIT\n      DMDD = (CDMDD/CDMFACTOR)^(1.0/MEXP)\n      CRITMACH = MCRIT-CLMFACTOR*abs(CLIFT-CLDMIN) - DMDD\n      # CRITMACH_ALF  = -CLMFACTOR*ABS(CL_ALF)\n      # CRITMACH_W    = -CLMFACTOR*ABS(CL_W)\n      if (Mach < CRITMACH)\n        CDC     = 0.0\n        # CDC_ALF = 0.0\n        # CDC_W   = 0.0\n      else\n        CDC = CDMFACTOR*(Mach-CRITMACH)^MEXP\n        # CDC_W   = MEXP*MACH_W*CDC/Mach - MEXP*CRITMACH_W  *CDC/CRITMACH\n        # CDC_ALF =                      - MEXP*CRITMACH_ALF*CDC/CRITMACH\n      end\n# c      write(*,*) 'critmach,mach ',critmach,mach\n# c      write(*,*) 'cdc,cdc_w,cdc_alf ',cdc,cdc_w,cdc_alf\n# C\n      FAC   = 1.0\n      # FAC_W = 0.0\n# C--- Although test data does not show profile drag increases due to Mach # \n# C    you could use something like this to add increase drag by Prandtl-Glauert\n# C    (or any function you choose) \n# cc      FAC   = PG\n# cc      FAC_W = PG_W\n# C--- Total drag terms\n      CDRAG  = FAC*CDRAG              + DCD     + CDC\n      # CD_ALF = FAC*CD_ALF             + DCD_ALF + CDC_ALF\n      # CD_W   = FAC*CD_W + FAC_W*CDRAG + DCD_W   + CDC_W\n      # CD_REY = FAC*CD_REY\n# C\n      return CLIFT, CDRAG\nend","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"AcousticAnalogies.jl can write out CompactF1ASourceElement structs to VTK files, allowing us to easily visualize the state and motion of the acoustic sources in popular visualization tools (e.g. ParaView). This is very useful for checking that the motion, loading, coordinate system, etc. is what we expect.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"To write out VTK files, we just need to pass an array of source elements to the AcousticAnalogies.to_paraview_collection function. We'll use CCBlade.jl to calculate the aerodynamic loads, and the CCBlade.jl helper routines that AcousticAnalogies.jl provides to create the source elements from the CCBlade.jl data.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"using AcousticAnalogies\nusing CCBlade\n\n# Define the blade geometry.\nB = 2\nRhub = 0.10\nRtip = 1.1684  # meters\nradii = Rhub .+ range(0.0, 1.0, length=31).*(Rtip - Rhub)\nradii = 0.5.*(radii[2:end] .+ radii[1:end-1])\n\ncs_area_over_chord_squared = 0.064\nchord = [\n    0.35044     , 0.28260     , 0.22105     , 0.17787     , 0.14760,\n    0.12567     , 0.10927     , 0.96661E-01 , 0.86742E-01 ,\n    0.78783E-01 , 0.72287E-01 , 0.66906E-01 , 0.62387E-01 ,\n    0.58541E-01 , 0.55217E-01 , 0.52290E-01 , 0.49645E-01 ,\n    0.47176E-01 , 0.44772E-01 , 0.42326E-01 , 0.39732E-01 ,\n    0.36898E-01 , 0.33752E-01 , 0.30255E-01 , 0.26401E-01 ,\n    0.22217E-01 , 0.17765E-01 , 0.13147E-01 , 0.85683E-02 ,\n    0.47397E-02].*Rtip\n\ntheta = [\n    40.005, 34.201, 28.149, 23.753, 20.699, 18.516, 16.890, 15.633,\n    14.625, 13.795, 13.094, 12.488, 11.956, 11.481, 11.053, 10.662,\n    10.303, 9.9726, 9.6674, 9.3858, 9.1268, 8.8903, 8.6764, 8.4858,\n    8.3193, 8.1783, 8.0638, 7.9769, 7.9183, 7.8889].*(pi/180)\n\n# Define the operating point.\nrpm = 2200.0\nomega = rpm*(2*pi/60.0)\nrho = 1.226  # kg/m^3\nc0 = 340.0  # m/s\nmu = 0.1780e-4  # kg/(m*s)\npitch = 0.0  # rad\nVinf = 5.0  # m/s\n\n# Create an airfoil interpolation object.\nxrotor_config = XROTORAirfoilConfig(\n    A0=0.0, DCLDA=6.2800, CLMAX=1.5, CLMIN=-0.5, DCLDA_STALL=0.1,\n    DCL_STALL=0.1, MCRIT=0.8, CDMIN=0.13e-1, CLDMIN=0.5, DCDCL2=0.4e-2, REREF=0.2e6, REXP=-0.4)\nairfoil_interp(a, r, m) = af_xrotor(a, r, m, xrotor_config)\n\n# Create the CCBlade.jl structs.\nrotor = Rotor(Rhub, Rtip, B)\nsections = Section.(radii, chord, theta, Ref(airfoil_interp))\nops = OperatingPoint.(Vinf, omega.*radii, rho, pitch, mu, c0)\nouts = solve.(Ref(rotor), sections, ops)\n\n# Create the AcousticAnalogies.jl source elements.\nbpp = 60/(rpm*B)\nperiod = 2*bpp\nnum_source_times = 64\npositive_x_rotation = true\nses = f1a_source_elements_ccblade(rotor, sections, ops, outs, fill(cs_area_over_chord_squared, length(radii)), period, num_source_times, positive_x_rotation)\n@show size(ses)","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"ses is an array of source elements of shape (num_source_times, num_radial, B), where num_source_times is the number of time steps over which the source elements are defined, num_radial is the number of radial elements each blade is subdivided into, and B is the number of blades.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"Now that we have an array of source elements, we can write them out to VTK files.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"name = \"two_blade_example\"\noutfiles = AcousticAnalogies.to_paraview_collection(name, ses)","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"This will write out one polygonal VTK (.vtp) file per time step, along with a ParaView collection (.pvd) file that allows us to open all of the .vtp files at once.","category":"page"},{"location":"writevtk_support/","page":"WriteVTK.jl Support","title":"WriteVTK.jl Support","text":"Here's an example visualization of the above example, showing an animation of the loading in the y direction, which is normal to the rotation axis of the rotor. (Image: Loading Animation)","category":"page"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"CurrentModule = AADocs","category":"page"},{"location":"itr_tests1/#Software-Quality-Assurance,-Cont.","page":"Ideally Twisted Rotor Tests","title":"Software Quality Assurance, Cont.","text":"","category":"section"},{"location":"itr_tests1/#BPM.jl-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor","page":"Ideally Twisted Rotor Tests","title":"BPM.jl Comparisons for the Pettingill et al. Ideally Twisted Rotor","text":"","category":"section"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"See here or here for details on the Ideally Twisted Rotor.","category":"page"},{"location":"itr_tests1/#Figure-22b","page":"Ideally Twisted Rotor Tests","title":"Figure 22b","text":"","category":"section"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing GLMakie\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, SteadyRotYTransformation, SteadyRotZTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing FLOWMath: Akima\nusing StaticArrays: @SVector\n\n# Copied from BPM.jl (would like to add BPM.jl as a dependency if it's registered in General some day).\n# tip vortex noise correction data based on \"Airfoil Tip Vortex Formation Noise\"\nconst bm_tip_alpha_aspect_data = [2.0,2.67,4.0,6.0,12.0,24.0]\nconst bm_tip_alpha_aratio_data = [0.54,0.62,0.71,0.79,0.89,0.95]\nconst bm_tip_alpha_aspect_ratio_correction = Akima(bm_tip_alpha_aspect_data, bm_tip_alpha_aratio_data)\n\nfunction bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n    # compute tip lift curve slope\n    if aspect_ratio < 2.0\n        aratio = 0.5*one(aspect_ratio)\n    elseif 2.0 <= aspect_ratio <= 24.0\n        aratio = bm_tip_alpha_aspect_ratio_correction(aspect_ratio)\n    elseif aspect_ratio > 24.0\n        aratio = 1.0*one(aspect_ratio)\n    end\n\n    return aratio\nend\n\nstruct BMTipAlphaCorrection{TCorrection} <: AbstractTipAlphaCorrection\n    correction::TCorrection\n\n    function BMTipAlphaCorrection(aspect_ratio)\n        # correction = BPM._tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        correction = bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        return new{typeof(correction)}(correction)\n    end\nend\n\nfunction AcousticAnalogies.tip_vortex_alpha_correction(blade_tip::AbstractBladeTip{<:BMTipAlphaCorrection}, alphatip)\n    a0l = AcousticAnalogies.alpha_zerolift(blade_tip)\n    correction_factor = AcousticAnalogies.tip_alpha_correction(blade_tip).correction\n    return correction_factor * (alphatip - a0l) + a0l\nend\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 22 caption says Ω_c = 5465 RPM.\nrpm = 5465.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_bpmjl = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure22b.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_bpmjl[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_bpmjl[\"U\"]\n\n# In the Figure 22 caption, \"for these predictions, bluntness thickness H was set to 0.8 mm and trailing edge angle Ψ was set to 16 degrees.\"\nh = 0.8e-3  # meters\nPsi = 16*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\nperiod_src = num_blade_pass*bpp\nnum_src_times = num_src_times_blade_pass * num_blade_pass\nt0 = 0.0\ndt = period_src/num_src_times\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# BPM.jl uses a different tip alpha correction which appears to require the blade aspect ratio.\n# Need to find the blade aspect ratio of the ITR to apply the tip vortex angle of attack correction.\n# The aspect ratio is defined as the blade tip radius divided by the average chord, but the chord is constant for this case.\naspect_ratio = Rtip / chord\n\n# Now we can create the tip object.\nalpha0lift = 0.0\nblade_tip = AcousticAnalogies.FlatTip(BMTipAlphaCorrection(aspect_ratio), alpha0lift)\n\n# Start with a rotation about the negative x axis.\npositive_x_rotation = false\nrot_trans = SteadyRotXTransformation(t0, omega*ifelse(positive_x_rotation, 1, -1), 0)\n\n# Then translate along the positive x axis.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0]\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Then a 90° rotation about the negative z axis.\ntrans_z90deg = SteadyRotZTransformation(0.0, 0.0, -0.5*pi)\n\n# Then a 90° rotation about the negative y axis.\ntrans_y90deg = SteadyRotYTransformation(0.0, 0.0, -0.5*pi)\n\n# Put them all together:\ntrans = compose.(src_times, Ref(trans_y90deg),\n            compose.(src_times, Ref(trans_z90deg),\n                compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))))\n\n# Use the M_c = 0.8*M that BPM report and BPM.jl use.\nU = @. 0.8*sqrt(Vinf^2 + (omega*radii)^2)\n\n# In the text describing Figure 22, \"For these predictions, the trip flag was set to “tripped”, due to the rough surface quality of the blade.\"\n# So we'll use a tripped boundary layer for all radial stations along the blade.\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\n\n# Need to do the LBLVS with the untripped boundary layer to match what BPM.jl is doing.\n# BPM.jl uses the untripped boundary layer properties for the laminar boundary layer-vortex shedding noise source, so do that here too.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# Paper doesn't specify the microphone used for Figure 22, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 22.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# So, the docstring for BPM.jl says that `V` argument is the wind velocity in the y direction.\n# So I guess we should assume that the blades are rotating about the y axis.\n# And if the freestream velocity is in the positive y axis, then, from the perspective of the fluid, the blades are translating in the negative y direction.\n# And I want the observer to be downstream/behind the blades, so that would mean they would have a positive y position.\n# So I want to rotate the observer around the positive x axis, so I'm going to switch the sign on `theta_obs`.\nt0_obs = 0.0\nx0_obs = @SVector [0.0, r_obs*sin(-theta_obs), r_obs*cos(-theta_obs)]\n# The observer is moving in the same direction as the blades, which is the negative y axis.\nv_obs = @SVector [0.0, -Vinf, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B) .* ifelse(positive_x_rotation, 1, -1)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\n# bls_rs = reshape(bls, 1, :, 1)\n# bls_untripped_rs = reshape(bls_untripped, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\n# chord_rs_no_tip = @view chord_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\n# hs_rs_no_tip = @view hs_rs[:, begin:end-1, :]\n# Psis_rs_no_tip = @view Psis_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\n# bls_rs_no_tip = @view bls_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\n# chord_rs_with_tip = @view chord_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\n# hs_rs_with_tip = @view hs_rs[:, end:end, :]\n# Psis_rs_with_tip = @view Psis_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\n# bls_rs_with_tip = @view bls_rs[:, end:end, :]\n\ndirect = AcousticAnalogies.BPMDirectivity\nuse_UInduction = false\nuse_Doppler = false\nmach_correction = AcousticAnalogies.NoMachCorrection\nses_no_tip = CombinedNoTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, Ref(bl), positive_x_rotation) .|> trans\n\nses_with_tip = CombinedWithTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, Ref(bl), Ref(blade_tip), positive_x_rotation) .|> trans\n\n# Put the source elements together:\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Need to do the LBLVS with the untripped boundary layer to match what BPM.jl is doing.\nlblvs_ses = AcousticAnalogies.LBLVSSourceElement{direct,use_UInduction,use_Doppler}.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n \n# Define the frequencies we'd like to evaluate.\n# BPM.jl uses the approximate 1/3rd-octave bands.\nfreqs_obs = AcousticMetrics.ApproximateThirdOctaveCenterBands(100.0, 40000.0)\nfreqs_src = freqs_obs\n\n# Now do the noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(lblvs_ses, Ref(obs), Ref(freqs_src))\n\n# Separate out each source.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Combine each noise prediction.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 22b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# (Dividing the MSP by Δf_pbs aka the 1/3 octave spacing is like getting a power-spectral density, then multiplying by the narrowband spacing Δf_nb gives us the MSP associated with the narrowband.)\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\nnb_lblvs_untripped = pbs_lblvs .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\nspl_lblvs_untripped = 10 .* log10.(nb_lblvs_untripped./(pref^2))\n\n# Finally, let's get the BPM.jl predictions for this case, which we've run and saved previously in a JLD2/HDF5 file.\nfreq_bpmjl = data_bpmjl[\"freqs\"]\nspl_pressure_bpmjl = data_bpmjl[\"spl_nb_pressure\"]\nspl_suction_bpmjl = data_bpmjl[\"spl_nb_suction\"]\nspl_separation_bpmjl = data_bpmjl[\"spl_nb_separation\"]\nspl_lblvs_bpmjl = data_bpmjl[\"spl_nb_lblvs\"]\nspl_blunt_bpmjl = data_bpmjl[\"spl_nb_blunt\"]\nspl_tip_bpmjl = data_bpmjl[\"spl_nb_tip\"]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_bpmjl, spl_pressure_bpmjl, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_bpmjl, spl_suction_bpmjl, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_bpmjl, spl_separation_bpmjl, color=:yellow, marker=:diamond)\ns_lblvs = scatter!(ax1, freq_bpmjl, spl_lblvs_bpmjl, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_bpmjl, spl_blunt_bpmjl, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_bpmjl, spl_tip_bpmjl, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\nl_lblvs = lines!(ax1, freqs_obs, spl_lblvs_untripped, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 10.0, 70.0)\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 62; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure22b-spl-bpmjl.png\", fig)","category":"page"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"(Image: )","category":"page"},{"location":"itr_tests1/#Figure-23c","page":"Ideally Twisted Rotor Tests","title":"Figure 23c","text":"","category":"section"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing GLMakie\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, SteadyRotYTransformation, SteadyRotZTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing FLOWMath: Akima\nusing StaticArrays: @SVector\n\n# Copied from BPM.jl (would like to add BPM.jl as a dependency if it's registered in General some day).\n# tip vortex noise correction data based on \"Airfoil Tip Vortex Formation Noise\"\nconst bm_tip_alpha_aspect_data = [2.0,2.67,4.0,6.0,12.0,24.0]\nconst bm_tip_alpha_aratio_data = [0.54,0.62,0.71,0.79,0.89,0.95]\nconst bm_tip_alpha_aspect_ratio_correction = Akima(bm_tip_alpha_aspect_data, bm_tip_alpha_aratio_data)\n\nfunction bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n    # compute tip lift curve slope\n    if aspect_ratio < 2.0\n        aratio = 0.5*one(aspect_ratio)\n    elseif 2.0 <= aspect_ratio <= 24.0\n        aratio = bm_tip_alpha_aspect_ratio_correction(aspect_ratio)\n    elseif aspect_ratio > 24.0\n        aratio = 1.0*one(aspect_ratio)\n    end\n\n    return aratio\nend\n\nstruct BMTipAlphaCorrection{TCorrection} <: AbstractTipAlphaCorrection\n    correction::TCorrection\n\n    function BMTipAlphaCorrection(aspect_ratio)\n        # correction = BPM._tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        correction = bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        return new{typeof(correction)}(correction)\n    end\nend\n\nfunction AcousticAnalogies.tip_vortex_alpha_correction(blade_tip::AbstractBladeTip{<:BMTipAlphaCorrection}, alphatip)\n    a0l = AcousticAnalogies.alpha_zerolift(blade_tip)\n    correction_factor = AcousticAnalogies.tip_alpha_correction(blade_tip).correction\n    return correction_factor * (alphatip - a0l) + a0l\nend\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 23 caption says Ω_c = 5510 RPM.\nrpm = 5510.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_bpmjl = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure23c.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_bpmjl[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_bpmjl[\"U\"]\n\n# In the Figure 23 caption, \"for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.\"\nh = 0.5e-3  # meters\nPsi = 14*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\nperiod_src = num_blade_pass*bpp\nnum_src_times = num_src_times_blade_pass * num_blade_pass\nt0 = 0.0\ndt = period_src/num_src_times\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# BPM.jl uses a different tip alpha correction which appears to require the blade aspect ratio.\n# Need to find the blade aspect ratio of the ITR to apply the tip vortex angle of attack correction.\n# The aspect ratio is defined as the blade tip radius divided by the average chord, but the chord is constant for this case.\naspect_ratio = Rtip / chord\n\n# Now we can create the tip object.\nalpha0lift = 0.0\nblade_tip = AcousticAnalogies.FlatTip(BMTipAlphaCorrection(aspect_ratio), alpha0lift)\n\n# Start with a rotation about the negative x axis.\npositive_x_rotation = false\nrot_trans = SteadyRotXTransformation(t0, omega*ifelse(positive_x_rotation, 1, -1), 0)\n\n# Then translate along the positive x axis.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0]\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Then a 90° rotation about the negative z axis.\ntrans_z90deg = SteadyRotZTransformation(0.0, 0.0, -0.5*pi)\n\n# Then a 90° rotation about the negative y axis.\ntrans_y90deg = SteadyRotYTransformation(0.0, 0.0, -0.5*pi)\n\n# Put them all together:\ntrans = compose.(src_times, Ref(trans_y90deg),\n            compose.(src_times, Ref(trans_z90deg),\n                compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))))\n\n# Use the M_c = 0.8*M that BPM report and BPM.jl use.\nU = @. 0.8*sqrt(Vinf^2 + (omega*radii)^2)\n\n# For the boundary layer we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.\n# First figure out how many of each we'll actually have with the `num_radial = 50` radial stations.\nnum_untripped = Int(round(0.95*num_radial))\nnum_tripped = num_radial - num_untripped\n# Now create a length-`num_radial` vector of untripped and then tripped boundary layer objects.\nbls = vcat(fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped), fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped))\n\n# Now, the other trick: for this case, we're only going to include the LBLVS source where the local Reynolds number (with the chord as the length scale) is < 160000.\nlow_Re_c = 160000.0\n# So we need the Reynolds number for each section.\nRe_c = U .* chord / nu\n# Now we'll get a length-`num_radial` vector of Bools indicating if that criteria is satisfied or not.\nlblvs_flags = Re_c .< low_Re_c\n\n# Also we'll always be using the untripped boundary layer for LBLVS, like BPM.jl does.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# Paper doesn't specify the microphone used for Figure 23, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 23.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# So, the docstring for BPM.jl says that `V` argument is the wind velocity in the y direction.\n# So I guess we should assume that the blades are rotating about the y axis.\n# And if the freestream velocity is in the positive y axis, then, from the perspective of the fluid, the blades are translating in the negative y direction.\n# And I want the observer to be downstream/behind the blades, so that would mean they would have a positive y position.\n# So I want to rotate the observer around the positive x axis, so I'm going to switch the sign on `theta_obs`.\nt0_obs = 0.0\nx0_obs = @SVector [0.0, r_obs*sin(-theta_obs), r_obs*cos(-theta_obs)]\n# The observer is moving in the same direction as the blades, which is the negative y axis.\nv_obs = @SVector [0.0, -Vinf, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B) .* ifelse(positive_x_rotation, 1, -1)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\nbls_rs = reshape(bls, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\nbls_rs_no_tip = @view bls_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\nbls_rs_with_tip = @view bls_rs[:, end:end, :]\n\ndirect = AcousticAnalogies.BPMDirectivity\nuse_UInduction = false\nuse_Doppler = false\nmach_correction = AcousticAnalogies.NoMachCorrection\nses_no_tip = CombinedNoTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|> trans\n\nses_with_tip = CombinedWithTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|> trans\n\n# Put the source elements together:\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Need to do the LBLVS with the untripped boundary layer to match what BPM.jl is doing, and only where `lblvs_flags` is true.\n# So extract the radial locations where that's true.\nradii_lblvs = @view radii[lblvs_flags]\ndradii_lblvs = @view dradii[lblvs_flags]\ntwist_lblvs = @view twist[lblvs_flags]\nUs_lblvs = @view U[lblvs_flags]\nalphas_lblvs = @view alpha[lblvs_flags]\n\n# Now do the usual reshaping.\nradii_lblvs_rs = reshape(radii_lblvs, 1, :, 1)\ndradii_lblvs_rs = reshape(dradii_lblvs, 1, :, 1)\ntwist_lblvs_rs = reshape(twist_lblvs, 1, :, 1)\nUs_lblvs_rs = reshape(Us_lblvs, 1, :, 1)\nalphas_lblvs_rs = reshape(alphas_lblvs, 1, :, 1)\n\n# Now we can construct the lblvs source elements.\nlblvs_ses = AcousticAnalogies.LBLVSSourceElement{direct,use_UInduction,use_Doppler}.(asound, nu, radii_lblvs_rs, θs_rs, dradii_lblvs_rs, chord, twist_lblvs_rs, Us_lblvs_rs, alphas_lblvs_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# Define the frequencies we'd like to evaluate.\n# BPM.jl uses the approximate 1/3rd-octave bands.\nfreqs_obs = AcousticMetrics.ApproximateThirdOctaveCenterBands(100.0, 40000.0)\nfreqs_src = freqs_obs\n\n# Now do the noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(lblvs_ses, Ref(obs), Ref(freqs_src))\n\n# Separate out each source.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Combine each noise prediction.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 23c is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# (Dividing the MSP by Δf_pbs aka the 1/3 octave spacing is like getting a power-spectral density, then multiplying by the narrowband spacing Δf_nb gives us the MSP associated with the narrowband.)\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\nnb_lblvs_untripped = pbs_lblvs .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\nspl_lblvs_untripped = 10 .* log10.(nb_lblvs_untripped./(pref^2))\n\n# Finally, let's get the BPM.jl predictions for this case, which we've run and saved previously in a JLD2/HDF5 file.\nfreq_bpmjl = data_bpmjl[\"freqs\"]\nspl_pressure_bpmjl = data_bpmjl[\"spl_nb_pressure\"]\nspl_suction_bpmjl = data_bpmjl[\"spl_nb_suction\"]\nspl_separation_bpmjl = data_bpmjl[\"spl_nb_separation\"]\nspl_lblvs_bpmjl = data_bpmjl[\"spl_nb_lblvs\"]\nspl_blunt_bpmjl = data_bpmjl[\"spl_nb_blunt\"]\nspl_tip_bpmjl = data_bpmjl[\"spl_nb_tip\"]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_bpmjl, spl_pressure_bpmjl, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_bpmjl, spl_suction_bpmjl, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_bpmjl, spl_separation_bpmjl, color=:yellow, marker=:diamond)\ns_lblvs = scatter!(ax1, freq_bpmjl, spl_lblvs_bpmjl, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_bpmjl, spl_blunt_bpmjl, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_bpmjl, spl_tip_bpmjl, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\nl_lblvs = lines!(ax1, freqs_obs, spl_lblvs_untripped, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 10.0, 70.0)\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 62; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure23c-spl-bpmjl.png\", fig)","category":"page"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"(Image: )","category":"page"},{"location":"itr_tests1/#Figure-24b","page":"Ideally Twisted Rotor Tests","title":"Figure 24b","text":"","category":"section"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing GLMakie\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, SteadyRotYTransformation, SteadyRotZTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing FLOWMath: Akima\nusing StaticArrays: @SVector\n\n# Copied from BPM.jl (would like to add BPM.jl as a dependency if it's registered in General some day).\n# tip vortex noise correction data based on \"Airfoil Tip Vortex Formation Noise\"\nconst bm_tip_alpha_aspect_data = [2.0,2.67,4.0,6.0,12.0,24.0]\nconst bm_tip_alpha_aratio_data = [0.54,0.62,0.71,0.79,0.89,0.95]\nconst bm_tip_alpha_aspect_ratio_correction = Akima(bm_tip_alpha_aspect_data, bm_tip_alpha_aratio_data)\n\nfunction bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n    # compute tip lift curve slope\n    if aspect_ratio < 2.0\n        aratio = 0.5*one(aspect_ratio)\n    elseif 2.0 <= aspect_ratio <= 24.0\n        aratio = bm_tip_alpha_aspect_ratio_correction(aspect_ratio)\n    elseif aspect_ratio > 24.0\n        aratio = 1.0*one(aspect_ratio)\n    end\n\n    return aratio\nend\n\nstruct BMTipAlphaCorrection{TCorrection} <: AbstractTipAlphaCorrection\n    correction::TCorrection\n\n    function BMTipAlphaCorrection(aspect_ratio)\n        # correction = BPM._tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        correction = bm_tip_vortex_alpha_correction_nonsmooth(aspect_ratio)\n        return new{typeof(correction)}(correction)\n    end\nend\n\nfunction AcousticAnalogies.tip_vortex_alpha_correction(blade_tip::AbstractBladeTip{<:BMTipAlphaCorrection}, alphatip)\n    a0l = AcousticAnalogies.alpha_zerolift(blade_tip)\n    correction_factor = AcousticAnalogies.tip_alpha_correction(blade_tip).correction\n    return correction_factor * (alphatip - a0l) + a0l\nend\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 24 caption says Ω_c = 2938 RPM.\nrpm = 2938.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_bpmjl = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure24b.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_bpmjl[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_bpmjl[\"U\"]\n\n# In the Figure 24 caption, \"for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.\"\nh = 0.5e-3  # meters\nPsi = 14*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\n\n# Get the time levels we'll run.\n# First, get the blade passing period.\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\n\n# Now we can get the total period of source time we'll run over.\nperiod_src = num_blade_pass*bpp\n# And th number of source times.\nnum_src_times = num_src_times_blade_pass * num_blade_pass\n\n# We know the total time period and number of source times, so we can get the time step.\ndt = period_src/num_src_times\n\n# We'll arbitrarily start at time 0.0 seconds.\nt0 = 0.0\n\n# And now we can finally get each source time.\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# BPM.jl uses a different tip alpha correction which appears to require the blade aspect ratio.\n# Need to find the blade aspect ratio of the ITR to apply the tip vortex angle of attack correction.\n# The aspect ratio is defined as the blade tip radius divided by the average chord, but the chord is constant for this case.\naspect_ratio = Rtip / chord\n\n# Now we can create the tip object.\nalpha0lift = 0.0\nblade_tip = AcousticAnalogies.FlatTip(BMTipAlphaCorrection(aspect_ratio), alpha0lift)\n\n# Start with a rotation about the negative x axis.\npositive_x_rotation = false\nrot_trans = SteadyRotXTransformation(t0, omega*ifelse(positive_x_rotation, 1, -1), 0)\n\n# Then translate along the positive x axis.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0]\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Then a 90° rotation about the negative z axis.\ntrans_z90deg = SteadyRotZTransformation(0.0, 0.0, -0.5*pi)\n\n# Then a 90° rotation about the negative y axis.\ntrans_y90deg = SteadyRotYTransformation(0.0, 0.0, -0.5*pi)\n\n# Put them all together:\ntrans = compose.(src_times, Ref(trans_y90deg),\n            compose.(src_times, Ref(trans_z90deg),\n                compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))))\n\n# Use the M_c = 0.8*M that BPM report and BPM.jl use.\nU = @. 0.8*sqrt(Vinf^2 + (omega*radii)^2)\n\n# For the boundary layer we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.\n# First figure out how many of each we'll actually have with the `num_radial = 50` radial stations.\nnum_untripped = Int(round(0.95*num_radial))\nnum_tripped = num_radial - num_untripped\n# Now create a length-`num_radial` vector of untripped and then tripped boundary layer objects.\nbls = vcat(fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped), fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped))\n\n# Also we'll always be using the untripped boundary layer for LBLVS, like BPM.jl does.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# Paper doesn't specify the microphone used for Figure 24, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 23.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# So, the docstring for BPM.jl says that `V` argument is the wind velocity in the y direction.\n# So I guess we should assume that the blades are rotating about the y axis.\n# And if the freestream velocity is in the positive y axis, then, from the perspective of the fluid, the blades are translating in the negative y direction.\n# And I want the observer to be downstream/behind the blades, so that would mean they would have a positive y position.\n# So I want to rotate the observer around the positive x axis, so I'm going to switch the sign on `theta_obs`.\nt0_obs = 0.0\nx0_obs = @SVector [0.0, r_obs*sin(-theta_obs), r_obs*cos(-theta_obs)]\n# The observer is moving in the same direction as the blades, which is the negative y axis.\nv_obs = @SVector [0.0, -Vinf, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B) .* ifelse(positive_x_rotation, 1, -1)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\nbls_rs = reshape(bls, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\nbls_rs_no_tip = @view bls_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\nbls_rs_with_tip = @view bls_rs[:, end:end, :]\n\n# Use the directivity functions from the BPM report.\ndirect = AcousticAnalogies.BPMDirectivity\n\n# Don't include induction for the velocity scale U.\nuse_UInduction = false\n\n# Don't doppler-shift the source frequencies and source time steps to get observer frequencies & timesteps.\nuse_Doppler = false\n\n# Don't use the Prandtl-Glauret Mach number correction that Brooks & Burley recommend.\nmach_correction = AcousticAnalogies.NoMachCorrection\n\nses_no_tip = CombinedNoTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|> trans\n\nses_with_tip = CombinedWithTipBroadbandSourceElement{direct,use_UInduction,mach_correction,use_Doppler}.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|> trans\n\n# Put the source elements together:\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Need to do the LBLVS with the untripped boundary layer to match what BPM.jl is doing.\nlblvs_ses = AcousticAnalogies.LBLVSSourceElement{direct,use_UInduction,use_Doppler}.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# Define the frequencies we'd like to evaluate.\n# BPM.jl uses the approximate 1/3rd-octave bands.\nfreqs_obs = AcousticMetrics.ApproximateThirdOctaveCenterBands(100.0, 40000.0)\nfreqs_src = freqs_obs\n\n# Now do the noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(lblvs_ses, Ref(obs), Ref(freqs_src))\n\n# Separate out each source.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Combine each noise prediction.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 24b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# (Dividing the MSP by Δf_pbs aka the 1/3 octave spacing is like getting a power-spectral density, then multiplying by the narrowband spacing Δf_nb gives us the MSP associated with the narrowband.)\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\nnb_lblvs_untripped = pbs_lblvs .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\nspl_lblvs_untripped = 10 .* log10.(nb_lblvs_untripped./(pref^2))\n\n# Finally, let's get the BPM.jl predictions for this case, which we've run and saved previously in a JLD2/HDF5 file.\nfreq_bpmjl = data_bpmjl[\"freqs\"]\nspl_pressure_bpmjl = data_bpmjl[\"spl_nb_pressure\"]\nspl_suction_bpmjl = data_bpmjl[\"spl_nb_suction\"]\nspl_separation_bpmjl = data_bpmjl[\"spl_nb_separation\"]\nspl_lblvs_bpmjl = data_bpmjl[\"spl_nb_lblvs\"]\nspl_blunt_bpmjl = data_bpmjl[\"spl_nb_blunt\"]\nspl_tip_bpmjl = data_bpmjl[\"spl_nb_tip\"]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_bpmjl, spl_pressure_bpmjl, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_bpmjl, spl_suction_bpmjl, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_bpmjl, spl_separation_bpmjl, color=:yellow, marker=:diamond)\ns_lblvs = scatter!(ax1, freq_bpmjl, spl_lblvs_bpmjl, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_bpmjl, spl_blunt_bpmjl, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_bpmjl, spl_tip_bpmjl, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\nl_lblvs = lines!(ax1, freqs_obs, spl_lblvs_untripped, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 0.0, 50.0)\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 44; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure24b-spl-bpmjl.png\", fig)","category":"page"},{"location":"itr_tests1/","page":"Ideally Twisted Rotor Tests","title":"Ideally Twisted Rotor Tests","text":"(Image: )","category":"page"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"CurrentModule = AADocs","category":"page"},{"location":"itr_tests2/#Software-Quality-Assurance,-Cont.","page":"Ideally Twisted Rotor Tests, Cont.","title":"Software Quality Assurance, Cont.","text":"","category":"section"},{"location":"itr_tests2/#PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor","page":"Ideally Twisted Rotor Tests, Cont.","title":"PAS/ROTONET/BARC Comparisons for the Pettingill et al. Ideally Twisted Rotor","text":"","category":"section"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"See here or here for details on the Ideally Twisted Rotor.","category":"page"},{"location":"itr_tests2/#Figure-22b","page":"Ideally Twisted Rotor Tests, Cont.","title":"Figure 22b","text":"","category":"section"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing DelimitedFiles: readdlm\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing GLMakie\nusing StaticArrays: @SVector\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 22 caption says Ω_c = 5465 RPM.\nrpm = 5465.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_ccblade = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure22b.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_ccblade[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_ccblade[\"U\"]\n\n# In the text describing Figure 22, \"For these predictions, the trip flag was set to “tripped”, due to the rough surface quality of the blade.\"\nbl = AcousticAnalogies.TrippedN0012BoundaryLayer()\n\n# But we're going to use the untripped boundary layer for the LBL-VS noise.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# In the Figure 22 caption, \"for these predictions, bluntness thickness H was set to 0.8 mm and trailing edge angle Ψ was set to 16 degrees.\"\nh = 0.8e-3  # meters\nPsi = 16*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\nperiod_src = num_blade_pass*bpp\nnum_src_times = num_src_times_blade_pass * num_blade_pass\nt0 = 0.0\ndt = period_src/num_src_times\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# I don't see any discussion for what type of tip was used for the tip vortex noise.\n# The flat tip seems to match the PAS+ROTONET+BARC predictions well.\nblade_tip = AcousticAnalogies.FlatTip()\n\n# Now let's define the coordinate system.\n# I'm going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# And the blades will be rotating about the positive x axis at a rate of `omega`.\nrot_trans = SteadyRotXTransformation(t0, omega, 0.0)\n\n# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0] # m/s\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Now I can put the two transformations together:\ntrans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B)\n\n# Paper doesn't specify the microphone used for Figure 22, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 22.\n# For the coordinate system, I'm doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.\n# But it will of course be moving with the same freestream in the positive x direction.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# The observer is moving in the positive x direction at Vinf, at the origin at time t0.\nt0_obs = 0.0\nx0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]\nv_obs = @SVector [Vinf, 0.0, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\n# bls_rs = reshape(bls, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\n# chord_rs_no_tip = @view chord_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\n# hs_rs_no_tip = @view hs_rs[:, begin:end-1, :]\n# Psis_rs_no_tip = @view Psis_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\n# chord_rs_with_tip = @view chord_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\n# hs_rs_with_tip = @view hs_rs[:, end:end, :]\n# Psis_rs_with_tip = @view Psis_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\n\npositive_x_rotation = true\nses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, Ref(bl), positive_x_rotation) .|> trans\nses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, Ref(bl), Ref(blade_tip), positive_x_rotation) .|> trans\n\n# It's more convinient to cat all the sources together.\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Do the LBLVS prediction with the untripped boundary layer.\nses_lblvs = LBLVSSourceElement.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# The predictions in Figure 22b appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.\n# But let's expand the range of source frequencies to account for Doppler shifting.\nfreqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)\nfreqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)\n\n# Now we can do a noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))\n\n# This seperates out the noise prediction for each source-observer combination into the different sources.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\n# pbs_lblvss = AcousticAnalogies.pbs_lblvs.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Now, need to combine each broadband noise prediction.\n# The time axis the axis over which the time varies for each source.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 22b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_lblvs = pbs_lblvs .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\n\n# Now I should be able to compare to the BARC data.\n# Need to read it in first.\ndata_pressure_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-TBL-TE-pressure-2.csv\"), ',')\nfreq_pressure_barc = data_pressure_barc[:, 1]\nspl_pressure_barc = data_pressure_barc[:, 2]\n\ndata_suction_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-TBL-TE-suction-2.csv\"), ',')\nfreq_suction_barc = data_suction_barc[:, 1]\nspl_suction_barc = data_suction_barc[:, 2]\n\ndata_separation_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-separation-2.csv\"), ',')\nfreq_separation_barc = data_separation_barc[:, 1]\nspl_separation_barc = data_separation_barc[:, 2]\n\n# data_lblvs_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-LBLVS.csv\"), ',')\n# freq_lblvs_barc = data_lblvs_barc[:, 1]\n# spl_lblvs_barc = data_lblvs_barc[:, 2]\n\ndata_teb_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-BVS.csv\"), ',')\nfreq_teb_barc = data_teb_barc[:, 1]\nspl_teb_barc = data_teb_barc[:, 2]\n\ndata_tip_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure22b-tip_vortex_shedding.csv\"), ',')\nfreq_tip_barc = data_tip_barc[:, 1]\nspl_tip_barc = data_tip_barc[:, 2]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)\n# s_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\n# l_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 10.0, 70.0)\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        # [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         # \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 62; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure22b-spl-barc.png\", fig)","category":"page"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"(Image: )","category":"page"},{"location":"itr_tests2/#Figure-23c","page":"Ideally Twisted Rotor Tests, Cont.","title":"Figure 23c","text":"","category":"section"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing DelimitedFiles: readdlm\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing GLMakie\nusing StaticArrays: @SVector\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 23 caption says Ω_c = 5510 RPM.\nrpm = 5510.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_ccblade = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure23c.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_ccblade[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_ccblade[\"U\"]\n\n# So, for the boundary layer, we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.\nnum_untripped = Int(round(0.95*num_radial))\nnum_tripped = num_radial - num_untripped\nbls_untripped = fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped)\nbls_tripped = fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped)\nbls = vcat(bls_untripped, bls_tripped)\n\n# Now, the other trick: need to only include LBLVS noise for elements where the Reynolds number is < 160000.\n# So, we need the Reynolds number for each section.\nRe_c = @. U * chord / nu\n# So now we want to extract the radial stations that meet that < 160000 condition.\nlow_Re_c = 160000\nmask_low_Re_c = Re_c .< low_Re_c\n\n# And we're also going to use the untripped boundary layer for the LBLVS source.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# In the Figure 23 caption, \"for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.\"\nh = 0.5e-3  # meters\nPsi = 14*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\nperiod_src = num_blade_pass*bpp\nnum_src_times = num_src_times_blade_pass * num_blade_pass\nt0 = 0.0\ndt = period_src/num_src_times\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# I don't see any discussion for what type of tip was used for the tip vortex noise.\n# The flat tip seems to match the PAS+ROTONET+BARC predictions well.\nblade_tip = AcousticAnalogies.FlatTip()\n\n# Now let's define the coordinate system.\n# I'm going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# And the blades will be rotating about the positive x axis at a rate of `omega`.\nrot_trans = SteadyRotXTransformation(t0, omega, 0.0)\n\n# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0] # m/s\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Now I can put the two transformations together:\ntrans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B)\n\n# Paper doesn't specify the microphone used for Figure 22, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 22.\n# For the coordinate system, I'm doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.\n# But it will of course be moving with the same freestream in the positive x direction.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# The observer is moving in the positive x direction at Vinf, at the origin at time t0.\nt0_obs = 0.0\nx0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]\nv_obs = @SVector [Vinf, 0.0, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\nbls_rs = reshape(bls, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\n# chord_rs_no_tip = @view chord_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\n# hs_rs_no_tip = @view hs_rs[:, begin:end-1, :]\n# Psis_rs_no_tip = @view Psis_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\nbls_rs_no_tip = @view bls_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\n# chord_rs_with_tip = @view chord_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\n# hs_rs_with_tip = @view hs_rs[:, end:end, :]\n# Psis_rs_with_tip = @view Psis_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\nbls_rs_with_tip = @view bls_rs[:, end:end, :]\n\npositive_x_rotation = true\nses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|> trans\nses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|> trans\n\n# It's more convinient to cat all the sources together.\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Need to do the LBLVS stuff separately.\n# Grab the parts of the inputs that correspond to the low Reynolds number stations.\nradii_lblvs = @view radii[mask_low_Re_c]\ndradii_lblvs = @view dradii[mask_low_Re_c]\n# chord_lblvs = @view chord[mask_low_Re_c]\ntwist_lblvs = @view twist[mask_low_Re_c]\n# hs_lblvs = @view hs[mask_low_Re_c]\n# Psis_lblvs = @view Psis[mask_low_Re_c]\nUs_lblvs = @view U[mask_low_Re_c]\nalphas_lblvs = @view alpha[mask_low_Re_c]\n\n# And do the reshaping.\nradii_lblvs_rs = reshape(radii_lblvs, 1, :, 1)\ndradii_lblvs_rs = reshape(dradii_lblvs, 1, :, 1)\n# chord_lblvs_rs = reshape(chord_lblvs, 1, :, 1)\ntwist_lblvs_rs = reshape(twist_lblvs, 1, :, 1)\n# hs_lblvs_rs = reshape(hs_lblvs, 1, :, 1)\n# Psis_lblvs_rs = reshape(Psis_lblvs, 1, :, 1)\nUs_lblvs_rs = reshape(Us_lblvs, 1, :, 1)\nalphas_lblvs_rs = reshape(alphas_lblvs, 1, :, 1)\n\n# Now we can create the source elements.\nses_lblvs = LBLVSSourceElement.(asound, nu, radii_lblvs_rs, θs_rs, dradii_lblvs_rs, chord, twist_lblvs_rs, Us_lblvs_rs, alphas_lblvs_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# Now we can create the source elements.\nses_lblvs = LBLVSSourceElement.(asound, nu, radii_lblvs_rs, θs_rs, dradii_lblvs_rs, chord, twist_lblvs_rs, Us_lblvs_rs, alphas_lblvs_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# The predictions in Figure 23c appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.\n# But let's expand the range of source frequencies to account for Doppler shifting.\nfreqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)\nfreqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)\n\n# Now we can do a noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))\n\n# This seperates out the noise prediction for each source-observer combination into the different sources.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Now, need to combine each broadband noise prediction.\n# The time axis the axis over which the time varies for each source.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 23c is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_lblvs = pbs_lblvs .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\n\n# Now I should be able to compare to the BARC data.\n# Need to read it in first.\ndata_pressure_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-TBL-TE-pressure.csv\"), ',')\nfreq_pressure_barc = data_pressure_barc[:, 1]\nspl_pressure_barc = data_pressure_barc[:, 2]\n\ndata_suction_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-TBL-TE-suction.csv\"), ',')\nfreq_suction_barc = data_suction_barc[:, 1]\nspl_suction_barc = data_suction_barc[:, 2]\n\ndata_separation_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-separation.csv\"), ',')\nfreq_separation_barc = data_separation_barc[:, 1]\nspl_separation_barc = data_separation_barc[:, 2]\n\ndata_lblvs_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-LBLVS.csv\"), ',')\nfreq_lblvs_barc = data_lblvs_barc[:, 1]\nspl_lblvs_barc = data_lblvs_barc[:, 2]\n\ndata_teb_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-BVS.csv\"), ',')\nfreq_teb_barc = data_teb_barc[:, 1]\nspl_teb_barc = data_teb_barc[:, 2]\n\ndata_tip_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure23c-tip_vortex_shedding.csv\"), ',')\nfreq_tip_barc = data_tip_barc[:, 1]\nspl_tip_barc = data_tip_barc[:, 2]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)\ns_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\nl_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 10.0, 70.0)\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 62; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure23c-spl-barc.png\", fig)","category":"page"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"(Image: )","category":"page"},{"location":"itr_tests2/#Figure-24b","page":"Ideally Twisted Rotor Tests, Cont.","title":"Figure 24b","text":"","category":"section"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"using AcousticAnalogies\nusing AcousticMetrics: AcousticMetrics\nusing DelimitedFiles: readdlm\nusing KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation\nusing FileIO: load\nusing GLMakie\nusing StaticArrays: @SVector\n\n# Pettingill et al., \"Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover\", 2021\n# Parameters from Table 1\nB = 4  # number of blades\nRtip = 0.1588 # meters\nchord = 0.2*Rtip\n\n# Standard day:\nTamb = 15 + 273.15 # 15°C in Kelvin\npamb = 101325.0  # Pa\nR = 287.052874 # J/(kg*K)\nrho = pamb/(R*Tamb)\nasound = sqrt(1.4*R*Tamb)\n# Dynamic and kinematic viscosity\nmu = rho*1.4502e-5\nnu = mu/rho\n\n# This is a hover case, so the freestream velocity should be zero.\n# CCBlade.jl will run with a zero freestream, but I've found that it compares a bit better with experiment if I give it a small non-zero value.\nVinf = 0.001*asound\n\n# Figure 24 caption says Ω_c = 2938 RPM.\nrpm = 2938.0\nomega = rpm * (2*pi/60)\n\n# Get \"cell-centered\" radial locations, and also the radial spacing.\nnum_radial = 50\nr_Rtip_ = range(0.2, 1.0; length=num_radial+1)\nr_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])\nradii = r_Rtip .* Rtip\ndradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip\nRhub = r_Rtip_[1]*Rtip\n\n# From Pettingill Equation (1), and value for Θ_tip in Table 1.\nΘ_tip = 6.9 * pi/180\ntwist = Θ_tip ./ (r_Rtip)\n\n# Need some aerodynamic quantities.\n# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.\ndata_ccblade = load(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"gen_bpmjl_data\", \"figure24b.jld2\"))\n# Angle of attack at each radial station, radians.\nalpha = data_ccblade[\"alpha\"]\n# Flow speed normal to span at each radial station, m/s.\nU = data_ccblade[\"U\"]\n\n# In the Figure 24 caption, \"for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.\"\nh = 0.5e-3  # meters\nPsi = 14*pi/180  # radians\n\n# We'll run for 1 blade pass, 20 time steps per blade pass.\nnum_blade_pass = 1\nnum_src_times_blade_pass = 20\n\n# Get the time levels we'll run.\n# First, get the blade passing period.\nbpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)\n\n# Now we can get the total period of source time we'll run over.\nperiod_src = num_blade_pass*bpp\n\n# And the number of source times.\nnum_src_times = num_src_times_blade_pass * num_blade_pass\n\n# We know the total time period and number of source times, so we can get the time step.\ndt = period_src/num_src_times\n\n# We'll arbitrarily start at time 0.0 seconds.\nt0 = 0.0\n\n# And now we can finally get each source time.\nsrc_times = t0 .+ (0:num_src_times-1).*dt\n\n# Now let's define the coordinate system.\n# I'm going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# And the blades will be rotating about the positive x axis at a rate of `omega`.\nrot_trans = SteadyRotXTransformation(t0, omega, 0.0)\n\n# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.\ny0_hub = @SVector [0.0, 0.0, 0.0]  # m\nv0_hub = @SVector [Vinf, 0.0, 0.0] # m/s\nconst_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)\n\n# Now I can put the two transformations together:\ntrans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))\n\n# Azimuthal offset for each blade.\nθs = (0:(B-1)) .* (2*pi/B)\n\n# For the boundary layer we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.\n# First figure out how many of each we'll actually have with the `num_radial = 50` radial stations.\nnum_untripped = Int(round(0.95*num_radial))\nnum_tripped = num_radial - num_untripped\n# Now create a length-`num_radial` vector of untripped and then tripped boundary layer objects.\nbls = vcat(fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped), fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped))\n\n# But we'll always use the untripped boundary layer with LBLVS.\nbl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()\n\n# I don't see any discussion for what type of tip was used for the tip vortex noise.\n# The flat tip seems to match the PAS+ROTONET+BARC predictions well.\nblade_tip = AcousticAnalogies.FlatTip()\n\n# Paper doesn't specify the microphone used for Figure 24, but earlier at the beginning of \"C. Noise Characteristics and Trends\" there is this:\n#   > For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).\n# So I'll just assume that holds for Figure 24.\n# For the coordinate system, I'm doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.\n# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.\n# But it will of course be moving with the same freestream in the positive x direction.\nr_obs = 2.27 # meters\ntheta_obs = -35*pi/180\n# The observer is moving in the positive x direction at Vinf, at the origin at time t0.\nt0_obs = 0.0\nx0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]\nv_obs = @SVector [Vinf, 0.0, 0.0]\nobs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)\n\n# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).\nθs_rs = reshape(θs, 1, 1, :)\nradii_rs = reshape(radii, 1, :, 1)\ndradii_rs = reshape(dradii, 1, :, 1)\n# chord_rs = reshape(chord, 1, :, 1)\ntwist_rs = reshape(twist, 1, :, 1)\n# hs_rs = reshape(hs, 1, :, 1)\n# Psis_rs = reshape(Psis, 1, :, 1)\nUs_rs = reshape(U, 1, :, 1)\nalphas_rs = reshape(alpha, 1, :, 1)\nbls_rs = reshape(bls, 1, :, 1)\n\n# Separate things into tip and no-tip.\nradii_rs_no_tip = @view radii_rs[:, begin:end-1, :]\ndradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]\ntwist_rs_no_tip = @view twist_rs[:, begin:end-1, :]\nUs_rs_no_tip = @view Us_rs[:, begin:end-1, :]\nalphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]\nbls_rs_no_tip = @view bls_rs[:, begin:end-1, :]\n\nradii_rs_with_tip = @view radii_rs[:, end:end, :]\ndradii_rs_with_tip = @view dradii_rs[:, end:end, :]\ntwist_rs_with_tip = @view twist_rs[:, end:end, :]\nUs_rs_with_tip = @view Us_rs[:, end:end, :]\nalphas_rs_with_tip = @view alphas_rs[:, end:end, :]\nbls_rs_with_tip = @view bls_rs[:, end:end, :]\n\npositive_x_rotation = true\nses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|> trans\nses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|> trans\n\n# Put the source elements together:\nses = cat(ses_no_tip, ses_with_tip; dims=2)\n\n# Need to do the LBLVS with the untripped boundary layer.\nses_lblvs = AcousticAnalogies.LBLVSSourceElement.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|> trans\n\n# The predictions in Figure 24b appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.\n# But let's expand the range of source frequencies to account for Doppler shifting.\nfreqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)\nfreqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)\n\n# Now we can do a noise prediction.\nbpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))\npbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))\n\n# This seperates out the noise prediction for each source-observer combination into the different sources.\npbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)\npbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)\npbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)\npbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)\npbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])\n\n# Now, need to combine each broadband noise prediction.\n# The time axis the axis over which the time varies for each source.\ntime_axis = 1\npbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)\npbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)\npbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)\npbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)\npbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)\npbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)\n\n# Now I need to account for the fact that Figure 24b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.\n# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.\n# I think the paper describes that, right?\n# Right, here's something:\n#\n#   > The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.\n#   > This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.\n#\n# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.\n# And then I'm dividing by that.\n# So that seems like the right thing.\n# So, first thing is to get the proportional band spacing.\nfreqs_l = AcousticMetrics.lower_bands(freqs_obs)\nfreqs_u = AcousticMetrics.upper_bands(freqs_obs)\ndf_pbs = freqs_u .- freqs_l\n\n# Also need the experimental narrowband spacing.\ndf_nb = 20.0\n# Now multiply each by that.\nnb_pressure = pbs_pressure .* df_nb ./ df_pbs\nnb_suction = pbs_suction .* df_nb ./ df_pbs\nnb_alpha = pbs_alpha .* df_nb ./ df_pbs\nnb_lblvs = pbs_lblvs .* df_nb ./ df_pbs\nnb_teb = pbs_teb .* df_nb ./ df_pbs\nnb_tip = pbs_tip .* df_nb ./ df_pbs\n\n# Now I want the SPL, which should just be this:\npref = 20e-6\nspl_pressure = 10 .* log10.(nb_pressure./(pref^2))\nspl_suction = 10 .* log10.(nb_suction./(pref^2))\nspl_alpha = 10 .* log10.(nb_alpha./(pref^2))\nspl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))\nspl_teb = 10 .* log10.(nb_teb./(pref^2))\nspl_tip = 10 .* log10.(nb_tip./(pref^2))\n\n# Now I should be able to compare to the BARC data.\n# Need to read it in first.\ndata_pressure_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-TBL-TE-pressure.csv\"), ',')\nfreq_pressure_barc = data_pressure_barc[:, 1]\nspl_pressure_barc = data_pressure_barc[:, 2]\n\ndata_suction_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-TBL-TE-suction.csv\"), ',')\nfreq_suction_barc = data_suction_barc[:, 1]\nspl_suction_barc = data_suction_barc[:, 2]\n\ndata_separation_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-separation.csv\"), ',')\nfreq_separation_barc = data_separation_barc[:, 1]\nspl_separation_barc = data_separation_barc[:, 2]\n\ndata_lblvs_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-LBLVS.csv\"), ',')\nfreq_lblvs_barc = data_lblvs_barc[:, 1]\nspl_lblvs_barc = data_lblvs_barc[:, 2]\n\ndata_teb_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-BVS.csv\"), ',')\nfreq_teb_barc = data_teb_barc[:, 1]\nspl_teb_barc = data_teb_barc[:, 2]\n\ndata_tip_barc = readdlm(joinpath(@__DIR__, \"..\", \"..\", \"test\", \"bpm_data\", \"pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021\", \"figure24b-tip_vortex_shedding.csv\"), ',')\nfreq_tip_barc = data_tip_barc[:, 1]\nspl_tip_barc = data_tip_barc[:, 2]\n\n# Now let's plot.\nfig = Figure()\nax1 = fig[2, 1] = Axis(fig, xlabel=\"frequency, Hz\", ylabel=\"SPL (dB Ref: 20 μPa), Δf = 20 Hz\", xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)\n\ns_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)\ns_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)\ns_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)\ns_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)\ns_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)\ns_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)\n\nl_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)\nl_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)\nl_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)\nl_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)\nl_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)\nl_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)\n\nxlims!(ax1, 2e2, 6e4)\nylims!(ax1, 0.0, 50.0)\n\n\nleg = Legend(fig[1, 1], [\n        [s_pressure, l_pressure],\n        [s_suction, l_suction],\n        [s_separation, l_alpha],\n        [s_lblvs, l_lblvs],\n        [s_blunt, l_teb],\n        [s_tip, l_tip],\n    ],\n    [\n         \"TBLTE-Pressure\",\n         \"TBLTE-Suction\",\n         \"Separation\",\n         \"LBLVS\",\n         \"BVS\",\n         \"Tip\",\n    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)\n\ntext!(ax1, 210, 44; text=\"markers: CCBlade.jl+BPM.jl\\nlines: CCBlade.jl+AcousticAnalogies.jl\")\n\nsave(\"figure24b-spl-barc.png\", fig)","category":"page"},{"location":"itr_tests2/","page":"Ideally Twisted Rotor Tests, Cont.","title":"Ideally Twisted Rotor Tests, Cont.","text":"(Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = AADocs","category":"page"},{"location":"#AcousticAnalogies.jl-Documentation","page":"Introduction","title":"AcousticAnalogies.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Summary: A pure-Julia package for propeller/rotor blade noise prediction with acoustic analogies.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"What's an acoustic analogy?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TL;DR answer:\nAn acoustic analogy is a noise prediction approach that takes information from one area of the fluid domain (e.g., a propeller blade surface, or a fictitious surface surrounding a complicated flow) and calculates the acoustics radiated by the flow. The particular acoustic analogy implemented in AcousticAnalogies.jl is especially well-suited for predicting tonal propeller/rotor noise, and has features that ease its inclusion in gradient-based optimizations.\nMathy answer:\nAn acoustic analogy is a clever rearrangement of the Navier-Stokes equations, the governing equations of fluid flow, into a form that looks like the classical inhomogeneous wave equation. The inhomogeneous term represents sources of sound in the flow. The wave equation can be solved using the appropriate Green's function, which requires the evaluation of two surface integrals and a volume integral (usually neglected). If the integration surface is taken to be a solid surface in the fluid domain (e.g., a propeller blade), we can use the acoustic analogy solution to predict the acoustics caused by the motion of and loading on the integration surface.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Features:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of L. Lopes' compact form of Farassat's formulation 1A (see http://dx.doi.org/10.2514/6.2015-2673 or http://dx.doi.org/10.2514/1.C034048 for details).\nImplementation of Brooks & Burley's rotor broadband noise prediction method http://dx.doi.org/10.2514/6.2001-2210.\nSupport for stationary or constant-velocity moving observers, with an explict calculation for the latter from D. Casalino http://dx.doi.org/10.1016/S0022-460X(02)00986-0.\nThoroughly tested: unit tests for everything, and multiple comparisons of the entire calculation to equivalent methods in NASA's ANOPP2 code.\nConvenient, fast coordinate system transformations through KinematicCoordinateTransformations.jl.\nWritten in pure Julia, and compatible with automatic differentiation (AD) tools like ForwardDiff.jl.\nComprehensive docs (TODO).\nFast!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Installation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add AcousticAnalogies","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Usage","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the docs.","category":"page"},{"location":"#Software-Quality-Assurance","page":"Introduction","title":"Software Quality Assurance","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This repository contains extensive tests run by GitHub Actions.\nThis repository only allows signed commits to be merged into the main branch.","category":"page"}]
}
