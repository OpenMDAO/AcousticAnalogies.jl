<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ideally Twisted Rotor Tests, Cont. · AcousticAnalogies.jl</title><meta name="title" content="Ideally Twisted Rotor Tests, Cont. · AcousticAnalogies.jl"/><meta property="og:title" content="Ideally Twisted Rotor Tests, Cont. · AcousticAnalogies.jl"/><meta property="twitter:title" content="Ideally Twisted Rotor Tests, Cont. · AcousticAnalogies.jl"/><meta name="description" content="Documentation for AcousticAnalogies.jl."/><meta property="og:description" content="Documentation for AcousticAnalogies.jl."/><meta property="twitter:description" content="Documentation for AcousticAnalogies.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AcousticAnalogies.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../guided_example/">Guided Example</a></li><li><a class="tocitem" href="../ccblade_example/">CCBlade.jl Example</a></li><li><a class="tocitem" href="../writevtk_support/">WriteVTK.jl Support</a></li><li><a class="tocitem" href="../openfast_example/">OpenFAST Example</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../sqa/">Software Quality Assurance</a></li><li><a class="tocitem" href="../bpm_tests1/">BPM Airfoil Self-Noise Tests</a></li><li><a class="tocitem" href="../bpm_tests2/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../bpm_tests3/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../itr_tests1/">Ideally Twisted Rotor Tests</a></li><li class="is-active"><a class="tocitem" href>Ideally Twisted Rotor Tests, Cont.</a><ul class="internal"><li><a class="tocitem" href="#PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor"><span>PAS/ROTONET/BARC Comparisons for the Pettingill et al. Ideally Twisted Rotor</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ideally Twisted Rotor Tests, Cont.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ideally Twisted Rotor Tests, Cont.</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl/blob/main/docs/src/itr_tests2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Software-Quality-Assurance,-Cont."><a class="docs-heading-anchor" href="#Software-Quality-Assurance,-Cont.">Software Quality Assurance, Cont.</a><a id="Software-Quality-Assurance,-Cont.-1"></a><a class="docs-heading-anchor-permalink" href="#Software-Quality-Assurance,-Cont." title="Permalink"></a></h1><h2 id="PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor"><a class="docs-heading-anchor" href="#PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor">PAS/ROTONET/BARC Comparisons for the Pettingill et al. Ideally Twisted Rotor</a><a id="PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor-1"></a><a class="docs-heading-anchor-permalink" href="#PAS/ROTONET/BARC-Comparisons-for-the-Pettingill-et-al.-Ideally-Twisted-Rotor" title="Permalink"></a></h2><p>See <a href="http://dx.doi.org/10.2514/6.2021-1928">here</a> or <a href="https://ntrs.nasa.gov/citations/20205003328">here</a> for details on the Ideally Twisted Rotor.</p><h3 id="Figure-22b"><a class="docs-heading-anchor" href="#Figure-22b">Figure 22b</a><a id="Figure-22b-1"></a><a class="docs-heading-anchor-permalink" href="#Figure-22b" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AcousticAnalogies
using AcousticMetrics: AcousticMetrics
using DelimitedFiles: readdlm
using KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation
using FileIO: load
using GLMakie
using StaticArrays: @SVector

# Pettingill et al., &quot;Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover&quot;, 2021
# Parameters from Table 1
B = 4  # number of blades
Rtip = 0.1588 # meters
chord = 0.2*Rtip

# Standard day:
Tamb = 15 + 273.15 # 15°C in Kelvin
pamb = 101325.0  # Pa
R = 287.052874 # J/(kg*K)
rho = pamb/(R*Tamb)
asound = sqrt(1.4*R*Tamb)
# Dynamic and kinematic viscosity
mu = rho*1.4502e-5
nu = mu/rho

# This is a hover case, so the freestream velocity should be zero.
# CCBlade.jl will run with a zero freestream, but I&#39;ve found that it compares a bit better with experiment if I give it a small non-zero value.
Vinf = 0.001*asound

# Figure 22 caption says Ω_c = 5465 RPM.
rpm = 5465.0
omega = rpm * (2*pi/60)

# Get &quot;cell-centered&quot; radial locations, and also the radial spacing.
num_radial = 50
r_Rtip_ = range(0.2, 1.0; length=num_radial+1)
r_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])
radii = r_Rtip .* Rtip
dradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip
Rhub = r_Rtip_[1]*Rtip

# From Pettingill Equation (1), and value for Θ_tip in Table 1.
Θ_tip = 6.9 * pi/180
twist = Θ_tip ./ (r_Rtip)

# Need some aerodynamic quantities.
# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.
data_ccblade = load(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;gen_bpmjl_data&quot;, &quot;figure22b.jld2&quot;))
# Angle of attack at each radial station, radians.
alpha = data_ccblade[&quot;alpha&quot;]
# Flow speed normal to span at each radial station, m/s.
U = data_ccblade[&quot;U&quot;]

# In the text describing Figure 22, &quot;For these predictions, the trip flag was set to “tripped”, due to the rough surface quality of the blade.&quot;
bl = AcousticAnalogies.TrippedN0012BoundaryLayer()

# But we&#39;re going to use the untripped boundary layer for the LBL-VS noise.
bl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()

# In the Figure 22 caption, &quot;for these predictions, bluntness thickness H was set to 0.8 mm and trailing edge angle Ψ was set to 16 degrees.&quot;
h = 0.8e-3  # meters
Psi = 16*pi/180  # radians

# We&#39;ll run for 1 blade pass, 20 time steps per blade pass.
num_blade_pass = 1
num_src_times_blade_pass = 20
bpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)
period_src = num_blade_pass*bpp
num_src_times = num_src_times_blade_pass * num_blade_pass
t0 = 0.0
dt = period_src/num_src_times
src_times = t0 .+ (0:num_src_times-1).*dt

# I don&#39;t see any discussion for what type of tip was used for the tip vortex noise.
# The flat tip seems to match the PAS+ROTONET+BARC predictions well.
blade_tip = AcousticAnalogies.FlatTip()

# Now let&#39;s define the coordinate system.
# I&#39;m going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# And the blades will be rotating about the positive x axis at a rate of `omega`.
rot_trans = SteadyRotXTransformation(t0, omega, 0.0)

# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.
y0_hub = @SVector [0.0, 0.0, 0.0]  # m
v0_hub = @SVector [Vinf, 0.0, 0.0] # m/s
const_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)

# Now I can put the two transformations together:
trans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))

# Azimuthal offset for each blade.
θs = (0:(B-1)) .* (2*pi/B)

# Paper doesn&#39;t specify the microphone used for Figure 22, but earlier at the beginning of &quot;C. Noise Characteristics and Trends&quot; there is this:
#   &gt; For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).
# So I&#39;ll just assume that holds for Figure 22.
# For the coordinate system, I&#39;m doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.
# But it will of course be moving with the same freestream in the positive x direction.
r_obs = 2.27 # meters
theta_obs = -35*pi/180
# The observer is moving in the positive x direction at Vinf, at the origin at time t0.
t0_obs = 0.0
x0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]
v_obs = @SVector [Vinf, 0.0, 0.0]
obs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)

# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).
θs_rs = reshape(θs, 1, 1, :)
radii_rs = reshape(radii, 1, :, 1)
dradii_rs = reshape(dradii, 1, :, 1)
# chord_rs = reshape(chord, 1, :, 1)
twist_rs = reshape(twist, 1, :, 1)
# hs_rs = reshape(hs, 1, :, 1)
# Psis_rs = reshape(Psis, 1, :, 1)
Us_rs = reshape(U, 1, :, 1)
alphas_rs = reshape(alpha, 1, :, 1)
# bls_rs = reshape(bls, 1, :, 1)

# Separate things into tip and no-tip.
radii_rs_no_tip = @view radii_rs[:, begin:end-1, :]
dradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]
# chord_rs_no_tip = @view chord_rs[:, begin:end-1, :]
twist_rs_no_tip = @view twist_rs[:, begin:end-1, :]
# hs_rs_no_tip = @view hs_rs[:, begin:end-1, :]
# Psis_rs_no_tip = @view Psis_rs[:, begin:end-1, :]
Us_rs_no_tip = @view Us_rs[:, begin:end-1, :]
alphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]

radii_rs_with_tip = @view radii_rs[:, end:end, :]
dradii_rs_with_tip = @view dradii_rs[:, end:end, :]
# chord_rs_with_tip = @view chord_rs[:, end:end, :]
twist_rs_with_tip = @view twist_rs[:, end:end, :]
# hs_rs_with_tip = @view hs_rs[:, end:end, :]
# Psis_rs_with_tip = @view Psis_rs[:, end:end, :]
Us_rs_with_tip = @view Us_rs[:, end:end, :]
alphas_rs_with_tip = @view alphas_rs[:, end:end, :]

positive_x_rotation = true
ses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, Ref(bl), positive_x_rotation) .|&gt; trans
ses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, Ref(bl), Ref(blade_tip), positive_x_rotation) .|&gt; trans

# It&#39;s more convinient to cat all the sources together.
ses = cat(ses_no_tip, ses_with_tip; dims=2)

# Do the LBLVS prediction with the untripped boundary layer.
ses_lblvs = LBLVSSourceElement.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|&gt; trans

# The predictions in Figure 22b appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.
# But let&#39;s expand the range of source frequencies to account for Doppler shifting.
freqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)
freqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)

# Now we can do a noise prediction.
bpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))
pbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))

# This seperates out the noise prediction for each source-observer combination into the different sources.
pbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)
pbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)
pbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)
# pbs_lblvss = AcousticAnalogies.pbs_lblvs.(bpm_outs)
pbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)
pbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])

# Now, need to combine each broadband noise prediction.
# The time axis the axis over which the time varies for each source.
time_axis = 1
pbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)
pbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)
pbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)
pbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)
pbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)
pbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)

# Now I need to account for the fact that Figure 22b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.
# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.
# I think the paper describes that, right?
# Right, here&#39;s something:
#
#   &gt; The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.
#   &gt; This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.
#
# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.
# And then I&#39;m dividing by that.
# So that seems like the right thing.
# So, first thing is to get the proportional band spacing.
freqs_l = AcousticMetrics.lower_bands(freqs_obs)
freqs_u = AcousticMetrics.upper_bands(freqs_obs)
df_pbs = freqs_u .- freqs_l

# Also need the experimental narrowband spacing.
df_nb = 20.0
# Now multiply each by that.
nb_pressure = pbs_pressure .* df_nb ./ df_pbs
nb_suction = pbs_suction .* df_nb ./ df_pbs
nb_alpha = pbs_alpha .* df_nb ./ df_pbs
nb_lblvs = pbs_lblvs .* df_nb ./ df_pbs
nb_teb = pbs_teb .* df_nb ./ df_pbs
nb_tip = pbs_tip .* df_nb ./ df_pbs

# Now I want the SPL, which should just be this:
pref = 20e-6
spl_pressure = 10 .* log10.(nb_pressure./(pref^2))
spl_suction = 10 .* log10.(nb_suction./(pref^2))
spl_alpha = 10 .* log10.(nb_alpha./(pref^2))
spl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))
spl_teb = 10 .* log10.(nb_teb./(pref^2))
spl_tip = 10 .* log10.(nb_tip./(pref^2))

# Now I should be able to compare to the BARC data.
# Need to read it in first.
data_pressure_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-TBL-TE-pressure-2.csv&quot;), &#39;,&#39;)
freq_pressure_barc = data_pressure_barc[:, 1]
spl_pressure_barc = data_pressure_barc[:, 2]

data_suction_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-TBL-TE-suction-2.csv&quot;), &#39;,&#39;)
freq_suction_barc = data_suction_barc[:, 1]
spl_suction_barc = data_suction_barc[:, 2]

data_separation_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-separation-2.csv&quot;), &#39;,&#39;)
freq_separation_barc = data_separation_barc[:, 1]
spl_separation_barc = data_separation_barc[:, 2]

# data_lblvs_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-LBLVS.csv&quot;), &#39;,&#39;)
# freq_lblvs_barc = data_lblvs_barc[:, 1]
# spl_lblvs_barc = data_lblvs_barc[:, 2]

data_teb_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-BVS.csv&quot;), &#39;,&#39;)
freq_teb_barc = data_teb_barc[:, 1]
spl_teb_barc = data_teb_barc[:, 2]

data_tip_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure22b-tip_vortex_shedding.csv&quot;), &#39;,&#39;)
freq_tip_barc = data_tip_barc[:, 1]
spl_tip_barc = data_tip_barc[:, 2]

# Now let&#39;s plot.
fig = Figure()
ax1 = fig[2, 1] = Axis(fig, xlabel=&quot;frequency, Hz&quot;, ylabel=&quot;SPL (dB Ref: 20 μPa), Δf = 20 Hz&quot;, xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)

s_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)
s_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)
s_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)
# s_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)
s_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)
s_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)

l_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)
l_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)
l_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)
# l_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)
l_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)
l_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)

xlims!(ax1, 2e2, 6e4)
ylims!(ax1, 10.0, 70.0)

leg = Legend(fig[1, 1], [
        [s_pressure, l_pressure],
        [s_suction, l_suction],
        [s_separation, l_alpha],
        # [s_lblvs, l_lblvs],
        [s_blunt, l_teb],
        [s_tip, l_tip],
    ],
    [
         &quot;TBLTE-Pressure&quot;,
         &quot;TBLTE-Suction&quot;,
         &quot;Separation&quot;,
         # &quot;LBLVS&quot;,
         &quot;BVS&quot;,
         &quot;Tip&quot;,
    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)

text!(ax1, 210, 62; text=&quot;markers: PAS+ROTONET+BARC\nlines: CCBlade.jl+AcousticAnalogies.jl&quot;)

save(&quot;figure22b-spl-barc.png&quot;, fig)</code></pre><p><img src="../figure22b-spl-barc.png" alt/></p><h3 id="Figure-23c"><a class="docs-heading-anchor" href="#Figure-23c">Figure 23c</a><a id="Figure-23c-1"></a><a class="docs-heading-anchor-permalink" href="#Figure-23c" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AcousticAnalogies
using AcousticMetrics: AcousticMetrics
using DelimitedFiles: readdlm
using KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation
using FileIO: load
using GLMakie
using StaticArrays: @SVector

# Pettingill et al., &quot;Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover&quot;, 2021
# Parameters from Table 1
B = 4  # number of blades
Rtip = 0.1588 # meters
chord = 0.2*Rtip

# Standard day:
Tamb = 15 + 273.15 # 15°C in Kelvin
pamb = 101325.0  # Pa
R = 287.052874 # J/(kg*K)
rho = pamb/(R*Tamb)
asound = sqrt(1.4*R*Tamb)
# Dynamic and kinematic viscosity
mu = rho*1.4502e-5
nu = mu/rho

# This is a hover case, so the freestream velocity should be zero.
# CCBlade.jl will run with a zero freestream, but I&#39;ve found that it compares a bit better with experiment if I give it a small non-zero value.
Vinf = 0.001*asound

# Figure 23 caption says Ω_c = 5510 RPM.
rpm = 5510.0
omega = rpm * (2*pi/60)

# Get &quot;cell-centered&quot; radial locations, and also the radial spacing.
num_radial = 50
r_Rtip_ = range(0.2, 1.0; length=num_radial+1)
r_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])
radii = r_Rtip .* Rtip
dradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip
Rhub = r_Rtip_[1]*Rtip

# From Pettingill Equation (1), and value for Θ_tip in Table 1.
Θ_tip = 6.9 * pi/180
twist = Θ_tip ./ (r_Rtip)

# Need some aerodynamic quantities.
# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.
data_ccblade = load(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;gen_bpmjl_data&quot;, &quot;figure23c.jld2&quot;))
# Angle of attack at each radial station, radians.
alpha = data_ccblade[&quot;alpha&quot;]
# Flow speed normal to span at each radial station, m/s.
U = data_ccblade[&quot;U&quot;]

# So, for the boundary layer, we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.
num_untripped = Int(round(0.95*num_radial))
num_tripped = num_radial - num_untripped
bls_untripped = fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped)
bls_tripped = fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped)
bls = vcat(bls_untripped, bls_tripped)

# Now, the other trick: need to only include LBLVS noise for elements where the Reynolds number is &lt; 160000.
# So, we need the Reynolds number for each section.
Re_c = @. U * chord / nu
# So now we want to extract the radial stations that meet that &lt; 160000 condition.
low_Re_c = 160000
mask_low_Re_c = Re_c .&lt; low_Re_c

# And we&#39;re also going to use the untripped boundary layer for the LBLVS source.
bl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()

# In the Figure 23 caption, &quot;for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.&quot;
h = 0.5e-3  # meters
Psi = 14*pi/180  # radians

# We&#39;ll run for 1 blade pass, 20 time steps per blade pass.
num_blade_pass = 1
num_src_times_blade_pass = 20
bpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)
period_src = num_blade_pass*bpp
num_src_times = num_src_times_blade_pass * num_blade_pass
t0 = 0.0
dt = period_src/num_src_times
src_times = t0 .+ (0:num_src_times-1).*dt

# I don&#39;t see any discussion for what type of tip was used for the tip vortex noise.
# The flat tip seems to match the PAS+ROTONET+BARC predictions well.
blade_tip = AcousticAnalogies.FlatTip()

# Now let&#39;s define the coordinate system.
# I&#39;m going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# And the blades will be rotating about the positive x axis at a rate of `omega`.
rot_trans = SteadyRotXTransformation(t0, omega, 0.0)

# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.
y0_hub = @SVector [0.0, 0.0, 0.0]  # m
v0_hub = @SVector [Vinf, 0.0, 0.0] # m/s
const_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)

# Now I can put the two transformations together:
trans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))

# Azimuthal offset for each blade.
θs = (0:(B-1)) .* (2*pi/B)

# Paper doesn&#39;t specify the microphone used for Figure 22, but earlier at the beginning of &quot;C. Noise Characteristics and Trends&quot; there is this:
#   &gt; For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).
# So I&#39;ll just assume that holds for Figure 22.
# For the coordinate system, I&#39;m doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.
# But it will of course be moving with the same freestream in the positive x direction.
r_obs = 2.27 # meters
theta_obs = -35*pi/180
# The observer is moving in the positive x direction at Vinf, at the origin at time t0.
t0_obs = 0.0
x0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]
v_obs = @SVector [Vinf, 0.0, 0.0]
obs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)

# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).
θs_rs = reshape(θs, 1, 1, :)
radii_rs = reshape(radii, 1, :, 1)
dradii_rs = reshape(dradii, 1, :, 1)
# chord_rs = reshape(chord, 1, :, 1)
twist_rs = reshape(twist, 1, :, 1)
# hs_rs = reshape(hs, 1, :, 1)
# Psis_rs = reshape(Psis, 1, :, 1)
Us_rs = reshape(U, 1, :, 1)
alphas_rs = reshape(alpha, 1, :, 1)
bls_rs = reshape(bls, 1, :, 1)

# Separate things into tip and no-tip.
radii_rs_no_tip = @view radii_rs[:, begin:end-1, :]
dradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]
# chord_rs_no_tip = @view chord_rs[:, begin:end-1, :]
twist_rs_no_tip = @view twist_rs[:, begin:end-1, :]
# hs_rs_no_tip = @view hs_rs[:, begin:end-1, :]
# Psis_rs_no_tip = @view Psis_rs[:, begin:end-1, :]
Us_rs_no_tip = @view Us_rs[:, begin:end-1, :]
alphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]
bls_rs_no_tip = @view bls_rs[:, begin:end-1, :]

radii_rs_with_tip = @view radii_rs[:, end:end, :]
dradii_rs_with_tip = @view dradii_rs[:, end:end, :]
# chord_rs_with_tip = @view chord_rs[:, end:end, :]
twist_rs_with_tip = @view twist_rs[:, end:end, :]
# hs_rs_with_tip = @view hs_rs[:, end:end, :]
# Psis_rs_with_tip = @view Psis_rs[:, end:end, :]
Us_rs_with_tip = @view Us_rs[:, end:end, :]
alphas_rs_with_tip = @view alphas_rs[:, end:end, :]
bls_rs_with_tip = @view bls_rs[:, end:end, :]

positive_x_rotation = true
ses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|&gt; trans
ses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|&gt; trans

# It&#39;s more convinient to cat all the sources together.
ses = cat(ses_no_tip, ses_with_tip; dims=2)

# Need to do the LBLVS stuff separately.
# Grab the parts of the inputs that correspond to the low Reynolds number stations.
radii_lblvs = @view radii[mask_low_Re_c]
dradii_lblvs = @view dradii[mask_low_Re_c]
# chord_lblvs = @view chord[mask_low_Re_c]
twist_lblvs = @view twist[mask_low_Re_c]
# hs_lblvs = @view hs[mask_low_Re_c]
# Psis_lblvs = @view Psis[mask_low_Re_c]
Us_lblvs = @view U[mask_low_Re_c]
alphas_lblvs = @view alpha[mask_low_Re_c]

# And do the reshaping.
radii_lblvs_rs = reshape(radii_lblvs, 1, :, 1)
dradii_lblvs_rs = reshape(dradii_lblvs, 1, :, 1)
# chord_lblvs_rs = reshape(chord_lblvs, 1, :, 1)
twist_lblvs_rs = reshape(twist_lblvs, 1, :, 1)
# hs_lblvs_rs = reshape(hs_lblvs, 1, :, 1)
# Psis_lblvs_rs = reshape(Psis_lblvs, 1, :, 1)
Us_lblvs_rs = reshape(Us_lblvs, 1, :, 1)
alphas_lblvs_rs = reshape(alphas_lblvs, 1, :, 1)

# Now we can create the source elements.
ses_lblvs = LBLVSSourceElement.(asound, nu, radii_lblvs_rs, θs_rs, dradii_lblvs_rs, chord, twist_lblvs_rs, Us_lblvs_rs, alphas_lblvs_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|&gt; trans

# Now we can create the source elements.
ses_lblvs = LBLVSSourceElement.(asound, nu, radii_lblvs_rs, θs_rs, dradii_lblvs_rs, chord, twist_lblvs_rs, Us_lblvs_rs, alphas_lblvs_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|&gt; trans

# The predictions in Figure 23c appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.
# But let&#39;s expand the range of source frequencies to account for Doppler shifting.
freqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)
freqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)

# Now we can do a noise prediction.
bpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))
pbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))

# This seperates out the noise prediction for each source-observer combination into the different sources.
pbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)
pbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)
pbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)
pbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)
pbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])

# Now, need to combine each broadband noise prediction.
# The time axis the axis over which the time varies for each source.
time_axis = 1
pbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)
pbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)
pbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)
pbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)
pbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)
pbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)

# Now I need to account for the fact that Figure 23c is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.
# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.
# I think the paper describes that, right?
# Right, here&#39;s something:
#
#   &gt; The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.
#   &gt; This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.
#
# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.
# And then I&#39;m dividing by that.
# So that seems like the right thing.
# So, first thing is to get the proportional band spacing.
freqs_l = AcousticMetrics.lower_bands(freqs_obs)
freqs_u = AcousticMetrics.upper_bands(freqs_obs)
df_pbs = freqs_u .- freqs_l

# Also need the experimental narrowband spacing.
df_nb = 20.0
# Now multiply each by that.
nb_pressure = pbs_pressure .* df_nb ./ df_pbs
nb_suction = pbs_suction .* df_nb ./ df_pbs
nb_alpha = pbs_alpha .* df_nb ./ df_pbs
nb_lblvs = pbs_lblvs .* df_nb ./ df_pbs
nb_teb = pbs_teb .* df_nb ./ df_pbs
nb_tip = pbs_tip .* df_nb ./ df_pbs

# Now I want the SPL, which should just be this:
pref = 20e-6
spl_pressure = 10 .* log10.(nb_pressure./(pref^2))
spl_suction = 10 .* log10.(nb_suction./(pref^2))
spl_alpha = 10 .* log10.(nb_alpha./(pref^2))
spl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))
spl_teb = 10 .* log10.(nb_teb./(pref^2))
spl_tip = 10 .* log10.(nb_tip./(pref^2))

# Now I should be able to compare to the BARC data.
# Need to read it in first.
data_pressure_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-TBL-TE-pressure.csv&quot;), &#39;,&#39;)
freq_pressure_barc = data_pressure_barc[:, 1]
spl_pressure_barc = data_pressure_barc[:, 2]

data_suction_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-TBL-TE-suction.csv&quot;), &#39;,&#39;)
freq_suction_barc = data_suction_barc[:, 1]
spl_suction_barc = data_suction_barc[:, 2]

data_separation_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-separation.csv&quot;), &#39;,&#39;)
freq_separation_barc = data_separation_barc[:, 1]
spl_separation_barc = data_separation_barc[:, 2]

data_lblvs_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-LBLVS.csv&quot;), &#39;,&#39;)
freq_lblvs_barc = data_lblvs_barc[:, 1]
spl_lblvs_barc = data_lblvs_barc[:, 2]

data_teb_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-BVS.csv&quot;), &#39;,&#39;)
freq_teb_barc = data_teb_barc[:, 1]
spl_teb_barc = data_teb_barc[:, 2]

data_tip_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure23c-tip_vortex_shedding.csv&quot;), &#39;,&#39;)
freq_tip_barc = data_tip_barc[:, 1]
spl_tip_barc = data_tip_barc[:, 2]

# Now let&#39;s plot.
fig = Figure()
ax1 = fig[2, 1] = Axis(fig, xlabel=&quot;frequency, Hz&quot;, ylabel=&quot;SPL (dB Ref: 20 μPa), Δf = 20 Hz&quot;, xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)

s_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)
s_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)
s_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)
s_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)
s_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)
s_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)

l_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)
l_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)
l_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)
l_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)
l_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)
l_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)

xlims!(ax1, 2e2, 6e4)
ylims!(ax1, 10.0, 70.0)

leg = Legend(fig[1, 1], [
        [s_pressure, l_pressure],
        [s_suction, l_suction],
        [s_separation, l_alpha],
        [s_lblvs, l_lblvs],
        [s_blunt, l_teb],
        [s_tip, l_tip],
    ],
    [
         &quot;TBLTE-Pressure&quot;,
         &quot;TBLTE-Suction&quot;,
         &quot;Separation&quot;,
         &quot;LBLVS&quot;,
         &quot;BVS&quot;,
         &quot;Tip&quot;,
    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)

text!(ax1, 210, 62; text=&quot;markers: PAS+ROTONET+BARC\nlines: CCBlade.jl+AcousticAnalogies.jl&quot;)

save(&quot;figure23c-spl-barc.png&quot;, fig)</code></pre><p><img src="../figure23c-spl-barc.png" alt/></p><h3 id="Figure-24b"><a class="docs-heading-anchor" href="#Figure-24b">Figure 24b</a><a id="Figure-24b-1"></a><a class="docs-heading-anchor-permalink" href="#Figure-24b" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AcousticAnalogies
using AcousticMetrics: AcousticMetrics
using DelimitedFiles: readdlm
using KinematicCoordinateTransformations: compose, SteadyRotXTransformation, ConstantVelocityTransformation
using FileIO: load
using GLMakie
using StaticArrays: @SVector

# Pettingill et al., &quot;Acoustic And Performance Characteristics of an Ideally Twisted Rotor in Hover&quot;, 2021
# Parameters from Table 1
B = 4  # number of blades
Rtip = 0.1588 # meters
chord = 0.2*Rtip

# Standard day:
Tamb = 15 + 273.15 # 15°C in Kelvin
pamb = 101325.0  # Pa
R = 287.052874 # J/(kg*K)
rho = pamb/(R*Tamb)
asound = sqrt(1.4*R*Tamb)
# Dynamic and kinematic viscosity
mu = rho*1.4502e-5
nu = mu/rho

# This is a hover case, so the freestream velocity should be zero.
# CCBlade.jl will run with a zero freestream, but I&#39;ve found that it compares a bit better with experiment if I give it a small non-zero value.
Vinf = 0.001*asound

# Figure 24 caption says Ω_c = 2938 RPM.
rpm = 2938.0
omega = rpm * (2*pi/60)

# Get &quot;cell-centered&quot; radial locations, and also the radial spacing.
num_radial = 50
r_Rtip_ = range(0.2, 1.0; length=num_radial+1)
r_Rtip = 0.5 .* (r_Rtip_[2:end] .+ r_Rtip_[1:end-1])
radii = r_Rtip .* Rtip
dradii = (r_Rtip_[2:end] .- r_Rtip_[1:end-1]) .* Rtip
Rhub = r_Rtip_[1]*Rtip

# From Pettingill Equation (1), and value for Θ_tip in Table 1.
Θ_tip = 6.9 * pi/180
twist = Θ_tip ./ (r_Rtip)

# Need some aerodynamic quantities.
# Got these using CCBlade.jl: see `AcousticAnalogies.jl/test/gen_bpmjl_data/itr_with_bpmjl.jl`.
data_ccblade = load(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;gen_bpmjl_data&quot;, &quot;figure24b.jld2&quot;))
# Angle of attack at each radial station, radians.
alpha = data_ccblade[&quot;alpha&quot;]
# Flow speed normal to span at each radial station, m/s.
U = data_ccblade[&quot;U&quot;]

# In the Figure 24 caption, &quot;for these predictions, bluntness thickness H was set to 0.5 mm and trailing edge angle Ψ was set to 14 degrees.&quot;
h = 0.5e-3  # meters
Psi = 14*pi/180  # radians

# We&#39;ll run for 1 blade pass, 20 time steps per blade pass.
num_blade_pass = 1
num_src_times_blade_pass = 20

# Get the time levels we&#39;ll run.
# First, get the blade passing period.
bpp = 1/(B/(2*pi)*omega)  # 1/(B blade_passes/rev * 1 rev / (2*pi rad) * omega rad/s)

# Now we can get the total period of source time we&#39;ll run over.
period_src = num_blade_pass*bpp

# And the number of source times.
num_src_times = num_src_times_blade_pass * num_blade_pass

# We know the total time period and number of source times, so we can get the time step.
dt = period_src/num_src_times

# We&#39;ll arbitrarily start at time 0.0 seconds.
t0 = 0.0

# And now we can finally get each source time.
src_times = t0 .+ (0:num_src_times-1).*dt

# Now let&#39;s define the coordinate system.
# I&#39;m going to do my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# And the blades will be rotating about the positive x axis at a rate of `omega`.
rot_trans = SteadyRotXTransformation(t0, omega, 0.0)

# The hub/rotation axis of the blades will start at the origin at time `t0`, and translate in the positive x direction at a speed of `Vinf`.
y0_hub = @SVector [0.0, 0.0, 0.0]  # m
v0_hub = @SVector [Vinf, 0.0, 0.0] # m/s
const_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)

# Now I can put the two transformations together:
trans = compose.(src_times, Ref(const_vel_trans), Ref(rot_trans))

# Azimuthal offset for each blade.
θs = (0:(B-1)) .* (2*pi/B)

# For the boundary layer we want to use untripped for the 95% of the blade from the hub to almost tip, and then tripped for the last 5% of the blade at the tip.
# First figure out how many of each we&#39;ll actually have with the `num_radial = 50` radial stations.
num_untripped = Int(round(0.95*num_radial))
num_tripped = num_radial - num_untripped
# Now create a length-`num_radial` vector of untripped and then tripped boundary layer objects.
bls = vcat(fill(AcousticAnalogies.UntrippedN0012BoundaryLayer(), num_untripped), fill(AcousticAnalogies.TrippedN0012BoundaryLayer(), num_tripped))

# But we&#39;ll always use the untripped boundary layer with LBLVS.
bl_lblvs = AcousticAnalogies.UntrippedN0012BoundaryLayer()

# I don&#39;t see any discussion for what type of tip was used for the tip vortex noise.
# The flat tip seems to match the PAS+ROTONET+BARC predictions well.
blade_tip = AcousticAnalogies.FlatTip()

# Paper doesn&#39;t specify the microphone used for Figure 24, but earlier at the beginning of &quot;C. Noise Characteristics and Trends&quot; there is this:
#   &gt; For the purposes of this paper, presented acoustic spectra will correspond to an observer located −35° below the plane of the rotor (microphone 5).
# So I&#39;ll just assume that holds for Figure 24.
# For the coordinate system, I&#39;m doing my usual thing, which is to have the freestream velocity pointed in the negative x direction, and thus the blades will be translating in the positive x direction.
# The observer (microphone 5) is 35 deg behind/downstream of the rotor rotation plane, so this should be good.
# But it will of course be moving with the same freestream in the positive x direction.
r_obs = 2.27 # meters
theta_obs = -35*pi/180
# The observer is moving in the positive x direction at Vinf, at the origin at time t0.
t0_obs = 0.0
x0_obs = @SVector [r_obs*sin(theta_obs), r_obs*cos(theta_obs), 0.0]
v_obs = @SVector [Vinf, 0.0, 0.0]
obs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)

# Reshape the inputs to the source element constructors so that everything will line up with (num_times, num_radial, num_blades).
θs_rs = reshape(θs, 1, 1, :)
radii_rs = reshape(radii, 1, :, 1)
dradii_rs = reshape(dradii, 1, :, 1)
# chord_rs = reshape(chord, 1, :, 1)
twist_rs = reshape(twist, 1, :, 1)
# hs_rs = reshape(hs, 1, :, 1)
# Psis_rs = reshape(Psis, 1, :, 1)
Us_rs = reshape(U, 1, :, 1)
alphas_rs = reshape(alpha, 1, :, 1)
bls_rs = reshape(bls, 1, :, 1)

# Separate things into tip and no-tip.
radii_rs_no_tip = @view radii_rs[:, begin:end-1, :]
dradii_rs_no_tip = @view dradii_rs[:, begin:end-1, :]
twist_rs_no_tip = @view twist_rs[:, begin:end-1, :]
Us_rs_no_tip = @view Us_rs[:, begin:end-1, :]
alphas_rs_no_tip = @view alphas_rs[:, begin:end-1, :]
bls_rs_no_tip = @view bls_rs[:, begin:end-1, :]

radii_rs_with_tip = @view radii_rs[:, end:end, :]
dradii_rs_with_tip = @view dradii_rs[:, end:end, :]
twist_rs_with_tip = @view twist_rs[:, end:end, :]
Us_rs_with_tip = @view Us_rs[:, end:end, :]
alphas_rs_with_tip = @view alphas_rs[:, end:end, :]
bls_rs_with_tip = @view bls_rs[:, end:end, :]

positive_x_rotation = true
ses_no_tip = CombinedNoTipBroadbandSourceElement.(asound, nu, radii_rs_no_tip, θs_rs, dradii_rs_no_tip, chord, twist_rs_no_tip, h, Psi, Us_rs_no_tip, alphas_rs_no_tip, src_times, dt, bls_rs_no_tip, positive_x_rotation) .|&gt; trans
ses_with_tip = CombinedWithTipBroadbandSourceElement.(asound, nu, radii_rs_with_tip, θs_rs, dradii_rs_with_tip, chord, twist_rs_with_tip, h, Psi, Us_rs_with_tip, alphas_rs_with_tip, src_times, dt, bls_rs_with_tip, Ref(blade_tip), positive_x_rotation) .|&gt; trans

# Put the source elements together:
ses = cat(ses_no_tip, ses_with_tip; dims=2)

# Need to do the LBLVS with the untripped boundary layer.
ses_lblvs = AcousticAnalogies.LBLVSSourceElement.(asound, nu, radii_rs, θs_rs, dradii_rs, chord, twist_rs, Us_rs, alphas_rs, src_times, dt, Ref(bl_lblvs), positive_x_rotation) .|&gt; trans

# The predictions in Figure 24b appear to be on 1/3 octave, ranging from about 200 Hz to 60,000 Hz.
# But let&#39;s expand the range of source frequencies to account for Doppler shifting.
freqs_src = AcousticMetrics.ExactProportionalBands{3, :center}(10.0, 200000.0)
freqs_obs = AcousticMetrics.ExactProportionalBands{3, :center}(200.0, 60000.0)

# Now we can do a noise prediction.
bpm_outs = AcousticAnalogies.noise.(ses, Ref(obs), Ref(freqs_src))
pbs_lblvss = AcousticAnalogies.noise.(ses_lblvs, Ref(obs), Ref(freqs_src))

# This seperates out the noise prediction for each source-observer combination into the different sources.
pbs_tblte_ps = AcousticAnalogies.pbs_pressure.(bpm_outs)
pbs_tblte_ss = AcousticAnalogies.pbs_suction.(bpm_outs)
pbs_tblte_alphas = AcousticAnalogies.pbs_alpha.(bpm_outs)
pbs_tebs = AcousticAnalogies.pbs_teb.(bpm_outs)
pbs_tips = AcousticAnalogies.pbs_tip.(bpm_outs[:, end:end, :])

# Now, need to combine each broadband noise prediction.
# The time axis the axis over which the time varies for each source.
time_axis = 1
pbs_pressure = AcousticMetrics.combine(pbs_tblte_ps, freqs_obs, time_axis)
pbs_suction = AcousticMetrics.combine(pbs_tblte_ss, freqs_obs, time_axis)
pbs_alpha = AcousticMetrics.combine(pbs_tblte_alphas, freqs_obs, time_axis)
pbs_teb = AcousticMetrics.combine(pbs_tebs, freqs_obs, time_axis)
pbs_tip = AcousticMetrics.combine(pbs_tips, freqs_obs, time_axis)
pbs_lblvs = AcousticMetrics.combine(pbs_lblvss, freqs_obs, time_axis)

# Now I need to account for the fact that Figure 24b is actually comparing to narrowband experimental data with a frequency spacing of 20 Hz.
# So, to do that, I need to multiply the mean-squared pressure by Δf_nb/Δf_pbs, where `Δf_nb` is the 20 Hz narrowband and `Δf_pbs` is the bandwidth of each 1/3-octave proportional band.
# I think the paper describes that, right?
# Right, here&#39;s something:
#
#   &gt; The current prediction method is limited to one-third octave bands, but it is compared to the narrowband experiment with Δf = 20 Hz.
#   &gt; This is done by dividing the energy from the one-third octave bands by the number of bands in Δf = 20 Hz.
#
# So, `Δf_pbs/Δf_nb` would represent the number of `Δf_nb`-width bands that could fit in a proportional band of bin width `Δf_pbs`.
# And then I&#39;m dividing by that.
# So that seems like the right thing.
# So, first thing is to get the proportional band spacing.
freqs_l = AcousticMetrics.lower_bands(freqs_obs)
freqs_u = AcousticMetrics.upper_bands(freqs_obs)
df_pbs = freqs_u .- freqs_l

# Also need the experimental narrowband spacing.
df_nb = 20.0
# Now multiply each by that.
nb_pressure = pbs_pressure .* df_nb ./ df_pbs
nb_suction = pbs_suction .* df_nb ./ df_pbs
nb_alpha = pbs_alpha .* df_nb ./ df_pbs
nb_lblvs = pbs_lblvs .* df_nb ./ df_pbs
nb_teb = pbs_teb .* df_nb ./ df_pbs
nb_tip = pbs_tip .* df_nb ./ df_pbs

# Now I want the SPL, which should just be this:
pref = 20e-6
spl_pressure = 10 .* log10.(nb_pressure./(pref^2))
spl_suction = 10 .* log10.(nb_suction./(pref^2))
spl_alpha = 10 .* log10.(nb_alpha./(pref^2))
spl_lblvs = 10 .* log10.(nb_lblvs./(pref^2))
spl_teb = 10 .* log10.(nb_teb./(pref^2))
spl_tip = 10 .* log10.(nb_tip./(pref^2))

# Now I should be able to compare to the BARC data.
# Need to read it in first.
data_pressure_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-TBL-TE-pressure.csv&quot;), &#39;,&#39;)
freq_pressure_barc = data_pressure_barc[:, 1]
spl_pressure_barc = data_pressure_barc[:, 2]

data_suction_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-TBL-TE-suction.csv&quot;), &#39;,&#39;)
freq_suction_barc = data_suction_barc[:, 1]
spl_suction_barc = data_suction_barc[:, 2]

data_separation_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-separation.csv&quot;), &#39;,&#39;)
freq_separation_barc = data_separation_barc[:, 1]
spl_separation_barc = data_separation_barc[:, 2]

data_lblvs_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-LBLVS.csv&quot;), &#39;,&#39;)
freq_lblvs_barc = data_lblvs_barc[:, 1]
spl_lblvs_barc = data_lblvs_barc[:, 2]

data_teb_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-BVS.csv&quot;), &#39;,&#39;)
freq_teb_barc = data_teb_barc[:, 1]
spl_teb_barc = data_teb_barc[:, 2]

data_tip_barc = readdlm(joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;bpm_data&quot;, &quot;pettingill_acoustic_performance_characteristics_of_ideally_twisted_rotor_in_hover_2021&quot;, &quot;figure24b-tip_vortex_shedding.csv&quot;), &#39;,&#39;)
freq_tip_barc = data_tip_barc[:, 1]
spl_tip_barc = data_tip_barc[:, 2]

# Now let&#39;s plot.
fig = Figure()
ax1 = fig[2, 1] = Axis(fig, xlabel=&quot;frequency, Hz&quot;, ylabel=&quot;SPL (dB Ref: 20 μPa), Δf = 20 Hz&quot;, xscale=log10, xticks=[10^3, 10^4], xminorticksvisible=true, xminorgridvisible=true, xminorticks=IntervalsBetween(9), yticks=10:10:70)#, aspect=3)

s_pressure = scatter!(ax1, freq_pressure_barc, spl_pressure_barc, color=:blue, marker=:rtriangle)
s_suction = scatter!(ax1, freq_suction_barc, spl_suction_barc, color=:red, marker=:ltriangle)
s_separation = scatter!(ax1, freq_separation_barc, spl_separation_barc, color=:yellow, marker=:diamond)
s_lblvs = scatter!(ax1, freq_lblvs_barc, spl_lblvs_barc, color=:purple, marker=:rect)
s_blunt = scatter!(ax1, freq_teb_barc, spl_teb_barc, color=:green, marker=:star6)
s_tip = scatter!(ax1, freq_tip_barc, spl_tip_barc, color=:cyan, marker=:circle)

l_pressure = lines!(ax1, freqs_obs, spl_pressure, color=:blue)
l_suction = lines!(ax1, freqs_obs, spl_suction, color=:red)
l_alpha = lines!(ax1, freqs_obs, spl_alpha, color=:yellow)
l_lblvs = lines!(ax1, freqs_obs, spl_lblvs, color=:purple)
l_teb = lines!(ax1, freqs_obs, spl_teb, color=:green)
l_tip = lines!(ax1, freqs_obs, spl_tip, color=:cyan)

xlims!(ax1, 2e2, 6e4)
ylims!(ax1, 0.0, 50.0)


leg = Legend(fig[1, 1], [
        [s_pressure, l_pressure],
        [s_suction, l_suction],
        [s_separation, l_alpha],
        [s_lblvs, l_lblvs],
        [s_blunt, l_teb],
        [s_tip, l_tip],
    ],
    [
         &quot;TBLTE-Pressure&quot;,
         &quot;TBLTE-Suction&quot;,
         &quot;Separation&quot;,
         &quot;LBLVS&quot;,
         &quot;BVS&quot;,
         &quot;Tip&quot;,
    ]; orientation=:horizontal, tellwidth=false, tellheight=true, nbanks=2)

text!(ax1, 210, 44; text=&quot;markers: PAS+ROTONET+BARC\nlines: CCBlade.jl+AcousticAnalogies.jl&quot;)

save(&quot;figure24b-spl-barc.png&quot;, fig)</code></pre><p><img src="../figure24b-spl-barc.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../itr_tests1/">« Ideally Twisted Rotor Tests</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 17 April 2025 19:26">Thursday 17 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
