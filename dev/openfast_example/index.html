<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OpenFAST Example · AcousticAnalogies.jl</title><meta name="title" content="OpenFAST Example · AcousticAnalogies.jl"/><meta property="og:title" content="OpenFAST Example · AcousticAnalogies.jl"/><meta property="twitter:title" content="OpenFAST Example · AcousticAnalogies.jl"/><meta name="description" content="Documentation for AcousticAnalogies.jl."/><meta property="og:description" content="Documentation for AcousticAnalogies.jl."/><meta property="twitter:description" content="Documentation for AcousticAnalogies.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AcousticAnalogies.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../guided_example/">Guided Example</a></li><li><a class="tocitem" href="../ccblade_example/">CCBlade.jl Example</a></li><li><a class="tocitem" href="../writevtk_support/">WriteVTK.jl Support</a></li><li class="is-active"><a class="tocitem" href>OpenFAST Example</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Inputs"><span>Inputs</span></a></li><li><a class="tocitem" href="#Constructing-the-Source-Elements"><span>Constructing the Source Elements</span></a></li><li><a class="tocitem" href="#Defining-the-Observer"><span>Defining the Observer</span></a></li><li><a class="tocitem" href="#Visualization-with-VTK-Files"><span>Visualization with VTK Files</span></a></li><li><a class="tocitem" href="#Noise-Prediction"><span>Noise Prediction</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../sqa/">Software Quality Assurance</a></li><li><a class="tocitem" href="../bpm_tests1/">BPM Airfoil Self-Noise Tests</a></li><li><a class="tocitem" href="../bpm_tests2/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../bpm_tests3/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../itr_tests1/">Ideally Twisted Rotor Tests</a></li><li><a class="tocitem" href="../itr_tests2/">Ideally Twisted Rotor Tests, Cont.</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>OpenFAST Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OpenFAST Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl/blob/main/docs/src/openfast_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Compact-Formulation-1A-OpenFAST-Example"><a class="docs-heading-anchor" href="#Compact-Formulation-1A-OpenFAST-Example">Compact Formulation 1A OpenFAST Example</a><a id="Compact-Formulation-1A-OpenFAST-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Compact-Formulation-1A-OpenFAST-Example" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This example loads a .out file generated by the popular aeroserohydroelastic solver <a href="https://github.com/OpenFAST/openfast">OpenFAST</a>, which is released by the U.S. National Renewable Energy Laboratory to simulate wind turbines,  and then constructs the types used by AcousticAnalogies.jl for acoustic predictions.  The example simulates the acoustic emissions of the 3.4MW land-based reference wind turbine released by the International Wind Energy Agency. The OpenFAST model is available at https://github.com/IEAWindTask37/IEA-3.4-130-RWT.</p><p>We start by loading Julia dependencies, which are available in the General registry</p><pre><code class="language-julia hljs">using AcousticAnalogies: AcousticAnalogies
using AcousticMetrics: AcousticMetrics
using ColorSchemes: colorschemes
using FillArrays: FillArrays, getindex_value
using GLMakie
using KinematicCoordinateTransformations: SteadyRotYTransformation
using StaticArrays: @SVector</code></pre><h2 id="Inputs"><a class="docs-heading-anchor" href="#Inputs">Inputs</a><a id="Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Inputs" title="Permalink"></a></h2><p>Next, we set the user-defined inputs:</p><ul><li>number of blades, usually 3 for modern wind turbines</li><li>hub radius in m, it is specified in the ElastoDyn main input file of OpenFAST</li><li>blade spanwise grid in m and the corresponding chord, also in m. The two arrays are specified in the AeroDyn15 blade input file</li><li>Observer location in the global coordinate frame (located at the rotor center, x points downwind, z points vertically up, and y points sideways). In this case we picked the IEC-prescribed location (turbine height on the ground) by specifying the hub height of 110 m.</li><li>Air density and speed of sound</li><li>Path to the OpenFAST .out file. The file must contain these channels: Time (always available), Wind1VelX from InflowWind, RotSpeed from ElastoDyn, Nodal outputs Fxl and Fyl from AeroDyn15. the file is available in the repo under <code>test/gen_test_data/openfast_data</code>.</li></ul><pre><code class="language-julia hljs"># num_blades = 3
Rhub = 2.
BlSpn = [0.0000e+00, 2.1692e+00, 4.3385e+00, 6.5077e+00, 8.6770e+00, 1.0846e+01, 1.3015e+01, 1.5184e+01,
    1.7354e+01, 1.9523e+01, 2.1692e+01, 2.3861e+01, 2.6031e+01, 2.8200e+01, 3.0369e+01, 3.2538e+01,
    3.4708e+01, 3.6877e+01, 3.9046e+01, 4.1215e+01, 4.3385e+01, 4.5554e+01, 4.7723e+01,
    4.9892e+01, 5.2062e+01, 5.4231e+01, 5.6400e+01, 5.8570e+01, 6.0739e+01, 6.2908e+01]
Chord = [2.600e+00, 2.645e+00, 3.020e+00, 3.437e+00, 3.781e+00, 4.036e+00, 4.201e+00,
    4.284e+00, 4.288e+00, 4.223e+00, 4.098e+00, 3.923e+00, 3.709e+00, 3.468e+00, 3.220e+00,
    2.986e+00, 2.770e+00, 2.581e+00, 2.412e+00, 2.266e+00, 2.142e+00, 2.042e+00, 1.964e+00,
    1.909e+00, 1.870e+00, 1.807e+00, 1.666e+00, 1.387e+00, 9.172e-01, 1.999e-01]
file_path = joinpath(@__DIR__, &quot;..&quot;, &quot;..&quot;, &quot;test&quot;, &quot;gen_test_data&quot;, &quot;openfast_data&quot;, &quot;IEA-3.4-130-RWT.out&quot;)
HH = 110. # m
RSpn = BlSpn .+ Rhub
x0 = @SVector [HH .+ RSpn[end], 0.0, -HH]
rho = 1.225  # kg/m^3
c0 = 340.0  # m/s</code></pre><p>For the monopole/thickness noise, we need the cross-sectional area at each radial station. If we know the cross-sectional area per chord squared, we can find the cross-sectional area this way:</p><pre><code class="language-julia hljs"># Cross-sectional area of each element in m**2. This is taking a bit of a shortcut—the value of `cs_area_over_chord_squared` does not actually correspond to the IEAWindTask37 turbine blade.
cs_area_over_chord_squared = 0.064
cs_area = cs_area_over_chord_squared .* Chord.^2</code></pre><p>Next, we&#39;ll use the <a href="../api/#AcousticAnalogies.read_openfast_file"><code>read_openfast_file</code></a> function to read the OpenFAST output file:</p><pre><code class="language-julia hljs"># Read the data from the file and create an `OpenFASTData` object, a simple struct with fields like `time`, `omega`, `axial_loading`, etc.
data = AcousticAnalogies.read_openfast_file(file_path, RSpn, cs_area; average_freestream_vel=true, average_omega=true)</code></pre><p>That will read the data in the file, but also do a bit of processing necessary for an acoustic prediction.  Specifically, it will...</p><ul><li>interpolate the cross-sectional area and loading from the blade element interfaces to the cell centers,</li><li>use second-order finite differences to differentiate the loading with respect to time,</li><li>average the freestream velocity and RPM (if <code>average_freestream_vel</code> or <code>average_omega</code> keyword arguments are <code>true</code>)</li></ul><p>The <a href="../api/#AcousticAnalogies.read_openfast_file"><code>read_openfast_file</code> doc string</a> has more information.</p><p>The output of <code>read_openfast_file</code> is a <code>OpenFASTData</code> <code>struct</code> that has fields like <code>time</code>, <code>omega</code>, <code>axial_loading</code>, etc. that are read from the output file, and also fields like <code>radii_mid</code>, <code>circum_loading_mid_dot</code> that are created after the output file is read. Check out the <a href="../api/#AcousticAnalogies.OpenFASTData"><code>OpenFASTData</code> doc string</a> for a list of all the fields.</p><p>We can get the averaged rotation rate value from the <code>OpenFASTData</code> <code>struct</code> this way:</p><pre><code class="language-julia hljs">omega_avg = getindex_value(data.omega)
@show omega_avg</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">omega_avg = 0.8509447378264272</code></pre><p>(When averaging rotation rate or freestream velocity, <code>read_openfast_file</code> uses a <a href="https://juliaarrays.github.io/FillArrays.jl/stable/#FillArrays.Fill"><code>Fill</code></a> <code>struct</code> from the <a href="https://github.com/JuliaArrays/FillArrays.jl"><code>FillArrays.jl</code></a> package to lazily represent the average <code>omega</code> value as a length-<code>num_times</code> <code>Vector</code>, and <a href="https://juliaarrays.github.io/FillArrays.jl/stable/#FillArrays.getindex_value"><code>getindex_value</code></a> is a function from <code>FillArrays.jl</code> that returns that single averaged value. Could have also just indexed the <code>data.omega</code> array at the first value, or last, etc..)</p><pre><code class="language-julia hljs">@show data.omega[1] data.omega[8] data.omega[end]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">data.omega[1] = 0.8509447378264272
data.omega[8] = 0.8509447378264272
data.omega[end] = 0.8509447378264272</code></pre><p>Before we actually try an acoustic prediction, let&#39;s have a look at the loading. We&#39;ll use the Makie plotting package to make the plots, and only plot 1 out of every 500 time steps (as seen in the <code>for tidx</code> line):</p><pre><code class="language-julia hljs">ntimes_loading = size(data.axial_loading_mid, 1)
fig = Figure()
ax11 = fig[1, 1] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fx (N/m)&quot;, title=&quot;blade 1&quot;)
ax21 = fig[2, 1] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fy (N/m)&quot;)
ax12 = fig[1, 2] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fx (N/m)&quot;, title=&quot;blade 2&quot;)
ax22 = fig[2, 2] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fy (N/m)&quot;)
ax13 = fig[1, 3] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fx (N/m)&quot;, title=&quot;blade 3&quot;)
ax23 = fig[2, 3] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;Fy (N/m)&quot;)
num_blades = data.num_blades
colormap = colorschemes[:viridis]
time = data.time
sim_length_s = time[end] - time[begin]
for tidx in 1:500:ntimes_loading
    cidx = (time[tidx] - time[1])/sim_length_s
    l1 = lines!(ax11, data.radii_mid, data.axial_loading_mid[tidx,:,1], label =&quot;b1&quot;, color=colormap[cidx])
    l1 = lines!(ax12, data.radii_mid, data.axial_loading_mid[tidx,:,2], label =&quot;b2&quot;, color=colormap[cidx])
    l1 = lines!(ax13, data.radii_mid, data.axial_loading_mid[tidx,:,3], label =&quot;b3&quot;, color=colormap[cidx])
    l2 = lines!(ax21, data.radii_mid, data.circum_loading_mid[tidx,:,1], label =&quot;b1&quot;, color=colormap[cidx])
    l2 = lines!(ax22, data.radii_mid, data.circum_loading_mid[tidx,:,2], label =&quot;b2&quot;, color=colormap[cidx])
    l2 = lines!(ax23, data.radii_mid, data.circum_loading_mid[tidx,:,3], label =&quot;b3&quot;, color=colormap[cidx])
end

linkxaxes!(ax21, ax11)
linkxaxes!(ax12, ax11)
linkxaxes!(ax22, ax11)
linkxaxes!(ax13, ax11)
linkxaxes!(ax23, ax11)

linkyaxes!(ax12, ax11)
linkyaxes!(ax13, ax11)

linkyaxes!(ax22, ax21)
linkyaxes!(ax23, ax21)

hidexdecorations!(ax11, grid=false)
hidexdecorations!(ax12, grid=false)
hidexdecorations!(ax13, grid=false)
hideydecorations!(ax12, grid=false)
hideydecorations!(ax13, grid=false)
hideydecorations!(ax22, grid=false)
hideydecorations!(ax23, grid=false)

cbar = fig[:, 4] = Colorbar(fig; limits=(time[begin], time[end]), colormap=:viridis, label=&quot;time (sec)&quot;)

save(joinpath(@__DIR__, &quot;openfast_example_loading.png&quot;), fig)</code></pre><p><img src="../openfast_example_loading.png" alt="Loading"/></p><p>The x axis of each subplot is the radial position along the blade, from hub to tip. The top three plots show the axial loading, bottom three the circumferential, and there&#39;s one column for each blade. And the colorbar indicates the simulation time. The plot shows significant unsteadiness, which is cool to see.</p><p>We can also plot the loading time derivative in a similar form:</p><pre><code class="language-julia hljs">ntimes_loading = size(data.axial_loading_mid_dot, 1)
fig = Figure()
ax11 = fig[1, 1] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fx/∂t (N/(m*s))&quot;, title=&quot;blade 1&quot;)
ax21 = fig[2, 1] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fy/∂t (N/(m*s))&quot;)
ax12 = fig[1, 2] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fx/∂t (N/(m*s))&quot;, title=&quot;blade 2&quot;)
ax22 = fig[2, 2] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fy/∂t (N/(m*s))&quot;)
ax13 = fig[1, 3] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fx/∂t (N/(m*s))&quot;, title=&quot;blade 3&quot;)
ax23 = fig[2, 3] = Axis(fig, xlabel=&quot;Span Position (m)&quot;, ylabel=&quot;∂Fy/∂t (N/(m*s))&quot;)
num_blades = data.num_blades
colormap = colorschemes[:viridis]
time = data.time
sim_length_s = time[end] - time[begin]
for tidx in 1:500:ntimes_loading
    cidx = (time[tidx] - time[1])/sim_length_s
    l1 = lines!(ax11, data.radii_mid, data.axial_loading_mid_dot[tidx,:,1], label =&quot;b1&quot;, color=colormap[cidx])
    l1 = lines!(ax12, data.radii_mid, data.axial_loading_mid_dot[tidx,:,2], label =&quot;b2&quot;, color=colormap[cidx])
    l1 = lines!(ax13, data.radii_mid, data.axial_loading_mid_dot[tidx,:,3], label =&quot;b3&quot;, color=colormap[cidx])
    l2 = lines!(ax21, data.radii_mid, data.circum_loading_mid_dot[tidx,:,1], label =&quot;b1&quot;, color=colormap[cidx])
    l2 = lines!(ax22, data.radii_mid, data.circum_loading_mid_dot[tidx,:,2], label =&quot;b2&quot;, color=colormap[cidx])
    l2 = lines!(ax23, data.radii_mid, data.circum_loading_mid_dot[tidx,:,3], label =&quot;b3&quot;, color=colormap[cidx])
end

linkxaxes!(ax21, ax11)
linkxaxes!(ax12, ax11)
linkxaxes!(ax22, ax11)
linkxaxes!(ax13, ax11)
linkxaxes!(ax23, ax11)

linkyaxes!(ax12, ax11)
linkyaxes!(ax13, ax11)

linkyaxes!(ax22, ax21)
linkyaxes!(ax23, ax21)

hidexdecorations!(ax11, grid=false)
hidexdecorations!(ax12, grid=false)
hidexdecorations!(ax13, grid=false)
hideydecorations!(ax12, grid=false)
hideydecorations!(ax13, grid=false)
hideydecorations!(ax22, grid=false)
hideydecorations!(ax23, grid=false)

cbar = fig[:, 4] = Colorbar(fig; limits=(time[begin], time[end]), colormap=:viridis, label=&quot;time (sec)&quot;)

save(joinpath(@__DIR__, &quot;openfast_example_loading_dot.png&quot;), fig)</code></pre><p><img src="../openfast_example_loading_dot.png" alt="Loading Time Derivative"/></p><h2 id="Constructing-the-Source-Elements"><a class="docs-heading-anchor" href="#Constructing-the-Source-Elements">Constructing the Source Elements</a><a id="Constructing-the-Source-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-Source-Elements" title="Permalink"></a></h2><p>Now, the next step is to turn the OpenFAST data into source elements. This step is pretty easy, since there is a function called <a href="../api/#AcousticAnalogies.f1a_source_elements_openfast"><code>f1a_source_elements_openfast</code></a> that takes the <code>OpenFASTData</code> <code>struct</code> and a few other parameters and will create the source elements for us. But first we need to think about the coordinate system we&#39;d like our source elements to be in. Eventually, we want the turbine blades to be rotating about the positive x axis, with the freestream velocity pointing in the positive x axis direction. But there are two things we need to account for to make that happen:</p><ul><li><p>To do a proper noise prediction, AcousticAnalogies.jl needs the source elements&#39; motion to be defined in a reference frame relative to the ambient fluid, not the ground. Put another way, we need to manipulate the source elements in a way so that it appears that there is no freestream velocity—that the ambient fluid is stationary. So instead of having blade elements that are only rotating about a fixed hub position relative to the ground in a freestream pointed in the positive x direction, we will have the blade elements translate in the <em>negative</em> x direction as they rotate, with no freestream velocity.</p></li><li><p>The <code>f1a_source_elements_openfast</code> routine puts the source elements in the Standard AcousticAnalogies.jl Reference Frame™, where the source elements </p><ul><li>begin with the hub (rotation center) at coordinate system origin at source time <code>t = 0</code>,</li><li>rotate about either the positive x or negative x axis (depending on the value of the <code>positive_x_rotation</code> argument),</li><li>translate in the positive x direction.</li></ul></li></ul><p>So, to make all this work, we&#39;ll initially have the source elements translate in the positive x direction (as required by <code>f1a_source_elements_openfast</code>) and rotate about the <em>negative</em> x axis. Then we&#39;ll rotate the source elements 180° about the y axis, which will mean they will be translating in the negative x axis, rotating about the positive x axis, just like what we intend.</p><p>So, here&#39;s the first step: create the source elements from the <code>OpenFASTData</code> <code>struct</code>, where they&#39;ll be rotating about the negative x axis, translating along the positive x axis.</p><pre><code class="language-julia hljs">positive_x_rotation = false
ses_before_roty = AcousticAnalogies.f1a_source_elements_openfast(data, rho, c0, positive_x_rotation)</code></pre><p>The <code>f1a_source_elements_openfast</code> returns an array of <a href="../api/#AcousticAnalogies.CompactF1ASourceElement-NTuple{10, Any}"><code>CompactF1ASourceElement</code></a> <code>structs</code>. The array is of size <code>(num_times, num_radial, num_blades)</code>, where <code>ses[i, j, k]</code> refers to the source element of the <code>i</code>th time step, <code>j</code>th radial position, and <code>k</code>th blade:</p><pre><code class="language-julia hljs">@show size(ses_before_roty)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">size(ses_before_roty) = (6001, 29, 3)</code></pre><p>Now we&#39;ll rotate each source element 180° about the positive y axis.</p><pre><code class="language-julia hljs"># Create the object from KinematicCoordinateTransformations.jl defining the 180° rotation about the y axis.
rot180degy = SteadyRotYTransformation(0, 0, pi)

# Now rotate the source elements.
ses = rot180degy.(ses_before_roty)

# Could have combined all that in one line, i.e.,
# ses = rot180degy.(AcousticAnalogies.f1a_source_elements_openfast(data, rho, c0, positive_x_rotation))</code></pre><h2 id="Defining-the-Observer"><a class="docs-heading-anchor" href="#Defining-the-Observer">Defining the Observer</a><a id="Defining-the-Observer-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Observer" title="Permalink"></a></h2><p>The last thing we need before we can perform the noise prediction is an acoustic observer. The observer is just the computational equivalent of the microphone—a fictitious, possibly moving point in space that will &quot;receive&quot; the noise produced by each source element. In this case we picked the IEC-prescribed location (turbine height on the ground) by specifying the hub height of 110 m. So we need the observer to be 110 m below the hub. We&#39;ll also have the observer positioned downstream of the turbine rotation plane by a certain amount.</p><pre><code class="language-julia hljs">x0_obs = @SVector [HH + RSpn[end], 0.0, -HH]</code></pre><p>(The <code>@SVector</code> macro creates a statically-size vector using the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> package, which is good for performance but not required.)</p><p>Now, just like with the source elements, we need to define the motion of the observer relative to the fluid, not the ground. So, we&#39;ll use the same trick that we used with the source elements: have the observer translate in the negative x direction to account for the freestream velocity that&#39;s pointed in the positive x direction:</p><pre><code class="language-julia hljs"># Get the average freestream velocity from the OpenFAST data.
v_avg = getindex_value(data.v)

# Create a vector defining the velocity of the observer.
v_obs = @SVector [-v_avg, 0, 0]</code></pre><p>Since the observer is moving, its position is obviously changing. So the <code>x0_obs</code> will be the position of the observer at the start of the simulation, at the first source time level of the source elements. We can get that first source time level this way:</p><pre><code class="language-julia hljs">t0_obs = data.time[1]</code></pre><p>Now we have enough information to create the observer object:</p><pre><code class="language-julia hljs">obs = AcousticAnalogies.ConstVelocityAcousticObserver(t0_obs, x0_obs, v_obs)</code></pre><p>That says that we want our observer to start at the location <code>x0_obs</code> at time <code>t0_obs</code>, and then move with constant velocity <code>v_obs</code> forever after. After creating the observer, we can query its location at any time value after this way:</p><pre><code class="language-julia hljs">@show obs(t0_obs) # should be equal to `x0_obs`
@show obs(t0_obs + 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">obs(t0_obs) = [174.90800000000002, 0.0, -110.0]
obs(t0_obs + 1) = [167.90800000000002, 0.0, -110.0]</code></pre><h2 id="Visualization-with-VTK-Files"><a class="docs-heading-anchor" href="#Visualization-with-VTK-Files">Visualization with VTK Files</a><a id="Visualization-with-VTK-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-with-VTK-Files" title="Permalink"></a></h2><p>That was a lot. How will we know we did all that correctly? The answer is: write out the source elements and observer we just created to VTK files, and then visualize them with our favorite visualization software (ParaView at the moment).</p><p>The function we want is <a href="../api/#AcousticAnalogies.to_paraview_collection-Tuple{Any, AbstractArray{&lt;:AcousticAnalogies.AbstractCompactSourceElement}}"><code>to_paraview_collection</code></a>. Using it is simple:</p><pre><code class="language-julia hljs">AcousticAnalogies.to_paraview_collection(&quot;openfast_example_with_obs&quot;, (ses,); observers=(obs,))</code></pre><p>(This form of <code>to_paraview_collection</code> expects multiple arrays of source elements and multiple observers. But here we just have one array of source elements (<code>ses</code>) and one observer (<code>obs</code>), so we wrap each in a single-entry tuple, i.e., <code>(ses,)</code> and <code>(obs,)</code>.)</p><p>That will write out a bunch of VTK files showing the motion of the source elements and the observer, all starting with the <code>name</code> argument to the function (<code>openfast_example_with_obs</code> here). The one to focus on is <code>openfast_example_with_obs.pvd</code>, a <a href="https://www.paraview.org/Wiki/ParaView/Data_formats#PVD_File_Format">ParaView data file</a> that describes how all the many VTK files that <code>to_paraview_collection</code> writes out fit together.</p><p>The VTK files for the source elements will also contain all the data defined in the source element <code>struct</code>s (the loading, cross-sectional area, etc.). That&#39;s really handy for checking that the loading is in the correct direction (remember, it needs to be the loading on the fluid, i.e. exactly opposite the loading on the blades).</p><p>To that end, here&#39;s an animation of the blades and observer, with the blades colored by the loading per unit span in the y direction:</p><p><img src="../assets/openfast_example_with_obs-iso_view-loading_y-0to6000-compressed.gif" alt="LoadingY, Iso"/></p><p>Things look pretty good: the observer (i.e. the gray sphere) and the blades are all translating in the negative x direction, and the blades are rotating about the positive x axis. (The gray smearing along the path of the observer is an artifact of the compression process the <code>gif</code> went through to make the file smaller.) The y-component of the loading also appears to be in the correction direction: for a wind turbine, we&#39;d expect the loading on the fluid to oppose the motion of the blade in the circumferential direction, which is what the animation shows.</p><p>One thing that is troubling about the previous animation is the location of the observer relative to the blades in the y direction. Since the rotor hub starts at the origin and moves along the negative x axis, and since y component of the observer position is always zero, the observer should only be offset in the x and z directions relative to the hub path. That&#39;s hard to see in the previous animation, but if we switch our perspective to be looking directly downstream (i.e., looking in the positive-x direction), everything appears as it should be:</p><p><img src="../assets/openfast_example_with_obs-downstream_view-loading_y-0to6000-compressed.gif" alt="LoadingY, Downstream"/></p><p>Both the blade hub and the observer appear to be moving in the <code>y=0</code> plane.</p><h2 id="Noise-Prediction"><a class="docs-heading-anchor" href="#Noise-Prediction">Noise Prediction</a><a id="Noise-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-Prediction" title="Permalink"></a></h2><p>Now we&#39;re finally ready to do a noise prediction! The relevant function for that is <a href="../api/#AcousticAnalogies.noise-Tuple{AcousticAnalogies.CompactF1ASourceElement, AcousticAnalogies.AbstractAcousticObserver, Any}"><code>noise</code></a>, which takes in a source element and observer and returns an <a href="../api/#AcousticAnalogies.F1AOutput"><code>F1AOutput</code></a> <code>struct</code>, representing the acoustic pressure experienced by the observer due to the source:</p><pre><code class="language-julia hljs">apth = AcousticAnalogies.noise.(ses, Ref(obs))</code></pre><p>Notice that we used a <code>.</code> after the <code>noise</code> function, which <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasts</a> the <code>noise</code> call over all source element-observer combinations. (The <code>Ref(obs)</code> makes the single observer <code>struct</code> act as a scalar during broadcasting, meaning the same observer object is passed to each <code>noise</code> call.) Because of the broadcasting, <code>apth</code> is an <code>Array</code> of <code>F1AOutput</code> <code>structs</code> with the same size as <code>ses</code>:</p><pre><code class="language-julia hljs">@show size(ses) size(apth)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">size(ses) = (6001, 29, 3)
size(apth) = (6001, 29, 3)</code></pre><p>We now have a noise prediction for each of the individual source elements in <code>ses</code> at the acoustic observer obs—specifically, <code>apth[i, j, k]</code> represents the acoustic pressure for the <code>i</code> time step, <code>j</code> radial location, and <code>k</code> blade. What we ultimately want is the total noise prediction at <code>obs</code>—we want to add all the acoustic pressures for each time level in <code>apth</code> together.  But we can&#39;t add them directly, yet, since the observer times—the time at which each source&#39;s noise reaches the observer—are not all the same. What we need to do is first interpolate the acoustic pressure time history of each source onto a common series of observer time levels, and then add them up.  We&#39;ll do this using the <a href="../api/#AcousticAnalogies.combine"><code>combine</code></a> function. First, we need to decide on the length of the observer time series and how many points it will contain. If the motion and loading of the blades was steady, then one blade pass would be sufficient, but for this example that is not the case, so we&#39;ll use a longer observer time:</p><pre><code class="language-julia hljs">rev_period = 2*pi/omega_avg
bpp = rev_period/num_blades  # blade passing period
omega_rpm = omega_avg * 60/(2*pi)
obs_time_range = sim_length_s/60*omega_rpm*bpp
num_obs_times = length(data.time)</code></pre><p>So that says that we&#39;ll have an output observer time length of <code>obs_time_range</code> with <code>num_obs_times</code> points. Note that we need to be careful to avoid extrapolation in the <code>combine</code> calculation, which will happen if the observer time specified via the <code>obs_time_range</code> and <code>num_obs_times</code> arguments to <code>combine</code> extends past the times contained in the <code>apth</code> array. That won&#39;t happen in this case, since <code>obs_time_range/sim_length_s</code> is 1/3, so the observer time range is much less than the source time range.</p><p>Now we call <code>combine</code> to get the total acoustic pressure time history:</p><pre><code class="language-julia hljs">time_axis = 1
apth_total = AcousticAnalogies.combine(apth, obs_time_range, num_obs_times, time_axis)</code></pre><p>With that, we&#39;re finally able to plot the acoustic pressure time history:</p><pre><code class="language-julia hljs">fig = Figure()
ax1 = fig[1, 1] = Axis(fig, xlabel=&quot;time, s&quot;, ylabel=&quot;monopole, Pa&quot;)
ax2 = fig[2, 1] = Axis(fig, xlabel=&quot;time, s&quot;, ylabel=&quot;dipole, Pa&quot;)
ax3 = fig[3, 1] = Axis(fig, xlabel=&quot;time, s&quot;, ylabel=&quot;total, Pa&quot;)
l1 = lines!(ax1, time, apth_total.p_m)
l2 = lines!(ax2, time, apth_total.p_d)
l3 = lines!(ax3, time, apth_total.p_m.+apth_total.p_d)
hidexdecorations!(ax1, grid=false)
hidexdecorations!(ax2, grid=false)
save(joinpath(@__DIR__, &quot;openfast-apth_total.png&quot;), fig)</code></pre><p><img src="../openfast-apth_total.png" alt="Acoustic Pressure Time History"/></p><p>The plot shows that the monopole/thickness noise is much lower than the dipole/loading noise. Wind turbine blades are relatively slender, which would tend to reduce thickness noise. Also the observer is downstream of the rotation plane, which is where loading noise is traditionally  thought to dominate (monopole/thickness noise is more significant in the rotor rotation plane, usually). (Although we didn&#39;t use the actual cross-sectional area for the blades, which directly affects the monopole/thickness noise.)</p><p>We now calculate the overall sound pressure level from the acoustic pressure time history. Next, we will calculate the narrowband spectrum. Finally, we will calculate the overall sound pressure level from the narrowband spectrum.</p><pre><code class="language-julia hljs">oaspl_from_apth = AcousticMetrics.OASPL(apth_total)
nbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)
oaspl_from_nbs = AcousticMetrics.OASPL(nbs)
@show oaspl_from_apth oaspl_from_nbs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">oaspl_from_apth = 56.899770486703346
oaspl_from_nbs = 56.899770486703346</code></pre><p>The OASPL values calculated from the acoustic pressure time history and the narrowband spectrum are the same, as they should be according to <a href="https://en.wikipedia.org/wiki/Parseval%27s_theorem">Parseval&#39;s theorem</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../writevtk_support/">« WriteVTK.jl Support</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 17 April 2025 19:26">Thursday 17 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
