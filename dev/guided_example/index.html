<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guided Example · AcousticAnalogies.jl</title><meta name="title" content="Guided Example · AcousticAnalogies.jl"/><meta property="og:title" content="Guided Example · AcousticAnalogies.jl"/><meta property="twitter:title" content="Guided Example · AcousticAnalogies.jl"/><meta name="description" content="Documentation for AcousticAnalogies.jl."/><meta property="og:description" content="Documentation for AcousticAnalogies.jl."/><meta property="twitter:description" content="Documentation for AcousticAnalogies.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AcousticAnalogies.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Guided Example</a><ul class="internal"><li><a class="tocitem" href="#1.-Define-the-Blade"><span>1. Define the Blade</span></a></li><li><a class="tocitem" href="#2.-Perform-the-Advanced-Time-Calculation"><span>2. Perform the Advanced Time Calculation</span></a></li><li><a class="tocitem" href="#3.-Perform-the-F1A-Calculation"><span>3. Perform the F1A Calculation</span></a></li><li><a class="tocitem" href="#4.-Combine-the-Acoustic-Pressures"><span>4. Combine the Acoustic Pressures</span></a></li><li class="toplevel"><a class="tocitem" href="#AcousticMetrics.jl-Support"><span>AcousticMetrics.jl Support</span></a></li></ul></li><li><a class="tocitem" href="../ccblade_example/">CCBlade.jl Example</a></li><li><a class="tocitem" href="../writevtk_support/">WriteVTK.jl Support</a></li><li><a class="tocitem" href="../openfast_example/">OpenFAST Example</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../sqa/">Software Quality Assurance</a></li><li><a class="tocitem" href="../bpm_tests1/">BPM Airfoil Self-Noise Tests</a></li><li><a class="tocitem" href="../bpm_tests2/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../bpm_tests3/">BPM Airfoil Self-Noise Tests, Cont.</a></li><li><a class="tocitem" href="../itr_tests1/">Ideally Twisted Rotor Tests</a></li><li><a class="tocitem" href="../itr_tests2/">Ideally Twisted Rotor Tests, Cont.</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guided Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guided Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OpenMDAO/AcousticAnalogies.jl/blob/main/docs/src/guided_example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="guided_example"><a class="docs-heading-anchor" href="#guided_example">Compact Formulation 1A Guided Example</a><a id="guided_example-1"></a><a class="docs-heading-anchor-permalink" href="#guided_example" title="Permalink"></a></h1><p>There are four steps to predicting propeller/rotor noise with AcousticAnalogies.jl.</p><ol><li>Define the blade&#39;s motion and loading as a function of source time</li><li>Perform the advanced time calculation</li><li>Propagate the acoustics caused by each blade section to the acoustic observer(s) using the F1A formulation</li><li>Combine all the acoustic pressures resulting from step 3 into one acoustic pressure time history</li></ol><h2 id="1.-Define-the-Blade"><a class="docs-heading-anchor" href="#1.-Define-the-Blade">1. Define the Blade</a><a id="1.-Define-the-Blade-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Define-the-Blade" title="Permalink"></a></h2><h3 id="The-Blade-Fixed-Reference-Frame"><a class="docs-heading-anchor" href="#The-Blade-Fixed-Reference-Frame">The Blade-Fixed Reference Frame</a><a id="The-Blade-Fixed-Reference-Frame-1"></a><a class="docs-heading-anchor-permalink" href="#The-Blade-Fixed-Reference-Frame" title="Permalink"></a></h3><p>We need to know what the blade is doing aerodynamically before we can predict how loud it is.  Specifically, we need to know at each radial station along each blade the</p><ul><li>position</li><li>velocity</li><li>acceleration</li><li>jerk (time derivative of acceleration)</li><li>cross-sectional area</li><li>loading per unit span</li></ul><p>all as a function of time. We&#39;ll do this first in a reference frame moving with the blades, i.e., translating and rotating with the blade geometry, that we&#39;ll call the blade-fixed reference frame.</p><p>First step is to load up <code>AcousticAnalogies.jl</code>:</p><pre><code class="language-julia hljs">using AcousticAnalogies</code></pre><p>So, for this example we&#39;ll imagine that we have a blade with radial stations that look like this:</p><pre><code class="language-julia hljs">num_blades = 2  # number of blades
Rhub = 0.10  # meters
Rtip = 1.1684  # meters
radii = [
    0.92904E-01, 0.11751, 0.15631, 0.20097,
    0.24792    , 0.29563, 0.34336, 0.39068,
    0.43727    , 0.48291, 0.52741, 0.57060,
    0.61234    , 0.65249, 0.69092, 0.72752,
    0.76218    , 0.79479, 0.82527, 0.85352,
    0.87947    , 0.90303, 0.92415, 0.94275,
    0.95880    , 0.97224, 0.98304, 0.99117,
    0.99660    , 0.99932].*Rtip</code></pre><p><code>radii</code> is a <code>Vector</code> of the distance of each blade element&#39;s center from the propeller hub, in meters.</p><p>Each of the <code>num_blades</code> blades have the same radial coordinates in the blade-fixed frame, but different angular coordinates: blade number <code>2</code> will be offset <code>180°</code> from blade number <code>1</code>.</p><pre><code class="language-julia hljs">θs = 2*pi/num_blades.*(0:(num_blades-1))</code></pre><p>So now we know where each blade element is in the blade-fixed frame: in polar coordinates, element at radial index <code>j</code> and blade <code>k</code> is at <code>radii[j]</code>, <code>θs[k]</code>.</p><p>We&#39;ll also need the length of each blade element. There is a convenience function in <code>AcousticAnalogies.jl</code> called <code>get_dradii</code> that calculates each blade element&#39;s length from the element centers and the hub and tip location:</p><pre><code class="language-julia hljs">dradii = get_dradii(radii, Rhub, Rtip)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30-element Vector{Float64}:
 0.022923858800000002
 0.03704178520000001
 0.048757332000000014
 0.05351856200000002
 0.05530037199999999
 0.055756048
 0.05552821000000002
 0.054862222000000016
 0.05388076599999991
 0.05265978800000015
 ⋮
 0.02610205600000004
 0.023204424
 0.02024252999999998
 0.017228057999999935
 0.014161008000000086
 0.011058905999999924
 0.007921751999999893
 0.004761230000000172
 0.002383535999999964</code></pre><p>The compact F1A calculation also requires the cross-sectional area of each element. In many types of propeller codes, the cross-sectional shape at each radial station is defined as having a certain standard shape (e.g., circular near the hub, a given airfoil shape elsewhere).  If we know the cross-sectional area for each relevant airfoil shape with a chord length of one, we can find the cross-sectional area for any chord length by multiplying by the squared chord length. In this example we&#39;ll assume the blade uses the same airfoil shape at each radial station, and that this airfoil has a cross-sectional area per unit chord squared of <code>0.064</code>. After defining the chord length for each radial station, we find the cross-sectional area in units of meters squared:</p><pre><code class="language-julia hljs">cs_area_over_chord_squared = 0.064
chord = [
    0.35044     , 0.28260     , 0.22105     , 0.17787     , 0.14760,
    0.12567     , 0.10927     , 0.96661E-01 , 0.86742E-01 ,
    0.78783E-01 , 0.72287E-01 , 0.66906E-01 , 0.62387E-01 ,
    0.58541E-01 , 0.55217E-01 , 0.52290E-01 , 0.49645E-01 ,
    0.47176E-01 , 0.44772E-01 , 0.42326E-01 , 0.39732E-01 ,
    0.36898E-01 , 0.33752E-01 , 0.30255E-01 , 0.26401E-01 ,
    0.22217E-01 , 0.17765E-01 , 0.13147E-01 , 0.85683E-02 ,
    0.47397E-02].*Rtip
cs_area = cs_area_over_chord_squared.*chord.^2</code></pre><p>Next, we need the loading on the blade. <code>AcousticAnalogies.jl</code> needs us to specify the loading at each radial station as a 3D vector in units of loading per unit span. But for now, let&#39;s imagine that we&#39;ve run some type of propeller aerodynamic code (I used <a href="https://github.com/byuflowlab/CCBlade.jl">CCBlade.jl</a>, FYI) and have the normal and circumferential loading as a function of radial position along the blade. The loading is in units of force per unit span (here, Newtons/meter).</p><pre><code class="language-julia hljs">fn = [32.87810395677037, 99.05130471878633, 190.1751697055377,
      275.9492967565419, 358.14423433748146, 439.64679797145624,
      520.1002808148281, 599.1445046901513, 676.2358818769462,
      751.3409657831587, 824.2087672338118, 894.4465814696498,
      961.9015451678036, 1026.0112737521583, 1086.2610633094212,
      1141.4900032393818, 1190.3376703335655, 1230.8999662260915,
      1260.375390697363, 1275.354422403355, 1271.8827617273287,
      1245.9059108698596, 1193.9967137923225, 1113.9397490286995,
      1005.273267675585, 869.4101036003673, 709.8100230053759,
      532.1946243370355, 346.53986082379265, 180.66763939805125]

fc = [26.09881302938423, 55.5216259955307, 75.84767780212506, 84.84509232798283,
      89.73045068624886, 93.02999477395113, 95.4384273852926, 97.31647535460424,
      98.81063179767507, 100.07617771995163, 101.17251941705561, 102.11543878532882,
      102.94453631586998, 103.63835661864168, 104.18877957193807, 104.51732850056433,
      104.54735678589765, 104.1688287897138, 103.20319203286938, 101.46246817378582,
      99.11692436681635, 96.49009546562475, 93.45834266417528, 89.49783586366624,
      83.87176811707455, 75.83190739325453, 64.88004605331857, 50.98243352318318,
      34.85525518071079, 19.358679206883078]</code></pre><p>We also need to decide on some atmospheric properties, specifically the ambient air density and speed of sound.</p><pre><code class="language-julia hljs">rho = 1.226  # kg/m^3
c0 = 340.0  # m/s</code></pre><p>And we need to decide on some operating point parameters. Let&#39;s assume that the blade is moving forward at <code>5.0 m/s</code> and rotating at <code>2200 rev/min</code>.</p><pre><code class="language-julia hljs">v = 0.0  # m/s
omega = 2200 * 2*pi/60  # rad/s</code></pre><p>We also need to decide over what time period we&#39;re going to calculate the blades&#39; acoustics. Let&#39;s do one rotation of the blade:</p><pre><code class="language-julia hljs">period = 2*pi/omega
num_src_times = 64
dt = 2*period/(num_src_times-1)
src_times = (0:num_src_times-1).*dt</code></pre><p>So at this point we have all the information needed to define the source elements in a frame of reference that&#39;s moving with the blade, i.e., rotating at a rate of <code>omega</code> and moving forward at a speed of <code>v</code> defined above. Let&#39;s do that. We want one source element for each radial station along the blade at each <code>src_time</code> and each of the <code>num_blades</code> blades. Sounds kind of complicated, but luckily Julia&#39;s broadcasting makes this easy. What we&#39;d like is an array <code>ses</code> of <code>CompactF1ASourceElement</code> types that has <code>size</code> <code>(num_src_times, num_radial, num_blades)</code>, where <code>ses[i, j, k]</code> holds the <code>CompactF1ASourceElement</code> at <code>src_time[i]</code>, <code>radii[j]</code>, and blade number <code>k</code>. So let&#39;s reshape the input arrays to make that happen.</p><pre><code class="language-julia hljs">θs = reshape(θs, 1, 1, :)
radii = reshape(radii, 1, :, 1)
dradii = reshape(dradii, 1, :, 1)
cs_area = reshape(cs_area, 1, :, 1)
fn = reshape(fn, 1, :, 1)
fc = reshape(fc, 1, :, 1)
src_times = reshape(src_times, :, 1, 1)  # This isn&#39;t really necessary.</code></pre><p>Now, the last thing we need to think about is the coordinate system we&#39;re defining these quantities in. Again, right now we are in the blade-fixed frame, which means the coordinate system is rotating with the blades at a rate of <code>omega</code> and translating with a velocity <code>v</code> in the positive x direction. The <code>CompactF1ASourceElement</code> constructor we&#39;ll use allows us to specify each source element&#39;s location in terms of <code>r</code> and <code>θ</code>, where <code>r</code> is the distance from the origin and <code>θ</code> is the polar angle from the positive y axis, rotating toward the positive <code>z</code> axis. So the <code>radii</code> and <code>θs</code> arrays are set up correctly. </p><p>Now, one of the tricky aspects of using an acoustic analogy is getting the direction of the loading on the integration surface (or line in the case of a compact formulation) right. An acoustic analogy requires the loading <em>on the fluid</em>, not on the solid body. One might expect that we just need to switch the sign on the <code>fn</code> and <code>fc</code> arrays above. That&#39;s true for the <code>fn</code> array, which represents the loading in the axial direction: if we imagine our propeller is moving in the positive x direction, the propeller would be pushing on the fluid in the negative x direction in normal operation. But what about the circumferential loading? In the blade-fixed frame, we assume the propeller is rotating about the x axis in a positive (i.e., right-handed) sense. So, if we imagine the situation for <code>θ=0</code>, the blade will be initially along the positive y axis, rotating toward the positive z axis. What direction will the circumferential loading on the fluid be? It will be positive, pointing in the same direction as the positive z axis. So we don&#39;t need to switch the sign on the <code>fc</code> array.</p><p>So let&#39;s create all the source elements:</p><pre><code class="language-julia hljs">ses = CompactF1ASourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times)
size(ses)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(64, 30, 2)</code></pre><p>The size of the source element array ended up like we wanted: <code>(num_src_times, num_radial, num_blades)</code>.</p><h3 id="The-Global-Reference-Frame"><a class="docs-heading-anchor" href="#The-Global-Reference-Frame">The Global Reference Frame</a><a id="The-Global-Reference-Frame-1"></a><a class="docs-heading-anchor-permalink" href="#The-Global-Reference-Frame" title="Permalink"></a></h3><p>At this point we have an array of <code>CompactF1ASourceElement</code> that describes the what each blade element &quot;source&quot; is doing from the perspective of the blade-fixed reference frame. But in order to perform the F1A calculation, we need to move the sources from the blade-fixed frame to the global reference frame, i.e., the one for which the fluid medium (air) appears to be stationary. This involves just setting the position and loading components of each <code>CompactF1ASourceElement</code> to the correct values (<code>y0dot</code> through <code>y3dot</code> and <code>f0dot</code> and <code>f1dot</code>). This could be done manually, but it&#39;s easier to use the <a href="https://github.com/OpenMDAO/KinematicCoordinateTransformations.jl">KinematicCoordinateTransformations.jl</a> package.</p><p>The first transformation we need to perform is a steady rotation around the x axis. So we create a <code>SteadyRotXTransformation</code>:</p><pre><code class="language-julia hljs">using KinematicCoordinateTransformations
t0 = 0.0  # Time at which the angle between the source and target coordinate systems is equal to offest.
offset = 0.0  # Angular offset between the source and target cooridante systems at t0.
rot_trans = SteadyRotXTransformation(t0, omega, offset)</code></pre><p>Next, we need to orient the rotation axis of the blades as it is the global frame. For example, let&#39;s say that it&#39;s pointed in the global positive z-axis direction, and the first blade is pointed in the positive y-axis direction. Then we can perform this transformation using the <code>ConstantLinearMap</code> transformation:</p><pre><code class="language-julia hljs">using LinearAlgebra: ×
using StaticArrays
rot_axis = @SVector [0.0, 0.0, 1.0]
blade_axis = @SVector [0.0, 1.0, 0.0]
global_trans = ConstantLinearMap(hcat(rot_axis, blade_axis, rot_axis×blade_axis))</code></pre><p>Finally, we need the blade to move with the appropriate forward velocity, and start from the desired location in the global reference frame:</p><pre><code class="language-julia hljs">y0_hub = @SVector [0.0, 0.0, 0.0]  # Position of the hub at time t0
v0_hub = SVector{3}(v.*rot_axis)   # Constant velocity of the hub in the global reference frame
const_vel_trans = ConstantVelocityTransformation(t0, y0_hub, v0_hub)</code></pre><p>Now we could apply each of these transformations to the <code>SourceElement</code> array. But it&#39;s more efficient to combine these three transformations into one, and then use that on the <code>SourceElements</code> using <code>compose</code>.</p><pre><code class="language-julia hljs">trans = compose.(src_times, Ref(const_vel_trans), compose.(src_times, Ref(global_trans), Ref(rot_trans)))</code></pre><p>Now <code>trans</code> will perform the three transformations from right to left (<code>rot_trans</code>, <code>global_trans</code>, <code>const_vel_trans</code>). Now we use it on <code>ses</code>:</p><pre><code class="language-julia hljs">ses = ses .|&gt; trans</code></pre><p>So now the <code>ses</code> has been transformed from the blade-fixed reference frame to the global reference frame. We could have created the source elements and transformed them all in one line, too, which is pretty slick:</p><pre><code class="language-julia hljs">ses = AcousticAnalogies.CompactF1ASourceElement.(rho, c0, radii, θs, dradii, cs_area, -fn, 0.0, fc, src_times) .|&gt; trans</code></pre><h2 id="2.-Perform-the-Advanced-Time-Calculation"><a class="docs-heading-anchor" href="#2.-Perform-the-Advanced-Time-Calculation">2. Perform the Advanced Time Calculation</a><a id="2.-Perform-the-Advanced-Time-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Perform-the-Advanced-Time-Calculation" title="Permalink"></a></h2><p>The <code>ses</code> object now describes how each blade element source is moving through the global reference frame over the time <code>src_time</code>. As it does this, it will emit acoustics that can be sensed by an acoustic observer (a human, or a microphone). The exact &quot;amount&quot; of acoustics the observer will experience depends on the relative location and motion between each source and the observer. So we&#39;ll need to define our acoustic observer before we can calculate the noise heard by it. For this example, we&#39;ll assume that our acoustic observer is stationary in the global frame.</p><pre><code class="language-julia hljs">x0 = @SVector [100*12*0.0254, 0.0, 0.0]  # 100 ft in meters
obs = StationaryAcousticObserver(x0)</code></pre><p>(Really, the observer should be moving with the same forward velocity as the blades themeselves, and so the observer should be constructed using a constant-velocity acoustic observer like this</p><pre><code class="language-julia hljs">obs_const_vel = ConstVelocityAcousticObserver(t0, x0, v0_hub)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AcousticAnalogies.ConstVelocityAcousticObserver{Float64, StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}(0.0, [30.48, 0.0, 0.0], [0.0, 0.0, 0.0])</code></pre><p>But we&#39;ll ignore that complication since the <code>v0_hub</code> velocity is so small for this example.)</p><p>Now, in order to perform the F1A calculation, we need to know when each acoustic disturbance emitted by the source arrives at the observer. This is referred to an  advanced time calculation, and is done this way:</p><pre><code class="language-julia hljs">obs_time = adv_time.(ses, Ref(obs))</code></pre><p>That returns an array the same size of <code>ses</code> of the time each acoustic disturbance reaches the observer <code>obs</code>:</p><pre><code class="language-julia hljs">@show size(obs_time)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">size(obs_time) = (64, 30, 2)</code></pre><h2 id="3.-Perform-the-F1A-Calculation"><a class="docs-heading-anchor" href="#3.-Perform-the-F1A-Calculation">3. Perform the F1A Calculation</a><a id="3.-Perform-the-F1A-Calculation-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Perform-the-F1A-Calculation" title="Permalink"></a></h2><p>We&#39;re finally ready to do the compact F1A calculation!</p><pre><code class="language-julia hljs">apth = noise.(ses, Ref(obs), obs_time)</code></pre><p>When called this way (notice the <code>.</code> after <code>noise</code>), the <code>noise</code> routine returns an array of <code>F1AOutput</code> <code>struct</code>s, the same size as <code>ses</code> and <code>obs_time</code>. Each <code>F1AOutput</code> <code>struct</code> has three components: the observer time <code>t</code>, the thickness/monopole part of the acoustic pressure <code>p_m</code>, and the loading/dipole part of the acoustic pressure <code>p_d</code>.</p><h2 id="4.-Combine-the-Acoustic-Pressures"><a class="docs-heading-anchor" href="#4.-Combine-the-Acoustic-Pressures">4. Combine the Acoustic Pressures</a><a id="4.-Combine-the-Acoustic-Pressures-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Combine-the-Acoustic-Pressures" title="Permalink"></a></h2><p>We now have a noise prediction for each of the individual source elements in <code>ses</code> at the acoustic observer <code>obs</code>. What we ultimately want is the <em>total</em> noise prediction at <code>obs</code>—we want to add all the acoustic pressures in <code>apth</code> together. But we can&#39;t add them directly, yet, since the observer times are not all the same. What we need to do is first interpolate the <code>apth</code> of each source onto a common observer time grid, and then add them up. We&#39;ll do this using the <code>AcousticAnalogies.combine</code> function.</p><pre><code class="language-julia hljs">bpp = period/num_blades  # blade passing period
obs_time_range = 2*bpp
num_obs_times = 128
apth_total = combine(apth, obs_time_range, num_obs_times, 1)</code></pre><p><code>combine</code> returns a single <code>F1AAcousticPressure</code> <code>struct</code> made up of <code>Vector</code>s—it is an &quot;struct of arrays&quot; and not an &quot;array of structs&quot; like <code>apth</code>:</p><pre><code class="language-julia hljs">@show typeof(apth) typeof(apth_total)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">typeof(apth) = Array{AcousticAnalogies.F1AOutput{Float64, Float64, Float64}, 3}
typeof(apth_total) = AcousticAnalogies.F1APressureTimeHistory{true, Vector{Float64}, Vector{Float64}, Float64, Float64}</code></pre><p>We can now have a look at the total acoustic pressure time history at the observer:</p><pre><code class="language-julia hljs">using AcousticMetrics
using GLMakie
fig = Figure()
ax1 = fig[1, 1] = Axis(fig, xlabel=&quot;time, blade passes&quot;, ylabel=&quot;monopole, Pa&quot;)
ax2 = fig[2, 1] = Axis(fig, xlabel=&quot;time, blade passes&quot;, ylabel=&quot;dipole, Pa&quot;)
ax3 = fig[3, 1] = Axis(fig, xlabel=&quot;time, blade passes&quot;, ylabel=&quot;total, Pa&quot;)
t_nondim = (AcousticMetrics.time(apth_total) .- AcousticMetrics.starttime(apth_total))./bpp
l1 = lines!(ax1, t_nondim, apth_total.p_m)
l2 = lines!(ax2, t_nondim, apth_total.p_d)
l3 = lines!(ax3, t_nondim, apth_total.p_m.+apth_total.p_d)
hidexdecorations!(ax1, grid=false)
hidexdecorations!(ax2, grid=false)
save(&quot;first_example-apth_total.png&quot;, fig)</code></pre><p><img src="../first_example-apth_total.png" alt/></p><p>We can now post-process the total acoustic pressure time history in <code>apth_total</code> in any way we&#39;d like.</p><h1 id="AcousticMetrics.jl-Support"><a class="docs-heading-anchor" href="#AcousticMetrics.jl-Support">AcousticMetrics.jl Support</a><a id="AcousticMetrics.jl-Support-1"></a><a class="docs-heading-anchor-permalink" href="#AcousticMetrics.jl-Support" title="Permalink"></a></h1><p>The <a href="../api/#AcousticAnalogies.combine"><code>combine</code></a> function returns a <code>F1AAcousticPressure</code> <code>struct</code>, which subtypes the <code>AbstractAcousticPressure</code> type from the AcousticMetrics.jl package. Because of this, any of the acoustic metric functions defined in AcousticMetrics.jl relevant to <code>AbstractAcousticPressure</code> objects can be used with the <code>F1AAcousticPressure</code> returned by <code>combine</code>:</p><pre><code class="language-julia hljs">using AcousticMetrics
# Calculate the overall sound pressure level from the acoustic pressure time history.
oaspl_from_apth = AcousticMetrics.OASPL(apth_total)
# Calculate the narrowband spectrum of mean-squared pressure.
nbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)
# Calculate the OASPL from the NBS.
oaspl_from_nbs = AcousticMetrics.OASPL(nbs)
(oaspl_from_apth, oaspl_from_nbs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(83.77798474356251, 83.77798474356251)</code></pre><p>The two approaches to calculate the OASPL give essentially the same result.</p><p>We could also find the spectrum of, say, mean-squared pressure and use that to find the sound pressure level (SPL):</p><pre><code class="language-julia hljs"># Get the spectrum of the mean-squared pressure, and then the frequency associated with it:
nbs = AcousticMetrics.MSPSpectrumAmplitude(apth_total)
freq = AcousticMetrics.frequency(nbs)
# Find the blade passing frequency, for plotting in the frequency in units of cycles per blade passes.
bpf = omega / (2*pi) * num_blades
# Find the sound pressure level from the spectrum of mean-square pressure.
pref = 20e-6  # usual reference pressure in Pa
spl = @. 10 * log10(nbs/pref^2)

# Plot
fig = Figure()
ax1 = fig[1, 1] = Axis(fig, xlabel=&quot;frequency, cycles per blade pass&quot;, ylabel=&quot;SPL, dB&quot;)
scatter!(ax1, freq./bpf, spl)
ax1.xticks = 0:15
xlims!(ax1, 0, 15)
ylims!(ax1, 20, 85)
save(&quot;first_example-spl.png&quot;, fig)</code></pre><p><img src="../first_example-spl.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../ccblade_example/">CCBlade.jl Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 17 April 2025 18:37">Thursday 17 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
